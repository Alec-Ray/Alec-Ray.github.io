{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Alec","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-07-05T16:02:52.000Z","updated":"2020-07-05T16:04:07.432Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Shell脚本常用命令","slug":"Shell脚本常用命令","date":"2021-01-23T12:57:28.000Z","updated":"2021-01-23T13:43:51.901Z","comments":false,"path":"2021/01/23/Shell脚本常用命令/","link":"","permalink":"http://yoursite.com/2021/01/23/Shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"cd 切回主目录 cd ../切回上一级 cd folderName切进某个文件夹 新建目录： mkdir AAA 新建一个文件，写入内容： echo “This is a test” &gt; test.txt 改名字： mv test.txt tt.txt 用户user的主目录就是/home/user 绝对路径类似 /home/gaia/develop_210120/blueshield.sh 新建一个sh文件： touch test.sh vi test.sh 进入vim编辑 按下键盘i 第一行放入#!/bin/sh 第二行可以echo “11111” 按键esc，输入:wq保存，:wq!强制保存 给test.sh赋予可执行权限，chmod +x test.sh 执行脚本./test.sh 也可以通过sh test.sh 执行脚本 指定目录下调用make指令 #!/bin/sh cd /home/gaia/develop_210120/ &amp;&amp; make readonly option is set (add ! to override) 报错，使用:wq!保存 shell root账户登录 sudo passwd root 输入root的密码即可 查看目录下文件的大小，用ll或者ll -alh 清理文件夹 rm -rf folderName win命令行root账户登录linux机器 1ssh root@192.168.172.249 查看大小 1df -h 只保留最近20天内的文件，其他都删除 1find .&#x2F; -mtime +20 -type d | xargs rm -rf 安装zip yum install zip 安装unzip yum install unzip You need to be root to perform this command.输入su 输入toot的密码 压缩 text 文件夹下所有文件： zip -r text.zip text 压缩 text 文件夹下除 txt1.txt 以外所有文件： zip -r text.zip text -x=’text/txt1.txt’ 压缩 text 文件夹下除 music文件夹 与 txt1.txt 以外所有文件： zip -r text.zip text -x=’text/music/*’ -x=’text/txt1.txt’ 注意：-r后第一个参数为压缩后的文件夹，第二个参数为想要压缩的文件夹。 ​ -x排除文件夹下所有文件时后面要加 * ​ -x的路径是根据当前所在地址的相对路径 汇总查看文件夹的大小 1du -sh * 切到指定目录压缩文件，压缩之前先删除上一次的压缩包，注意用&amp;&amp; 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 #!/bin/shcd /home/gaia/develop_210120/ &amp;&amp; rm -rf GoServer.zip &amp;&amp; zip -r GoServer.zip release -x ‘release/DedicateServer/*’","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}]},{"title":"Perforce的Trigger","slug":"Perforce的Trigger","date":"2021-01-23T11:57:28.000Z","updated":"2021-01-23T13:43:47.276Z","comments":false,"path":"2021/01/23/Perforce的Trigger/","link":"","permalink":"http://yoursite.com/2021/01/23/Perforce%E7%9A%84Trigger/","excerpt":"","text":"Perforce的trigger可以方便我们做一些提交后检查类的事情。 在游戏开发中，比如检测到本次提交含有策划的表格，就可以触发远程CI自动打表上传。 在Unreal项目中，引擎的源码更改是个很频繁的事情，为了方便策划和美术可以像unity一样打开编辑器，而不用自己手动编译，也可以利用此特性。 当检测到Engine和Project的Source目录，Plugins目录有提交，或者是.uplugin文件有变化，就可以远程触发CI开始构建编辑器，构建好的编辑器存到一个局域网的服务器上，本地再做一些更新编辑器的脚本就oK了 进去CMD，依次输入以下指令： p4 set P4PORT=192.168.255.255:1666 p4 set P4USER=Alec p4 set P4PASSWD=666666 p4 triggers 编辑完保存，关闭后如果出现，则说明语法有错误，需要检查下重新编辑 Error in triggers specification. 修改成功会提示以下消息： Triggers saved. 在使用时发现，trigger文件对一些转义字符的支持不太好，好像一些括号也会有问题，所以可以在版本中加入一个bat文件，让trigger触发后执行这个bat脚本，bat脚本里面要做什么就很自由了。这个bat要先传到Perforce的服务器中，不然保存trigger文件时会提示找不到文件，因为它找的是服务器上的文件。 一个编写Trigger的小例子： 123Triggers:submitTrigger2 change-commit //Test/Dev/Engine/... %//Test/Dev/SubmitCheck.bat%submitTrigger2 change-commit //Test/Dev/Projects/Test/... %//Test/Dev/SubmitCheck.bat%","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}]},{"title":"C++四种类型变换","slug":"C++四种类型变换","date":"2021-01-23T10:57:28.000Z","updated":"2021-01-23T15:26:21.473Z","comments":false,"path":"2021/01/23/C++四种类型变换/","link":"","permalink":"http://yoursite.com/2021/01/23/C++%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%8F%98%E6%8D%A2/","excerpt":"","text":"C++引入这几种强制类型变换的原因：C风格的强制类型转换很简单，均用 Type b = (Type)a 形式转换，但是这样不安全，容易出bug而且也较难排查。比如不经意间将指向const对象的指针转换成非const对象的指针，或者将基类对象指针转成了派生类对象的指针，这种转换很容易出问题。 static_cast类似C风格的强制转换，进行无条件转换，静态类型转换： 1）基类和子类之间的转换：其中子类指针转换为父类指针是安全的，但父类指针转换为子类指针是不安全的（基类和子类之间的动态类型转换建议用dynamic_cast）。 2）基本数据类型转换，enum，struct，int，char，float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。 3）把任何类型的表达式转换成void类型。 4）static_cast不能去掉类型的const、volatile属性（用const_cast）。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;struct Base &#123; virtual void Func() &#123; cout &lt;&lt; &quot;Base Func \\n&quot;; &#125;&#125;;struct Derive : public Base &#123; void Func() override &#123; cout &lt;&lt; &quot;Derive Func \\n&quot;; &#125;&#125;;int main() &#123; float f &#x3D; 1.23; cout &lt;&lt; &quot;f &quot; &lt;&lt; f &lt;&lt; endl; &#x2F;&#x2F;基本类型转换 int i &#x3D; static_cast&lt;int&gt;(f); cout &lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; endl; &#x2F;&#x2F;无关类型转换，编译错误 int *pi &#x3D; static_cast&lt;int *&gt;(&amp;f); &#x2F;&#x2F;子类指针转为父类指针 Derive d; d.Func(); Base *b &#x3D; static_cast&lt;Base *&gt;(&amp;d); b-&gt;Func(); return 0;&#125; const_cast去掉类型的const或volatile属性 12345678910111213int main() &#123; struct T &#123; int i; &#125;; const T a; &#x2F;&#x2F;a.i &#x3D; 10; &#x2F;&#x2F;直接修改const类型，编译错误 T &amp;b &#x3D; const_cast&lt;T&amp;&gt;(a); b.i &#x3D; 10; return 0;&#125; dynamic_cast有条件转换，动态类型转换，运行时检查类型安全（转换失败返回NULL）： 1）安全的基类和子类之间的转换，不能用于内置的基本数据类型的强制转换。 2）基类中一定要有虚函数，否则编译不通过。 3）相同基类不同子类之间的交叉转换，但结果返回NULL。 4）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。 用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数，因为dynamic_cast是运行时检查，检查需要运行时信息RTTI，而RTTI存储在虚函数表中。 需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中，只有定义了虚函数的类才有虚函数表。 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的； 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 下行转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F; 我是父类class Tfather&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;father&#39;s f()&quot; &lt;&lt; endl; &#125;&#125;; &#x2F;&#x2F; 我是子类class Tson : public Tfather&#123;public: void f() &#123; cout &lt;&lt; &quot;son&#39;s f()&quot; &lt;&lt; endl; &#125; int data; &#x2F;&#x2F; 我是子类独有成员&#125;; int main()&#123; Tfather father; Tson son; son.data &#x3D; 123; Tfather *pf; Tson *ps; &#x2F;* 上行转换：没有问题，多态有效 *&#x2F; ps &#x3D; &amp;son; pf &#x3D; dynamic_cast&lt;Tfather *&gt;(ps); pf-&gt;f(); &#x2F;* 下行转换（pf实际指向子类对象）：没有问题 *&#x2F; pf &#x3D; &amp;son; ps &#x3D; dynamic_cast&lt;Tson *&gt;(pf); ps-&gt;f(); cout &lt;&lt; ps-&gt;data &lt;&lt; endl; &#x2F;&#x2F; 访问子类独有成员有效 &#x2F;* 下行转换（pf实际指向父类对象）：含有不安全操作，dynamic_cast发挥作用返回NULL *&#x2F; pf &#x3D; &amp;father; ps &#x3D; dynamic_cast&lt;Tson *&gt;(pf); assert(ps !&#x3D; NULL); &#x2F;&#x2F; 违背断言，阻止以下不安全操作 ps-&gt;f(); cout &lt;&lt; ps-&gt;data &lt;&lt; endl; &#x2F;&#x2F; 不安全操作，对象实例根本没有data成员 &#x2F;* 下行转换（pf实际指向父类对象）：含有不安全操作，static_cast无视 *&#x2F; pf &#x3D; &amp;father; ps &#x3D; static_cast&lt;Tson *&gt;(pf); assert(ps !&#x3D; NULL); ps-&gt;f(); cout &lt;&lt; ps-&gt;data &lt;&lt; endl; &#x2F;&#x2F; 不安全操作，对象实例根本没有data成员 system(&quot;pause&quot;);&#125; reinterpret_cast仅重新解释类型，但没有进行二进制的转换： 1）转换的类型必须是一个指针，应用、算术类型、函数指针或者成员指针。 2）在比特级别上进行转换，可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。但不能将非32bit的实例转成指针。3） 最普通的用途就是在函数指针类型之间进行转换。4） 很难保证移植性。 什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用这种强制类型转换方式。 12345678int main() &#123; int data &#x3D; 10; int *pi &#x3D; &amp;data; float *fpi &#x3D; reinterpret_cast&lt;float *&gt;(pi); return 0;&#125; 总结去const属性用const_cast 基本类型转换用static_cast 多态类之间的类型转换用dynamic_cast 不同类型的指针类型转换用reinterpret_cast 参考链接： https://mp.weixin.qq.com/s/6YW7VX787X7kZiRBLbVn-Q https://blog.csdn.net/weixin_44212574/article/details/89043854 https://www.cnblogs.com/evenleee/p/10382335.html","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++内存分布","slug":"C++内存分布","date":"2021-01-14T12:57:28.000Z","updated":"2021-01-14T16:05:10.170Z","comments":false,"path":"2021/01/14/C++内存分布/","link":"","permalink":"http://yoursite.com/2021/01/14/C++%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/","excerpt":"","text":"C++内存分布一个应用程序通常会占用以下空间，也就是内存四区： 堆区，栈区，数据区，代码区 栈区主要存储一些临时变量，临时变量包括了局部变量、返回值、参数、返回地址等，当这些变量超出了当前作用域时将会自动弹出。该栈的最大存储是有大小的，大致是8192kb，超过该大小将会造成栈溢出。 堆区指的是一个比较大的内存空间，主要用于对动态内存的分配；在程序开发中一般是开发人员进行分配与释放，若在程序结束时都未释放，系统将会自动进行回收。 数据区包含静态存储区和常量区： 静态存储区指的是主要存放全局变量、静态变量的区域，编译器编译时分配内存。将变量定义的类型前加static,则该变量存储在静态存储区static:1）只初始化一次2）只有程序退出才释放 常量区，存放常量，只读状态，不可修改，程序结束后由系统释放 代码区，所有代码编译后的cpu指令会存储在这里 12345678910111213141516#include&lt;stdio.h&gt;int e &#x3D; 0;int main()&#123; int a &#x3D; 0; int b &#x3D; 0; char c&#x3D;&#39;0&#39;; static int d &#x3D; 0; printf(&quot;变量a的地址是：%d\\n变量b的地址是：%d\\n变量c的地址是：%d\\n&quot;, &amp;a, &amp;b, &amp;c); printf(&quot;静态变量d的地址是：%d\\n&quot;, &amp;d); printf(&quot;全局变量e的地址是：%d\\n&quot;, &amp;e);&#125; 结果： 变量a的地址是：6487628变量b的地址是：6487624变量c的地址是：6487623静态变量d的地址是：4223028全局变量e的地址是：4223024 可以看出，a,b,c都在栈区，三个变量同属于一个栈内，所以它们地址的索引是连续性的。栈区的地址向下增长，因为栈是先进后出，栈底又是最大地址 d和e说明了全局变量与静态变量都应该存储在静态区 栈区、数据区都是使用栈结构对数据进行存储。 new/delete和malloc/free的区别:C++ 中使用 new 和 delete 从堆中分配和释放内存，new 和 delete 是C++语言中的两个运算符，malloc/free是C语言标准库中的两个函数 new/delete 比 malloc/free ，都是用来申请动态内存的 new/delete 比 malloc/free 多做了一些事情，new 相对于 malloc 会额外的做一些初始化工作，比如调用构造函数。delete 相对于 free 多做一些清理工作，比如调用析构函数。malloc/free无法调用构造和析构的原因是，他是库函数不是运算符，不在编译器控制权限之内 malloc得到的指针无类型，new出来的指针是带有类型信息的 new/delete 比 malloc/free 要成对使用，free释放new出来的对象会导致无法析构而出错。delete释放malloc出来的内存，理论上不会出错，但是程序可读性会变差 delete和delete[]的区别123int *a &#x3D; new int[10];delete a;delete[] a; 上面这种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数。 如果 ptr 代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么：delete ptr 代表用来释放内存，且只用来释放 ptr 指向的内存。delete[] rg 用来释放rg指向的内存，！！还逐一调用数组中每个对象的destructor！！ 对于像 int/char/long/int*/struct 等等简单数据类型，由于对象没有 destructor ，所以用 delete 和 delete []是一样的。但是如果是 C++ 对象数组就不同了！ 1234567891011121314class A &#123; private: char *m_cBuffer; int m_nLen; &#96;&#96; public: A()&#123; m_cBuffer &#x3D; new char[m_nLen]; &#125; ~A() &#123; delete [] m_cBuffer; &#125; &#125;; A *a &#x3D; new A[10]; delete a; &#x2F;&#x2F;仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏 delete[] a; &#x2F;&#x2F;调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空间 关于 new[] 和 delete[]，其中又分为两种情况： (1) 为基本数据类型分配和回收空间； (2) 为自定义类型分配和回收空间； 对于 (1)，上面提供的程序已经证明了 delete[] 和 delete 是等同的。但是对于 (2)，情况就发生了变化。 例子： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Babe&#123;public: Babe() &#123; cout &lt;&lt; \\&quot;Create a Babe to talk with me\\&quot; &lt;&lt; endl; &#125; ~Babe() &#123; cout &lt;&lt; \\&quot;Babe don\\&#39;t Go away,listen to me\\&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Babe* pbabe &#x3D; new Babe[3]; delete pbabe; pbabe &#x3D; new Babe[3]; delete[] pbabe; return 0;&#125; 结果： 12345678910Create a babe to talk with meCreate a babe to talk with meCreate a babe to talk with meBabe don\\&#39;t go away,listen to meCreate a babe to talk with meCreate a babe to talk with meCreate a babe to talk with meBabe don\\&#39;t go away,listen to meBabe don\\&#39;t go away,listen to meBabe don\\&#39;t go away,listen to me 只使用 delete 的时候只出现一个 Babe don’t go away,listen to me，而使用 delete[] 的时候出现 3 个 Babe don’t go away,listen to me。不过不管使用 delete 还是 delete[] 那三个对象的在内存中都被删除，既存储位置都标记为可写，但是使用 delete 的时候只调用了 pbabe[0] 的析构函数，而使用了 delete[] 则调用了 3 个 Babe 对象的析构函数。 反正不管怎样都是把存储空间释放了，有什么区别呢？ 关键在于调用析构函数上。此程序的类没有使用操作系统的系统资源（比如：Socket、File、Thread等），所以不会造成明显恶果。如果你的类使用了操作系统资源，单纯把类的对象从内存中删除是不妥当的，因为没有调用对象的析构函数会导致系统资源不被释放，这些资源的释放必须依靠这些类的析构函数。所以，在用这些类生成对象数组的时候，用 delete[] 来释放它们才是王道。而用 delete 来释放也许不会出问题，也许后果很严重，具体要看类的代码了。 参考链接：https://mp.weixin.qq.com/s/HAPtnOGhF2z17RhqMmUpNg","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"CPU缓存L1/L2/L3","slug":"CPU缓存L1L2L3","date":"2020-12-26T06:25:53.000Z","updated":"2020-12-27T06:51:15.764Z","comments":false,"path":"2020/12/26/CPU缓存L1L2L3/","link":"","permalink":"http://yoursite.com/2020/12/26/CPU%E7%BC%93%E5%AD%98L1L2L3/","excerpt":"","text":"CPU(Central Processing Units)RAM(Random Access Memory)ROM（Read-Only Memory） 当RAM处于正常工作时，可以从RAM中读出数据，也可以往RAM中写入数据。与ROM相比较，RAM的优点是读/写方便、使用灵活，特别适用于经常快速更换数据的场合。 CPU自身具有更快的存储单元，我们称之为缓存。计算机的内存具有基于速度的层次结构，而缓存位于该层次结构的顶部，是最快的。它也是最靠近中央处理的地方，它是CPU本身的一部分。高速缓存是静态RAM(SRAM)，而系统RAM是动态RAM(DRAM)。静态RAM是一种可以保存数据但是不要用一直刷新的存储器，与DRAM不同，SRAM更加适合用于高速缓存。 缓存功能工作流程：当我们运行程序的时候，这些指令必须从主存储器取指令到CPU。这是内存层次结构起作用的地方。数据首先被加载到RAM中，然后被发送到CPU。因为CPU每秒都能够执行大量指令。为了充分利用其功能，CPU需要访问超高速内存，这是缓存的来源。内存控制器执行从RAM中获取数据并将其发送到缓存的工作。根据系统中使用的CPU，此控制器可以位于主板的北桥芯片组上，也可以位于CPU本身内部。然后，高速缓存在CPU内执行数据的来回传输。内存的层次结构也存在于缓存中。 CPU缓存分为三个主要的级别，即L1，L2和L3。这里的层次结构是根据缓存速度来划分的。L1(1级)高速缓存是计算机系统中存在的最快的内存。就访问优先级而言，L1缓存具有CPU在完成特定任务时最可能需要的数据。就其大小而言，L1高速缓存通常最多可达256KB。但是，一些真正功能强大的CPU现在将其占用近1MB。现在，某些服务器芯片组(如Intel的高端Xeon CPU)具有1-2MB的一级缓存。 L1缓存通常也分为两种方式，分为指令缓存和数据缓存。指令高速缓存处理有关CPU必须执行的操作的信息，而数据高速缓存则保留要在其上执行操作的数据。L2(2级)缓存比L1缓存慢，但大小更大。它的大小通常在256KB到8MB之间，尽管更新，功能强大的CPU往往会超过此大小。L2高速缓存保存下一步可能由CPU访问的数据。在大多数现代CPU中，L1和L2高速缓存位于CPU内核本身，每个内核都有自己的高速缓存。L3(3级)高速缓存是最大的高速缓存存储单元，也是最慢的一个。它的范围从4MB到50MB以上。现代CPU在CPU裸片上具有用于L3高速缓存的专用空间，并且占用了很大一部分空间。 缓存命中或未命中以及延迟： 数据会从RAM依次流到L3高速缓存，然后是L2，最后是L1。当处理器正在寻找要执行操作的数据时，它首先尝试在L1高速缓存中找到它。如果CPU能够找到它，则该情况称为高速缓存命中。然后，它继续在L2和L3中找到它。如果找不到数据，它将尝试从主内存访问数据。这称为高速缓存未命中（cache miss）。现在，众所周知，高速缓存旨在加快主内存和CPU之间的数据传输。 参考链接：https://mp.weixin.qq.com/s/FY8sEX4acEUpCu_6ntArYw","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"RTTNW-ch4：Perlin Noise","slug":"rttnw-ch4：perlin-noise","date":"2018-07-02T13:54:53.000Z","updated":"2020-07-05T08:56:51.344Z","comments":false,"path":"2018/07/02/rttnw-ch4：perlin-noise/","link":"","permalink":"http://yoursite.com/2018/07/02/rttnw-ch4%EF%BC%9Aperlin-noise/","excerpt":"","text":"柏林噪声由Ken Perlin发明，很多人使用柏林噪音来获得一个比较酷的纹理效果。 Perlin纹理不会像这样返回白噪声： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070201.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070201.jpg) 相反，它返回类似于模糊白噪声的东西： [![](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070202.jpg) 除了简单迅速以外，柏林噪声的另一个关键特性是它对于相同的输入永远返回相同的随机数字，输入点附近的点返回近似的数字。 class perlin { public: float noise(const vec3&amp; p) const { float u = p.x() - floor(p.x()); float v = p.y() - floor(p.y()); float w = p.z() - floor(p.z()); int i = int(4 * p.x()) &amp; 255; int j = int(4 * p.y()) &amp; 255; int k = int(4 * p.z()) &amp; 255; return ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]]; } static float *ranfloat; static int *perm_x; static int *perm_y; static int *perm_z;}; static float* perlin_generate() { float * p = new float[256]; for (int i = 0; i &lt; 256; ++i) p[i] = (rand() % (100) / (float)(100)); return p;} void permute(int *p, int n) { for (int i = n-1; i &gt; 0; i–) { int target = int((rand() % (100) / (float)(100))*(i+1)); int tmp = p[i]; p[i] = p[target]; p[target] = tmp; } return;} static int* perlin_generate_perm() { int * p = new int[256]; for (int i = 0; i &lt; 256; i++) p[i] = i; permute(p, 256); return p;} float *perlin::ranfloat = perlin_generate();int *perlin::perm_x = perlin_generate_perm();int *perlin::perm_y = perlin_generate_perm();int *perlin::perm_z = perlin_generate_perm(); 生成噪声纹理： class noise_texture : public texture { public: noise_texture() {} virtual vec3 value(float u, float v, const vec3&amp; p) const { return vec3(1, 1, 1)*noise.noise(p); } perlin noise;}; 使用两个sphere表现噪声纹理： hitable *RandomScene() { texture *pertext = new noise_texture(); hitable **list = new hitable*[2]; list[0] = new sphere(vec3(0, -1000, 0), 1000, new lambertian(pertext)); list[1] = new sphere(vec3(0, 2, 0), 2, new lambertian(pertext)); return new hitable\\_list(list, 2);} 效果如下： [{% image http://www.wjgbaby.com/wp-content/uploads/2018/07/18070203.jpg '](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070203.jpg)' '' %} 为了使其平滑，我们可以线性插值： inline float perlin_interp(float c[2][2][2], float u, float v, float w) { float accum = 0; for (int i=0; i &lt; 2; i++) for (int j=0; j &lt; 2; j++) for (int k=0; k &lt; 2; k++) accum +=(i*u + (1 - i)*(1 - u))* (j*v + (1 - j)*(1 - v))* (k*w + (1 - k)*(1 - w))*c[i][j][k]; return accum;} class perlin { public: float noise(const vec3&amp; p) const { float u = p.x() - floor(p.x()); float v = p.y() - floor(p.y()); float w = p.z() - floor(p.z()); int i = floor(p.x()); int j = floor(p.y()); int k = floor(p.z()); float c\\[2\\]\\[2\\]\\[2\\]; for (int di=0; di &lt; 2; di++) for (int dj=0; dj &lt; 2; dj++) for (int dk=0; dk &lt; 2; dk++) c\\[di\\]\\[dj\\]\\[dk\\] = ranfloat\\[perm\\_x\\[(i+di) &amp; 255\\] ^ perm\\_y\\[(j+dj) &amp; 255\\] ^ perm\\_z\\[(k+dk) &amp; 255\\]\\]; return perlin\\_interp(c, u, v, w); } static float \\*ranfloat; static int \\*perm\\_x; static int \\*perm\\_y; static int \\*perm\\_z;}; 效果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070204.jpg) 使用hermite立方体来舍入插值，使图像更平滑： class perlin { public: float noise(const vec3&amp; p) const { float u = p.x() - floor(p.x()); float v = p.y() - floor(p.y()); float w = p.z() - floor(p.z()); u = u*u*(3 - 2 * u); v = v*v*(3 - 2 * v); w = w*w*(3 - 2 * w); int i = floor(p.x()); int j = floor(p.y()); int k = floor(p.z()); float c\\[2\\]\\[2\\]\\[2\\]; for (int di=0; di &lt; 2; di++) for (int dj=0; dj &lt; 2; dj++) for (int dk=0; dk &lt; 2; dk++) c\\[di\\]\\[dj\\]\\[dk\\] = ranfloat\\[perm\\_x\\[(i+di) &amp; 255\\] ^ perm\\_y\\[(j+dj) &amp; 255\\] ^ perm\\_z\\[(k+dk) &amp; 255\\]\\]; return perlin\\_interp(c, u, v, w); } static float \\*ranfloat; static int \\*perm\\_x; static int \\*perm\\_y; static int \\*perm\\_z;}; 效果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070205.jpg) 缩放输入点使其变化更快： class noise_texture : public texture { public: noise_texture() {} noise_texture(float sc) : scale(sc) {} virtual vec3 value(float u, float v, const vec3&amp; p) const { //return vec3(1, 1, 1)*noise.noise(p); return vec3(1, 1, 1)*noise.noise(scale * p); } perlin noise; float scale;}; hitable *RandomScene() { texture *pertext = new noise_texture(3); hitable **list = new hitable*[2]; list[0] = new sphere(vec3(0, -1000, 0), 1000, new lambertian(pertext)); list[1] = new sphere(vec3(0, 2, 0), 2, new lambertian(pertext)); return new hitable\\_list(list, 2);} 效果如下： [{% image http://www.wjgbaby.com/wp-content/uploads/2018/07/18070206.jpg '](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070206.jpg)' '' %} 仍然能看到网格，可能是因为该模式的最小值和最大值总是完全落在整数x / y / z上。 肯佩林非常聪明的把戏是在格点上放置随机单位矢量（而不是浮点数），并使用点积来移动格子上的最小和最大值。 所以，首先我们需要将随机浮点数更改为随机向量： #ifndef PERLINH#define PERLINH #include “vec3.h” inline float perlin_interp(vec3 c[2][2][2], float u, float v, float w) { float uu = u*u*(3-2*u); float vv = v*v*(3-2*v); float ww = w*w*(3-2*w); float accum = 0; for (int i=0; i &lt; 2; i++) for (int j=0; j &lt; 2; j++) for (int k=0; k &lt; 2; k++) { vec3 weight\\_v(u-i, v-j, w-k); accum += (i\\*uu + (1-i)\\*(1-uu))\\* (j\\*vv + (1-j)\\*(1-vv))\\* (k\\*ww + (1-k)\\*(1-ww))\\*dot(c\\[i\\]\\[j\\]\\[k\\], weight\\_v); } return accum;} class perlin { public: float noise(const vec3&amp; p) const { float u = p.x() - floor(p.x()); float v = p.y() - floor(p.y()); float w = p.z() - floor(p.z()); int i = floor(p.x()); int j = floor(p.y()); int k = floor(p.z()); vec3 c\\[2\\]\\[2\\]\\[2\\]; for (int di=0; di &lt; 2; di++) for (int dj=0; dj &lt; 2; dj++) for (int dk=0; dk &lt; 2; dk++) c\\[di\\]\\[dj\\]\\[dk\\] = ranvec\\[perm\\_x\\[(i+di) &amp; 255\\] ^ perm\\_y\\[(j+dj) &amp; 255\\] ^ perm\\_z\\[(k+dk) &amp; 255\\]\\]; return perlin\\_interp(c, u, v, w); } static vec3 \\*ranvec; static int \\*perm\\_x; static int \\*perm\\_y; static int \\*perm\\_z;}; static vec3* perlin_generate() { vec3 * p = new vec3[256]; for ( int i = 0; i &lt; 256; ++i ) p[i] = unit_vector(vec3(-1 + 2*(rand() % (100) / (float)(100)), -1 + 2*(rand() % (100) / (float)(100)), -1 + 2*(rand() % (100) / (float)(100)))); return p;} void permute(int *p, int n) { for (int i = n-1; i &gt; 0; i–) { int target = int((rand() % (100) / (float)(100))*(i+1)); int tmp = p[i]; p[i] = p[target]; p[target] = tmp; } return;} static int* perlin_generate_perm() { int * p = new int[256]; for (int i = 0; i &lt; 256; i++) p[i] = i; permute(p, 256); return p;} vec3 *perlin::ranvec = perlin_generate();int *perlin::perm_x = perlin_generate_perm();int *perlin::perm_y = perlin_generate_perm();int *perlin::perm_z = perlin_generate_perm(); #endif 效果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070207.jpg) 通常使用具有多个相加频率的复合噪声。 这通常称为混乱，并且是重复调用的噪音总和： float turb(const vec3&amp; p, int depth=7) const { float accum = 0; vec3 temp_p = p; float weight = 1.0; for (int i = 0; i &lt; depth; i++) { accum += weight*noise(temp_p); weight *= 0.5; temp_p *= 2; } return fabs(accum);} 这里fabs（）是math.h绝对值函数。 效果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070208.jpg) 做一个类似大理石纹理的效果： class noise_texture : public texture { public: noise_texture() {} noise_texture(float sc) : scale(sc) {} virtual vec3 value(float u, float v, const vec3&amp; p) const { return vec3(1,1,1)*noise.turb(scale * p); } perlin noise; float scale;}; 效果如下： 参考书籍：《Ray Tracing The Next Week》 RTTNW系列项目地址：GitHub","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTTNW-ch3：Solid Textures","slug":"rttnw-ch3：solid-textures","date":"2018-07-01T15:44:21.000Z","updated":"2020-07-05T08:56:51.342Z","comments":false,"path":"2018/07/01/rttnw-ch3：solid-textures/","link":"","permalink":"http://yoursite.com/2018/07/01/rttnw-ch3%EF%BC%9Asolid-textures/","excerpt":"","text":"图形中的纹理通常表示在表面上生成颜色的函数，我们将首先使所有颜色成为一种纹理。 class texture { public: virtual vec3 value(float u, float v, const vec3&amp; p) const = 0;}; class constant_texture : public texture { public: constant_texture() { } constant_texture(vec3 c) : color(c) { } //value函数是得到某个点的颜色的函数，会在不同纹理上重写 virtual vec3 value(float u, float v, const vec3&amp; p) const { return color; } vec3 color;}; 我们通过一个指向纹理的指针来替换vec3颜色来制作纹理材质，这样的话我们是赋值的纹理而不是颜色。 //漫反射材质class lambertian : public material { public: lambertian(texture *a) : albedo(a) {} //将求反射光线的部分放到了材质类的scatter()方法里，每个材质可以自己定义其反射光线 //获取漫反射的反射光线；获取材料的衰减系数; virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const { vec3 target = rec.p + rec.normal + random_in_unit_sphere(); scattered = ray(rec.p, target-rec.p); attenuation = albedo-&gt;value(0,0, rec.p); return true; } texture \\*albedo;}; 我们曾经使用：new lambertian(vec3(0.5, 0.5, 0.5)) 现在我们要把它替换为：new constant_texture(vec3(…)) 例如这样写：new lambertian(new constant_texture(vec3(0.5, 0.5, 0.5)))) 我们可以通过正弦和余弦的符号以常规交替来创建一个检查器纹理，下面写一个棋盘纹理，这个纹理会按棋盘格的方式分割两个不同的纹理 class checker_texture : public texture { public: checker_texture() { } checker_texture(texture *t0, texture *t1): even(t0), odd(t1) { } virtual vec3 value(float u, float v, const vec3&amp; p) const { float sines = sin(10*p.x())*sin(10*p.y())*sin(10*p.z()); if (sines &lt; 0) return odd-&gt;value(u, v, p); else return even-&gt;value(u, v, p); } texture *odd; texture *even;}; 上面的棋盘纹理可以是一个恒定的纹理或者一个程序化的纹理，这是Pat Hanrahan在上世纪80年代提出的着色网格原则。 我们将棋盘纹理添加到地面上，也就是添加到我们的第一个球上： texture *checker = new checker_texture(new constant_texture(vec3(0.2, 0.3, 0.1)), new constant_texture(vec3(0.9, 0.9, 0.9)));list[0] = new sphere(vec3(0, -1000, 0), 1000, new lambertian(checker)); 效果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/07/18070101.jpg) 我们试下渲染两个带有棋盘纹理的球： texture *checker = new checker_texture(new constant_texture(vec3(0.2, 0.3, 0.1)), new constant_texture(vec3(0.9, 0.9, 0.9)));int n = 50;hitable **list = new hitable*[n + 1];list[0] = new sphere(vec3(0, -10, 0), 10, new lambertian(checker));list[1] = new sphere(vec3(0, 10, 0), 10, new lambertian(checker)); return new hitable_list(list, 2); 调整摄像机： vec3 lookform(13.0f, 2.0f, 3.0f);vec3 lookat(0, 0, 0);float dist_to_focus = (lookform - lookat).length();float aperture = 0.0f; camera cam(lookform, lookat, vec3(0, 1, 0), 20, float(nx) / float(ny), aperture, 0.7*dist_to_focus,0.0,1.0); 效果如下： 参考书籍：《Ray Tracing The Next Week》 RTTNW系列项目地址：GitHub","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTTNW-ch2：Bounding Volume Hierarchies","slug":"rttnw-ch2：bounding-volume-hierarchies","date":"2018-06-28T18:21:55.000Z","updated":"2020-07-05T08:56:51.340Z","comments":false,"path":"2018/06/29/rttnw-ch2：bounding-volume-hierarchies/","link":"","permalink":"http://yoursite.com/2018/06/29/rttnw-ch2%EF%BC%9Abounding-volume-hierarchies/","excerpt":"","text":"这部分是迄今为止我们正在研究的光线追踪器中最困难的部分。 我们的光线与物体相交点是光线追踪器的主要时间瓶颈，时间是与物体的数量呈线性关系。但它是对同一个模型的重复搜索，所以我们可以使用二分搜索进行对数查找。 两个最常见的排序方法是划分空间和划分对象。后者通常是编码起来更容易，而且大多数模型的运行速度都很快。 关键在于在找到一个边界体积包围所有物体。 if (ray hits bounding object) return whether ray hits bounded objectselse return false 我们要把物体分离到不同的边界框中去，任何一个物体都在一个边界盒中，边界盒有可能重叠。如果我们使用矩形分成红色和蓝色两组，得到如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/06/18062901.png) 红色框和蓝色框都被包围在紫色盒子中，但是它们可能会重叠，而且它们不是有序的 ，它们都在里面。 所以树上显示的树没有左孩子和右孩子的概念。 if (hits purple) hit0 = hits blue enclosed objects hit1 = hits red enclosed objects if (hit0 or hit1) return true and info of closer hitreturn false 一个好的射线与层次包围相交需要快速，并且边界需要紧凑，轴对齐是个不错的方案。 从现在开始，我们将调用轴对齐的边界矩形平行六面体（真的，也就是说，他们需要如何调用）轴对齐边界框或AABB。 任何你想用来与AABB相交的方法很好。 所有我们需要知道的是否我们击中了它; 我们不需要相交点或法线或任何东西需要我们显示的对象。 大多数人使用“slab”方法。 这是基于n维的观察AABB只是n轴对齐的区间的交集，通常称为“平板”。 间隔只是两个端点之间的点，例如，x使得3 &lt;x &lt;5，或者更简洁地x in(3,5)。 在2D中，两个重叠的区间构成一个2D AABB（一个矩形）：[ 在3D中，这些边界是平面。平面的方程为x /Bx[/latex] 在一维空间中判定一次命中的关键是在t时间间隔内要有重叠。在二维空间中，如果有命中，绿色和蓝色会有一个重叠，如下面的那条射线。 用代码描述“在slab的t间隔是否重叠”： compute (tx0, tx1)compute (ty0, ty1)return overlap?( (tx0, tx1), (ty0, ty1)) 在3D中，slab方法依然可以工作，这也是人们喜欢它的原因。 compute (tx0, tx1)compute (ty0, ty1)compute (tz0, tz1)return overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1)) 有一些注意事项我们要知道，首先，假设射线在负x方向上行进。间隔（tx0，tx1）如上所述计算可能会逆转，例如（7,3）。第二，那里的鸿沟可能会给我们带无限可能。如果射线源位于一个slab边界上，我们可以得到一个NaN。那里 这些问题在许多光线追踪器的AABB中处理的方式有很多。 （也有像SIMD这样的矢量化问题，我们不在这里讨论。) 目的，只要我们使速度合理快速，这不太可能成为主要瓶颈，所以让我们走最简单的，无论如何，这往往是最快的！首先让我们看看计算间隔： [latex]tx_{0}=(x_{0}-Ax)/Bx[/latex]， [latex]tx_{1}=(x_{1}-Ax)/Bx[/latex] 一个麻烦事是如果Bx=0，造成分离为0.这样的射线有的是在平板内的，有些不在，而且这个0会带正负号。在IEEE浮点标准下，在Bx=0时，t0和t1会都是 正无穷或者负无穷，反正不是x0和x1之间的数字，所以我们可以使用最大值和最小值来解决问题 [latex]tx_{0}=min((x_{0}-Ax)/Bx,(x_{1}-Ax)/Bx)[/latex]， [latex]tx_{1}=min((x_{0}-Ax)/Bx,(x_{1}-Ax)/Bx)[/latex] 如果我们这样做，剩下的麻烦情况是如果Bx = 0并且x0-Ax = 0或者x1-Ax= 0，所以我们得到一个NaN。在这种情况下，我们可以返回不命中作为结果。 现在，我们来看看这个重叠函数。假设我们可以假设间隔不是反转（所以第一个值小于间隔中的第二个值），我们想要在那种情况下返回true。布尔重叠也计算重叠区间（f，F）（d，D）和（e，E）的间隔为： bool overlap(d, D, e, E, f, F)f = max(d, e)F = min(D, E)return (f &lt; F) 如果有任何NaN在那里运行，比较将返回false，所以我们需要确保我们的边界盒有一些填充。 创建AABB包围盒的类： inline float ffmin(float a, float b) { return a &lt; b ? a : b; }inline float ffmax(float a, float b) { return a &gt; b ? a : b; } class aabb { public: aabb() {} aabb(const vec3&amp; a, const vec3&amp; b) { _min = a; _max = b;} vec3 min() const {return \\_min; } vec3 max() const {return \\_max; } bool hit(const ray&amp; r, float tmin, float tmax) const { for (int a = 0; a &lt; 3; a++) { float t0 = ffmin((\\_min\\[a\\] - r.origin()\\[a\\]) / r.direction()\\[a\\], (\\_max\\[a\\] - r.origin()\\[a\\]) / r.direction()\\[a\\]); float t1 = ffmax((\\_min\\[a\\] - r.origin()\\[a\\]) / r.direction()\\[a\\], (\\_max\\[a\\] - r.origin()\\[a\\]) / r.direction()\\[a\\]); tmin = ffmax(t0, tmin); tmax = ffmin(t1, tmax); if (tmax &lt;= tmin) return false; } return true; } vec3 \\_min; vec3 \\_max;}; 我们现在需要添加一个函数来计算所有需求的边界框，并生成它们，这是个重载函数： class hitable { public: //hit()虚函数 virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0; virtual bool bounding_box(float t0, float t1, aabb&amp; box) const = 0;}; sphere的bounding_box函数： bool sphere ::bounding_box(float t0, float t1, aabb&amp; box) const { box = aabb(center - vec3(radius, radius, radius), center + vec3(radius, radius, radius)); return true;} moving_sphere的bounding_box函数： bool moving_sphere::bounding_box(float t0, float t1, aabb&amp; box) const { aabb box0(center(t0) - vec3(radius, radius, radius), center(t0) + vec3(radius, radius, radius)); aabb box1(center(t1) - vec3(radius, radius, radius), center(t1) + vec3(radius, radius, radius)); box = surrounding_box(box0, box1); return true;} hitable_list的bounding_box函数： bool hitable_list::bounding_box(float t0, float t1, aabb&amp; box) const { if (list_size &lt; 1) return false; aabb temp_box; bool first_true = list[0]-&gt;bounding_box(t0, t1, temp_box); if (!first_true) return false; else box = temp_box; for (int i = 1; i &lt; list_size; i++) { if(list[0]-&gt;bounding_box(t0, t1, temp_box)) { box = surrounding_box(box, temp_box); } else return false; } return true;} 对于移动球体，我们可以在t0处取球体的方框，在t1处取球体的方框，将t0时的盒子和t1时的盒子放进一个大盒子里： aabb surrounding_box(aabb box0, aabb box1) { vec3 small( fmin(box0.min().x(), box1.min().x()), fmin(box0.min().y(), box1.min().y()), fmin(box0.min().z(), box1.min().z())); vec3 big ( fmax(box0.max().x(), box1.max().x()), fmax(box0.max().y(), box1.max().y()), fmax(box0.max().z(), box1.max().z())); return aabb(small,big);} 一个BVH也将是一个可以击中的 ，就像击中列表一样。 这真的是一个容器，但是 它可以回应询问“这光线击中了你？”。 一个设计问题是我们是否有两个类，一个用于树，另一个用于树中的节点; 或者我们只有一个类，并且根只是我们指向的一个节点。这里我们使用一个类： class bvh_node : public hitable { public: bvh_node() {} bvh_node(hitable **l, int n, float time0, float time1); virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const; virtual bool bounding_box(float t0, float t1, aabb&amp; box) const; hitable *left; hitable *right; aabb box;}; bool bvh_node::bounding_box(float t0, float t1, aabb&amp; b) const { b = box; return true;} 这里的左右节点都是基类Hitable类型，这样BVH的子节点也有可能是另一个BVH节点或者是一个物体，如果是BVH的话就继续检测其子节点： bool bvh_node::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const { if (box.hit(r, t_min, t_max)) { hit_record left_rec, right_rec; bool hit_left = left-&gt;hit(r, t_min, t_max, left_rec); bool hit_right = right-&gt;hit(r, t_min, t_max, right_rec); if (hit_left &amp;&amp; hit_right) { if (left_rec.t &lt; right_rec.t) rec = left_rec; else rec = right_rec; return true; } else if (hit_left) { rec = left_rec; return true; } else if (hit_right) { rec = right_rec; return true; } else return false; } else return false;} 任何效率结构中最复杂的部分就是构建这个结构。关于BVH的一个很酷的事情是，只要BVH节点中的对象列表被分成两个子列表，命中检测就可以工作。如果合适分隔，这将最高效，为了生成一个尽量小的，包含所有对象的盒子，我们让每个节点沿一个轴分割列表： 1. 随机选择一个轴 2. 将节点内的对象进行排序 3. 左右子树各放一半 当列表进入是两个元素时，我在每个子树中放一个并结束递归。遍历算法应该是平滑的，不必检查空指针，所以如果我只需要在每个子树中复制一个元素。 明确检查三个元素只是在一次递归之后可能会有所帮助，但我认为整体方法稍后会得到优化。 这产生： bvh_node::bvh_node(hitable **l, int n, float time0, float time1) { int axis = int(3*((rand() % (100) / (float)(100)))); if (axis == 0) qsort(l, n, sizeof(hitable *), box_x_compare); else if (axis == 1) qsort(l, n, sizeof(hitable *), box_y_compare); else qsort(l, n, sizeof(hitable *), box_z_compare); if (n == 1) { left = right = l[0]; } else if (n == 2) { left = l[0]; right = l[1]; } else { left = new bvh_node(l, n/2, time0, time1); right = new bvh_node(l + n/2, n - n/2, time0, time1); } aabb box_left, box_right; if(!left-&gt;bounding_box(time0,time1, box_left) || !right-&gt;bounding_box(time0,time1, box_right)) std::cerr &lt;&lt; “no bounding box in bvh_node constructor\\n”; box = surrounding_box(box_left, box_right);} 检查是否有边界框是为了防止你发送像一个无限平面一样的东西，它们没有边界框. x轴compare函数： int box_x_compare (const void * a, const void * b) { aabb box_left, box_right; hitable *ah = *(hitable**)a; hitable *bh = *(hitable**)b; if(!ah-&gt;bounding_box(0,0, box_left) || !bh-&gt;bounding_box(0,0, box_right)) std::cerr &lt;&lt; “no bounding box in bvh_node constructor\\n”; if ( box_left.min().x() - box_right.min().x() &lt; 0.0 ) return -1; else return 1;} 参考书籍：《Ray Tracing The Next Week》 RTTNW系列项目地址：GitHub","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"3D数学常用的矩阵公式总结","slug":"3d数学常用的矩阵公式总结","date":"2018-06-13T06:03:09.000Z","updated":"2020-07-05T11:16:06.883Z","comments":false,"path":"2018/06/13/3d数学常用的矩阵公式总结/","link":"","permalink":"http://yoursite.com/2018/06/13/3d%E6%95%B0%E5%AD%A6%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A9%E9%98%B5%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"这篇文章主要是一些矩阵[latex]\\begin{bmatrix} matrix \\end{bmatrix}[/latex]公式的总结，为了书写这些麻烦的公式，我去学习了LaTex的一些使用技巧，看上去效果还不错。 由于使用了LaTex语法，LaTex代码在MathJax的JS脚本渲染后，所显示的数学公式在电脑上兼容性很好，但在一些手机浏览器上兼容性不好。在手机上无法自适应页面，一些较长的公式可能无法看到全部，所以本文建议在电脑上看。 1. 2D旋转矩阵：\\[R(\\theta )=\\begin{bmatrix} {p}’\\\\ {q}’ \\end{bmatrix}=\\begin{bmatrix} cos\\theta &amp;sin\\theta \\\\ -sin\\theta &amp; cos\\theta \\end{bmatrix}\\] 2. 绕x轴旋转的3D旋转矩阵：\\[R_{x}(\\theta )=\\begin{bmatrix} {p}’\\\\ {q}’\\\\ {r}’ \\end{bmatrix}=\\begin{bmatrix} 1 &amp;0 &amp;0\\\\ 0 &amp;cos\\theta &amp;sin\\theta\\\\ 0 &amp;-sin\\theta &amp;cos\\theta \\end{bmatrix}\\] 3. 绕y轴旋转的3D旋转矩阵：\\[R_{y}(\\theta )=\\begin{bmatrix} {p}’\\\\ {q}’\\\\ {r}’ \\end{bmatrix}=\\begin{bmatrix} cos\\theta &amp;0 &amp;-sin\\theta\\\\ 0 &amp;1 &amp;0\\\\ sin\\theta &amp;0 &amp;cos\\theta \\end{bmatrix}\\] 4. 绕z轴旋转的3D旋转矩阵：\\[R_{z}(\\theta )=\\begin{bmatrix} {p}’\\\\ {q}’\\\\ {r}’ \\end{bmatrix}=\\begin{bmatrix} cos\\theta &amp;sin\\theta &amp;0\\\\ -sin\\theta &amp;cos\\theta &amp;0\\\\ 0 &amp;0 &amp;1 \\end{bmatrix}\\] 5. 沿坐标轴的2D缩放矩阵(k为缩放因子)：\\[S(k_{x},k_{y})=\\begin{bmatrix} {p}’\\\\ {q}’ \\end{bmatrix}=\\begin{bmatrix} k_{x} &amp;0 \\\\ 0&amp;k_{y} \\end{bmatrix}\\] 6. 沿坐标轴的3D缩放矩阵：\\[S(k_{x},k_{y},k_{z})=\\begin{bmatrix} k_{x} &amp;0 &amp;0 \\\\ 0&amp; k_{y} &amp;0 \\\\ 0&amp;0 &amp;k_{z} \\end{bmatrix}\\] 通过使垂直方向上的缩放因子为0，就能向坐标轴或平面投影： 7. 向任意直线投影的2D矩阵：\\[P(n)=S(n,0)=\\begin{bmatrix} 1-n_{x}^{2} &amp;-n_{x}n_{y} \\\\ -n_{x}n_{y}&amp; 1-n_{y}^{2} \\end{bmatrix}\\] 8. 向任意平面投影的3D矩阵：\\[P(n)=S(n,0)=\\begin{bmatrix} 1-n_{x}^{2}&amp;-n_{x}n_{y} &amp;-n_{x}n_{z} \\\\ -n_{x}n_{y}&amp; 1-n_{y}^{2} &amp;-n_{y}n_{z} \\\\ -n_{x}n_{z}&amp;-n_{z}n_{y} &amp; 1-n_{z}^{2} \\end{bmatrix}\\] 使缩放因子为-1能够很容易的实现镜像变换： 9. 沿任意轴镜像的2D矩阵：\\[P(n)=S(n,-1)=\\begin{bmatrix} 1-2n_{x}^{2} &amp;-2n_{x}n_{y} \\\\ -2n_{x}n_{y} &amp; 1-2n_{y}^{2} \\end{bmatrix}\\] 10. 沿任意轴镜像的3D矩阵：\\[P(n)=S(n,-1)=\\begin{bmatrix} 1-2n_{x}^{2} &amp;-2n_{x}n_{y} &amp;-2n_{x}n_{z} \\\\ -2n_{x}n_{y}&amp; 1-2n_{y}^{2} &amp;-2n_{y}n_{z} \\\\ -2n_{x}n_{z}&amp; -2n_{z}n_{y}&amp; 1-2n_{z}^{2} \\end{bmatrix}\\] 11. 2X2矩阵的行列式：\\[|M|=\\begin{vmatrix} m_{11} &amp; m_{12}\\\\ m_{21}&amp; m_{22} \\end{vmatrix}=m_{11}m_{22}-m_{12}m_{21}\\] 12. 3X3矩阵的行列式：\\[\\begin{bmatrix} m_{11} &amp; m_{12} &amp;m_{13} \\\\ m_{21}&amp;m_{22} &amp;m_{23} \\\\ m_{31}&amp;m_{32} &amp; m_{33} \\end{bmatrix}=m_{11}m_{22}m_{33}+m_{12}m_{23}m_{31}+m_{13}m_{21}m_{32}-m_{13}m_{22}m_{31}-m_{12}m_{21}m_{33}-m_{11}m_{23}m_{32}\\] 13. 矩阵[latex]M^{\\begin{Bmatrix} ij \\end{Bmatrix}}[/latex]称作M的余子式，表示从M中去除第i行和j列后剩下的矩阵：\\[\\begin{bmatrix} -4&amp;-3 &amp;3 \\\\ 0&amp; 2&amp;-2 \\\\ 1&amp;4 &amp;-1 \\end{bmatrix}\\Rightarrow M^{\\begin{Bmatrix} ij \\end{Bmatrix}}=\\begin{bmatrix} 0 &amp;-2 \\\\ 1 &amp; -1 \\end{bmatrix}\\] 14. 矩阵的代数余子式。对方阵M，给定行列元素的代数余子式等于相应的余子式的有符号行列式。[latex]C_{ij}[/latex]表示M的第i行，第j列的代数余子式。注意余子式是一个矩阵，而代数余子式是一个标量：\\[C_{ij}=(-1)^{i+j}\\left | M^{\\begin{Bmatrix} ij \\end{Bmatrix}} \\right |\\] 15. 代数余子式计算n X n阶矩阵的行列式：\\[\\left | M \\right |=\\sum_{j=1}^{n}m_{ij}c_{ij} =\\sum_{j=1}^{n}m_{ij}(-1)^{i+j}\\left | M^{\\begin{Bmatrix} ij \\end{Bmatrix}} \\right |\\] 16. 矩阵的逆。方阵M的逆记作[latex]M^{-1}[/latex],当M与[latex]M^{-1}[/latex]相乘时，结果是单位矩阵：\\[M(M^{-1})=M^{-1}M=I\\] 17. 标准伴随矩阵。M的标准伴随矩阵记作“adj M”，定义为M的代数余子式矩阵的转置矩阵，给出矩阵M：\\[M=\\begin{bmatrix} -4 &amp;-3 &amp;3 \\\\ 0&amp; 2 &amp;-2 \\\\ 1&amp; 4 &amp;-1 \\end{bmatrix}\\] 计算M的代数余子式矩阵: [latex]c_{11}=+\\begin{vmatrix} 2 &amp;-2 \\\\ 4 &amp; -1 \\end{vmatrix}=6[/latex] ，[latex]c_{12}=-\\begin{vmatrix} 0 &amp;-2 \\\\ 1 &amp; -1 \\end{vmatrix}=-2[/latex] ， [latex]c_{13}=+\\begin{vmatrix} 0 &amp;2 \\\\ 1 &amp; 4 \\end{vmatrix}=-2[/latex] [latex]c_{21}=-\\begin{vmatrix} -3&amp;3 \\\\ 4 &amp;-1 \\end{vmatrix}=9[/latex] ，[latex]c_{22}=+\\begin{vmatrix} -4&amp;3 \\\\ 1 &amp;-1 \\end{vmatrix}=1[/latex] ，[latex]c_{23}=-\\begin{vmatrix} -4&amp;-3 \\\\ 1 &amp;4 \\end{vmatrix}=13[/latex] [latex]c_{31}=+\\begin{vmatrix} -3&amp;3 \\\\ 2&amp;-2 \\end{vmatrix}=0[/latex] ，[latex]c_{32}=-\\begin{vmatrix} -4&amp;3 \\\\ 0&amp;-2 \\end{vmatrix}=-8[/latex] ，[latex]c_{33}=+\\begin{vmatrix} -4&amp;-3 \\\\ 0&amp;2 \\end{vmatrix}=-8[/latex] M的标准伴随矩阵是代数余子式的转置： \\[adjM=\\begin{bmatrix} c_{11} &amp; c_{12} &amp;c_{13} \\\\ c_{21} &amp; c_{22} &amp; c_{23}\\\\ c_{31} &amp; c_{32} &amp; c_{33} \\end{bmatrix}^{T}=\\begin{bmatrix} 6 &amp;-2 &amp;-2 \\\\ 9&amp; 1 &amp;13 \\\\ 0&amp;-8 &amp;-8 \\end{bmatrix}^{T}=\\begin{bmatrix} 6 &amp;9 &amp;0 \\\\ -2&amp; 1 &amp;-8 \\\\ -2&amp;13 &amp;-8 \\end{bmatrix}\\] 18. 矩阵的逆能够用标准伴随矩阵除以行列式求得： \\[M^{-1}=\\frac{adjM}{\\left | M \\right |}\\] 求得公式17矩阵的逆： \\[M^{-1}=\\frac{adjM}{\\left | M \\right |}=\\frac{\\begin{bmatrix} 6 &amp;9 &amp;0 \\\\ -2 &amp;1 &amp;-8 \\\\ -2&amp;13 &amp;-8 \\end{bmatrix}}{-24}=\\begin{bmatrix} -1/4 &amp;-3/8 &amp;0 \\\\ 1/12 &amp;-1/24 &amp;1/3 \\\\ 1/12 &amp;-13/24 &amp;1/3 \\end{bmatrix}\\] 19. 检测矩阵的正交性。若方阵M是正交的，则当且仅当M与转置[latex]M^{T}[/latex]的乘积等于单位矩阵。\\[MM^{T}=I\\] 所以，如果一个矩阵是正交的，那么它的转置就是它的逆(旋转和镜像矩阵是正交的)： \\[M^{T}=M^{-1}\\] 20. 用4X4矩阵实现3D平移。在4D中，任然可以用矩阵乘法来表达位移，而在3D中是不可能的。即使是在4D中，矩阵乘法仍然是线性变换； \\[\\begin{bmatrix} x &amp;y &amp;z &amp;1 \\end{bmatrix}\\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 \\\\ 0&amp; 1&amp; 0&amp;0 \\\\ 0&amp; 0 &amp;1 &amp;0 \\\\ \\Delta x &amp;\\Delta y &amp;\\Delta z &amp; 1 \\end{bmatrix}=\\begin{bmatrix} x+\\Delta x &amp; y+\\Delta y &amp; z+\\Delta z &amp;1 \\end{bmatrix}\\] 21. 用4X4矩阵向z=d平面投影： \\[\\begin{bmatrix} x &amp;y &amp;z &amp;1 \\end{bmatrix}\\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 \\\\ 0&amp; 1&amp; 0&amp;0 \\\\ 0&amp; 0 &amp;1 &amp;1/d \\\\ 0&amp;0&amp;0 &amp; 0 \\end{bmatrix}=\\begin{bmatrix} x &amp; y &amp; z &amp;z/d \\end{bmatrix}\\] 参考书籍：《游戏引擎架构》 《3D Math Primer for graphics and game development》","categories":[],"tags":[{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"}]},{"title":"C函数中形参传递方式的差别","slug":"c函数中形参传递方式的差别","date":"2018-06-09T16:14:25.000Z","updated":"2020-07-05T08:56:51.336Z","comments":false,"path":"2018/06/10/c函数中形参传递方式的差别/","link":"","permalink":"http://yoursite.com/2018/06/10/c%E5%87%BD%E6%95%B0%E4%B8%AD%E5%BD%A2%E5%8F%82%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E7%9A%84%E5%B7%AE%E5%88%AB/","excerpt":"","text":"C函数中的形式参数可以是基本类型变量名，构造类型变量名和指针类型变量名。对于不同的形式参数，其传递参数的方式不同，总体来说分成两种：按值传递和按地址传递。 当形参是基本类型变量名时，采用按值传递方式；当形参是指针类型变量名或者构造类型变量名时，采用按地址传递方式。 下面通过两个相似的程序说明二者的区别： //程序一：按地址传递参数#include &lt;stdio.h&gt;swap(int *x,int *y){ int t=*x; *x=*y; *y=t;} main(){ int a=15,b=22; printf(“a=%d\\tb=%d\\n”,a,b); swap(&amp;a,&amp;b); printf(“a=%d\\tb=%d\\n”,a,b);} /*//输出结果：a=15 b=22a=22 b=15 //程序二：按值传递参数#include &lt;stdio.h&gt;swap(int x,int y){ int t=x; x=y; y=t;} main(){ int a=15,b=22; printf(“a=%d\\tb=%d\\n”,a,b); swap(a,b); printf(“a=%d\\tb=%d\\n”,a,b);} //输出结果：a=15 b=22a=15 b=22 可以看出，程序一实现了a和b的值的交换，而程序二并没有实现。 先看一下两个程序的栈帧内容有何差别： [ 可以看出他们仅在压入栈中的参数不同。程序一中，main函数把变量a和b的地址作为实参压入了栈中；程序二中，则把变量a和b的值作为实参压入了栈中。 ： //程序一汇编代码片段：main: leal -8(%ebp), %eax //将ebp-8里面的内容作为地址放到eax中 mov1 %eax, 4(%esp) //作为参数传到esp+4的位置 leal -4(%ebp), %eax //ebp-4传给eax，a=15 mov1 %eax, (%esp) call swap ret swap://以下是准备阶段 push1 %ebp mov1 %esp, %ebp push1 %ebx //ebx是被调用者保存 //以下是过程体 mov1 8(%ebp), %edx //R[ecx]&lt;-M[&amp;a]=15 mov1 (%edx), %ecx //把15送到了ecx中 mov1 12(%ebp), %eax //R[ebx]&lt;-M[&amp;b]=22 mov1 (%eax), %ebx //把22送到ebx中 mov1 %ebx, (%edx) //ebx中的22替换掉a=15，之后a=22 mov1 %ecx, (%eax) //ecx中的15替换掉b=22，之后b=15 //以下是结束阶段 pop1 %ebx pop1 %ebp ret //程序二汇编代码片段：main: leal -8(%ebp), %eax mov1 %eax, 4(%esp) leal -4(%ebp), %eax mov1 %eax, (%esp) call swap ret swap://以下是准备阶段 push1 %ebp mov1 %esp, %ebp //以下是过程体 mov1 8(%ebp), %edx mov1 12(%ebp), %eax mov1 (%eax), 8(%ebp) mov1 %edx, 12(%ebp) //以下是结束阶段 pop1 %ebp ret 对比图： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/06/18060904.png)](http://www.wjgbaby.com/wp-content/uploads/2018/06/18060904.png) 在给swap过程传递参数时，程序一用了leal指令，而程序二用的是movl指令。因此程序一传递的是a和b的地址，而程序二传递的是a和b的内容。 程序一的swap过程比程序二的swap过程多了三条指令。而且，由于程序一的swap过程更复杂，使用了较多的寄存器，除了三个调用者保存寄存器外，还使用了被调用者保存寄存器EBX，它的值必须在准备阶段被保存到栈中，而在结束阶段从栈中恢复。因而它比程序二又多了一条push指令和一条pop指令。 再来看一下执行swap过程后的main的栈帧中的状态： [![](http://www.wjgbaby.com/wp-content/uploads/2018/06/18060902.png) 程序一的swap函数的形式参数x和y用的是指针型变量名，相当于间接寻址，需要先取出地址，然后根据地质再存取x和y的值，因而改变了调用过程main的栈帧中局部变量a和b所在位置的内容。 而程序二中的swap函数的形式参数x和y用的是基本数据类型变量名，直接存取x和y的内容，因而改变的是swap函数的入口参数x和y所在位置的值。 程序一和程序二有这么明显的差别，这些差别造成最终结果的不同是重要的。这个不同就是，程序一中调用swap后回到main执行时，a和b的值已经交换过了，而在程序二时，swap的过程实际上交换的是其两个入口参数所在位置上的内容，并没有真正交换a和b的值。 从上面的例子我们可以看出，编译器并不为形式参数分配存储空间，而是给形式参数对应的实参分配空间，形式参数实际上只是被调用函数使用实参时的一个名称而已。不管是按值传递参数还是按地值传递参数，在调用过程用CALL指令调用被调用过程时，对应的实参应该都已有具体的值，并已将实参的值存放到调用过程的栈帧中作为入口参数，以等待被调用过程中的指令所用。例如，在程序一中，main函数调用swap函数的实参是&amp;a和&amp;b，在执行call指令调用swap之前，&amp;a和&amp;b的值分别是R[ebp]-4和R[ebp]-8。在程序二中，main函数调用swap函数的实参分别是a和b，在执行CALL指令调用swap之前，a和b的值分别是15和22。","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"Linux 0.11实验二：操作系统的引导","slug":"linux-0-11实验一：操作系统的引导","date":"2018-05-31T09:08:52.000Z","updated":"2020-07-05T08:56:51.334Z","comments":false,"path":"2018/05/31/linux-0-11实验一：操作系统的引导/","link":"","permalink":"http://yoursite.com/2018/05/31/linux-0-11%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/","excerpt":"","text":"实验目的熟悉hit-oslab实验环境； 建立对操作系统引导过程的深入认识； 掌握操作系统的基本开发过程； 能对操作系统代码进行简单的控制，揭开操作系统的神秘面纱 实验内容此次实验的基本内容是： 阅读《Linux内核完全注释》的第6章，对计算机和Linux 0.11的引导过程进行初步的了解； 按照下面的要求改写0.11的引导程序bootsect.s 有兴趣同学可以做做进入保护模式前的设置程序setup.s。 改写bootsect.s主要完成如下功能： bootsect.s能在屏幕上打印一段提示信息“XXX is booting…”，其中XXX是你给自己的操作系统起的名字，例如LZJos、Sunix等（可以上论坛上秀秀谁的OS名字最帅，也可以显示一个特色logo，以表示自己操作系统的与众不同。） 改写setup.s主要完成如下功能： bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行”Now we are in SETUP”。 setup.s能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可。 Linux 0.11相关代码详解boot/bootsect.s、boot/setup.s和tools/build.c是本实验会涉及到的源文件。它们的功能详见《注释》的6.2、6.3节和16章。 如果使用Windows下的环境，那么要注意Windows环境里提供的build.c是一个经过修改过的版本。Linus Torvalds的原版是将0.11内核的最终目标代码输出到标准输出，由make程序将数据重定向到Image文件，这在Linux、Unix和Minix等系统下都是非常有效的。但Windows本身的缺陷（也许是特色）决定了在Windows下不能这么做，所以flyfish修改了build.c，将输出直接写入到Image（flyfish是写入到Boot.img文件，我们为了两个环境的一致，也为了最大化地与原始版本保持统一，将其改为Image）文件中。同时为了适应Windows的一些特殊情况，他还做了其它一些小修改。 引导程序的运行环境引导程序由BIOS加载并运行。它活动时，操作系统还不存在，整台计算机的所有资源都由它掌控，而能利用的功能只有BIOS中断调用。 完成bootsect.s的屏幕输出功能首先来看完成屏幕显示的关键代码如下： ! 首先读入光标位置mov ah,#0x03xor bh,bhint 0x10 ! 显示字符串“LZJos is running...”mov cx,#25 ! 要显示的字符串长度mov bx,#0x0007 ! page 0, attribute 7 (normal)mov bp,#msg1mov ax,#0x1301 ! write string, move cursorint 0x10 inf_loop:jmp inf_loop ! 后面都不是正经代码了，得往回跳呀 ! msg1处放置字符串 msg1: .byte 13,10 ! 换行+回车 .ascii “WJG OS is running …” .byte 13,10,13,10 ! 两对换行+回车 !设置引导扇区标记0xAA55 .org 510boot_flag: .word 0xAA55 ! 必须有它，才能引导 接下来，将完成屏幕显示的代码在开发环境中编译，并使用linux-0.11/tools/build.c将编译后的目标文件做成Image文件。 编译和运行Ubuntu上先从终端进入~/oslab/linux-0.11/boot/目录。Windows上则先双击快捷方式“MinGW32.bat”，将打开一个命令行窗口，当前目录是oslab，用cd命令进入linux-0.11\\boot。无论那种系统，都执行下面两个命令编译和链接bootsect.s： as86 -0 -a -o bootsect.o bootsect.sld86 -0 -s -o bootsect bootsect.o 其中-0（注意：这是数字0，不是字母O）表示生成8086的16位目标程序，-a表示生成与GNU as和ld部分兼容的代码，-s告诉链接器ld86去除最后生成的可执行文件中的符号信息。 如果这两个命令没有任何输出，说明编译与链接都通过了。Ubuntu下用ls -l可列出下面的信息： wjg@v-m:/oslab$ cd ~/oslab/linux-0.11/boot/wjg@v-m:/oslab/linux-0.11/boot$ as86 -0 -a -o bootsect.o bootsect.swjg@v-m:/oslab/linux-0.11/boot$ ld86 -0 -s -o bootsect bootsect.owjg@v-m:/oslab/linux-0.11/boot$ ls -l总用量 68-rwxr-xr-x 1 wjg wjg 544 5月 31 14:56 bootsect-rw-r–r– 1 wjg wjg 927 5月 31 14:56 bootsect.o-rw-r–r– 1 wjg wjg 5095 5月 31 14:50 bootsect.s-rw-r–r– 1 wjg wjg 27868 4月 30 15:46 head.o-rw-r–r– 1 wjg wjg 5938 8月 28 2008 head.s-rwxr-xr-x 1 wjg wjg 344 4月 30 15:46 setup-rw-r–r– 1 wjg wjg 596 4月 30 15:46 setup.o-rw-r–r– 1 wjg wjg 5362 8月 28 2008 setup.s 其中bootsect.o是中间文件。bootsect是编译、链接后的目标文件。 需要留意的文件是bootsect的文件大小是544字节，而引导程序必须要正好占用一个磁盘扇区，即512个字节。造成多了32个字节的原因是ld86产生的是Minix可执行文件格式，这样的可执行文件处理文本段、数据段等部分以外，还包括一个Minix可执行文件头部，它的结构如下： struct exec { unsigned char a_magic[2]; //执行文件魔数 unsigned char a_flags; unsigned char a_cpu; //CPU标识号 unsigned char a_hdrlen; //头部长度，32字节或48字节 unsigned char a_unused; unsigned short a_version; long a_text; long a_data; long a_bss; //代码段长度、数据段长度、堆长度 long a_entry; //执行入口地址 long a_total; //分配的内存总量 long a_syms; //符号表大小}; 算一算：6 char(6字节)+1 short(2字节)+6 long(24字节)=32，正好是32个字节，去掉这32个字节后就可以放入引导扇区了（这是tools/build.c的用途之一）。 对于上面的Minix可执行文件，其a_magic[0]=0x01，a_magic[1]=0x03，a_flags=0x10（可执行文件），a_cpu=0x04（表示Intel i8086/8088，如果是0x17则表示Sun公司的SPARC），所以bootsect文件的头几个字节应该是01 03 10 04。为了验证一下，Ubuntu下用命令“hexdump -C bootsect”可以看到： wjg@v-m:~/oslab/linux-0.11/boot$ hexdump -C bootsect00000000 01 03 10 04 20 00 00 00 00 02 00 00 00 00 00 00 |…. ………..|00000010 00 00 00 00 00 00 00 00 00 82 00 00 00 00 00 00 |…………….|00000020 b8 c0 07 8e d8 b8 00 90 8e c0 b9 00 01 29 f6 29 |………….).)|00000030 ff f3 a5 ea 18 00 00 90 8c c8 8e d8 8e c0 8e d0 |…………….|00000040 bc 00 ff ba 00 00 b9 02 00 bb 00 02 b8 04 02 cd |…………….|00000050 13 73 0a ba 00 00 b8 00 00 cd 13 eb e6 b2 00 b8 |.s…………..|00000060 00 08 cd 13 b5 00 2e 89 0e 3d 01 b8 00 90 8e c0 |………=……|00000070 b4 03 30 ff cd 10 b9 1a 00 bb 07 00 bd 3f 01 b8 |..0……….?..|00000080 01 13 cd 10 b8 00 10 8e c0 e8 32 00 e8 c5 00 2e |……….2…..|00000090 a1 fc 01 3d 00 00 75 17 2e 8b 1e 3d 01 b8 08 02 |…=..u….=….|000000a0 83 fb 0f 74 0a b8 1c 02 83 fb 12 74 02 eb fe 2e |…t…….t….|000000b0 a3 fc 01 ea 00 00 20 90 05 00 00 00 00 00 8c c0 |…… ………|000000c0 a9 ff 0f 75 fe 31 db 8c c0 3d 00 40 72 01 c3 2e |…u.1…=.@r…|000000d0 a1 3d 01 2b 06 98 00 89 c1 c1 e1 09 01 d9 73 09 |.=.+……….s.|000000e0 74 07 31 c0 29 d8 c1 e8 09 e8 34 00 89 c1 03 06 |t.1.)…..4…..|000000f0 98 00 2e 3b 06 3d 01 75 12 b8 01 00 2b 06 9a 00 |…;.=.u….+…|00000100 75 04 ff 06 9c 00 a3 9a 00 31 c0 a3 98 00 c1 e1 |u……..1……|00000110 09 01 cb 73 b2 8c c0 05 00 10 8e c0 31 db eb a7 |…s……..1…|00000120 50 53 51 52 8b 16 9c 00 8b 0e 98 00 41 88 d5 8b |PSQR……..A…|00000130 16 9a 00 88 d6 b2 00 81 e2 00 01 b4 02 cd 13 72 |……………r|00000140 05 5a 59 5b 58 c3 b8 00 00 ba 00 00 cd 13 5a 59 |.ZY[X………ZY|00000150 5b 58 eb cc 52 ba f2 03 b0 00 ee 5a c3 00 00 0d |[X..R……Z….|00000160 0a 57 4a 47 20 4f 53 20 69 73 20 72 75 6e 6e 69 |.WJG OS is runni|00000170 6e 67 20 2e 2e 2e 0d 0a 0d 0a 00 00 00 00 00 00 |ng ………….|00000180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |…………….|*00000210 00 00 00 00 00 00 00 00 00 00 00 00 06 03 55 aa |…………..U.|00000220 接下来干什么呢？是的，要去掉这32个字节的文件头部（tools/build.c的功能之一就是这个）！随手编个小的文件读写程序都可以去掉它。不过，懒且聪明的人会在Ubuntu下用命令： wjg@v-m:~/oslab/linux-0.11/boot$ dd bs=1 if=bootsect of=Image skip=32记录了512+0 的读入记录了512+0 的写出512 bytes copied, 0.00156749 s, 327 kB/s 生成的Image就是去掉文件头的bootsect，正好512字节。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18053103.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18053103.jpg) 去掉这32个字节后，将生成的文件拷贝到linux-0.11目录下，并一定要命名为“Image”（注意大小写）。然后就“run”吧！ [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18053104.jpg) 参考链接： 操作系统原理与实践 课程链接： 操作系统之基础 操作系统之进程与线程 操作系统之内存管理 操作系统之外设与文件系统 所需资源下载： GitHub","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"RTTNW-ch1：Motion Blur","slug":"rttnw-ch01：motion-blur","date":"2018-05-30T11:02:43.000Z","updated":"2020-07-05T08:56:51.331Z","comments":false,"path":"2018/05/30/rttnw-ch01：motion-blur/","link":"","permalink":"http://yoursite.com/2018/05/30/rttnw-ch01%EF%BC%9Amotion-blur/","excerpt":"","text":"Peter Shirley有三本光线追踪的书： 《Ray Tracing In The Weekend》：用两天学光线追踪 《Ray Tracing The Next Week》：用一周学光线追踪 《Ray Tracing The Rest Of Your Life》：用余生学光线追踪 接下来的一系列笔记是第二本书，这篇讲动态模糊。 在现实生活中，我们拍照时相机会打开一段时间，在其期间会因为摄像机抖动或拍摄物体运动而造成相片模糊，我们来实现一下这种效果。 首先要使我们的射线能存储这段时间： #ifndef RAYH#define RAYH#include “RT/vec3.h” class ray{ public: ray() { } //给_time赋值 ray(const vec3&amp; a, const vec3&amp; b, float ti = 0.0) { A = a; B = b; _time = ti;} vec3 origin() const { return A; } vec3 direction() const { return B; } //存储时间的变量 float time() const { return \\_time; } vec3 point\\_at\\_parameter(float t) const { return A + t\\* B; } vec3 A; vec3 B; float \\_time;}; #endif 现在将我们的摄像机在time1到time2的随机时间生成射线，相机不需要移动，只需要在一段时间内发出射线： class camera{ vec3 origin; vec3 lower_left_corner; vec3 horizontal; vec3 vertical; vec3 u, v, w; float lens_radius; float time0, time1; //射线开始时间和结束时间 public: //构造函数中加入时间t0和t1 camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focus_dist,float t0, float t1) { time0 = t0; time1 = t1; lens_radius = aperture / 2; float theta = vfov * M_PI / 180; float half_height = tan(theta / 2); float half_width = aspect * half_height; origin = lookfrom; w = unit_vector(lookfrom - lookat); u = unit_vector(cross(vup, w)); v = cross(w, u); lower_left_corner = origin - half_width * focus_dist * u - half_height * focus_dist * v - focus_dist * w; horizontal = 2 * half_width * focus_dist * u; vertical = 2 * half_height * focus_dist * v; } //time为一个时间在time0到time1的随机时间 ray getray(float s, float t) { vec3 rd = lens\\_radius \\* random\\_in\\_unit\\_disk(); vec3 offset = u \\* rd.x() + v \\* rd.y(); float time = time0 + (rand() % (100) / (float)(100)) \\* (time1 - time0); return ray(origin + offset, lower\\_left\\_corner + s \\* horizontal + t \\* vertical - origin - offset, time); }}; 我们还需要一个移动的物体， 我将创建一个以线性为中心的球体类从time0的center0到time1的center1， 在这段时间之外它不需要配合相机光圈的开合。 #include “RT/hitable.h” //物体在移动，在time0时在地点center0，在time1时在地点center1class moving_sphere : public hitable {public: moving_sphere(){ } moving_sphere(vec3 cen0, vec3 cen1, float t0, float t1, float r, material* m) : center0(cen0), center1(cen1), time0(t0),time1(t1), radius(r), mat_ptr(m) { }; virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const; vec3 center(float time) const; vec3 center0, center1; float time0, time1; float radius; material* mat_ptr;}; //获取某一时刻的中心点坐标vec3 moving_sphere::center(float time) const{ return center0 + ((time - time0) / (time1 - time0))*(center1 - center0);} 我们也可以让所有的物体都实现动态模糊，给他们相同的开始点和结束点。在hit函数里将”center” 替换成 “center(r.time())“ //让所有的普通物体都可以实现动态模糊// replace “center” with “center(r.time())”bool moving_sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const { vec3 oc = r.origin() - center(r.time()); float a = dot(r.direction(), r.direction()); float b = dot(oc, r.direction()); float c = dot(oc, oc) - radius*radius; float discriminant = b*b - a*c; if (discriminant &gt; 0) { float temp = (-b - sqrt(discriminant))/a; if (temp &lt; t_max &amp;&amp; temp &gt; t_min) { rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center(r.time())) / radius; rec.mat_ptr = mat_ptr; return true; } temp = (-b + sqrt(discriminant))/a; if (temp &lt; t_max &amp;&amp; temp &gt; t_min) { rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center(r.time())) / radius; rec.mat_ptr = mat_ptr; return true; } } return false;} 将漫反射球在time0时刻的center位置移动到time1时刻的center+vec3(0,0.5*drand48(), 0)位置： hitable* RandomScene(){ int n = 500; hitable** list = new hitable*[n + 1]; /*定义一个包含n+1个元素的数组，数组的每个元素是指向hitable对象的指针。然后将数组的指针赋值给list。所以，list是指针的指针。*/ list[0] = new sphere(vec3(0, -1000, 0), 1000, new lambertian(vec3(0.5, 0.5, 0.5))); /*先创建一个中心在（0，-1000，0）半径为1000的超大漫射球，将其指针保存在list的第一个元素中。*/ int i = 1; for (int a = -11; a &lt; 11; a++) { for (int b = -11; b &lt; 11; b++) { /*两个for循环中会产生（11+11）*(11+11)=484个随机小球*/ float choose_mat = (rand() % (100) / (float)(100)); /*产生一个（0，1）的随机数，作为设置小球材料的阀值*/ vec3 center(a + 0.9 * (rand() % (100) / (float)(100)), 0.2, b + 0.9 * (rand() % (100) / (float)(100))); /*” a+0.9*(rand()%(100)/(float)(100))”配合[-11,11]产生（-11，11）之间的随机数， * 而不是[-11,11)之间的22个整数。使得球心的x,z坐标是（-11，11）之间的随机数*/ if ((center - vec3(4, 0.2, 0)).length() &gt; 0.9) { /*避免小球的位置和最前面的大球的位置太靠近*/ if (choose_mat &lt; 0.8) { //diffuse /*材料阀值小于0.8，则设置为漫反射球，漫反射球的衰减系数x,y,z都是（0，1）之间的随机数的平方*/ list[i++] = new moving_sphere(center, center + 0.4 * vec3(0, (rand() % 100 / (float)(100)), 0), 0.0f, 1.0f, 0.2f, new lambertian(vec3( (rand() % (100) / (float)(100)) * (rand() % (100) / (float)(100)), (rand() % (100) / (float)(100)) * (rand() % (100) / (float)(100)), (rand() % (100) / (float)(100)) * (rand() % (100) / (float)(100))))); } else if (choose_mat &lt; 0.95) { /*材料阀值大于等于0.8小于0.95，则设置为镜面反射球， * 镜面反射球的衰减系数x,y,z及模糊系数都是（0，1）之间的随机数加一再除以2*/ list[i++] = new sphere(center, 0.2, new metal(vec3(0.5 * (1 + (rand() % (100) / (float)(100))), 0.5 * (1 + (rand() % (100) / (float)(100))), 0.5 * (1 + (rand() % (100) / (float)(100)))), 0.5 * (1 + (rand() % (100) / (float)(100))))); } else { /*材料阀值大于等于0.95，则设置为介质球*/ list[i++] = new sphere(center, 0.2, new dielectric(1.5)); } } } } list\\[i++\\] = new sphere(vec3(0, 1, 0), 1.0, new dielectric(1.5)); list\\[i++\\] = new sphere(vec3(-4, 1, 0), 1.0, new lambertian(vec3(0.4, 0.2, 0.1))); list\\[i++\\] = new sphere(vec3(4, 1, 0), 1.0, new metal(vec3(0.7, 0.6, 0.5), 0.0)); /\\*定义三个大球\\*/ return new hitable\\_list(list, i);} 调整摄像机： vec3 lookform(13.0f, 2.0f, 3.0f);vec3 lookat(0, 0, 0);float dist_to_focus = (lookform - lookat).length();float aperture = 0.0f; camera cam(lookform, lookat, vec3(0, 1, 0), 20,float(nx) / float(ny), aperture, 0.7*dist_to_focus,0.0,1.0); 最终效果： 参考书籍：《Ray Tracing The Next Week》 RTTNW系列项目地址：GitHub","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch12：Where next","slug":"rtiow-ch12：where-next","date":"2018-05-21T14:55:38.000Z","updated":"2020-07-05T08:56:51.328Z","comments":false,"path":"2018/05/21/rtiow-ch12：where-next/","link":"","permalink":"http://yoursite.com/2018/05/21/rtiow-ch12%EF%BC%9Awhere-next/","excerpt":"","text":"制作书籍的封面图： cpp: #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h”#include “material.h” using namespace std; //获得反射射线vec3 RandomInUnitsphere(){ vec3 p; do{ p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (dot(p, p) &gt;= 1.0f); return p;} vec3 Color(const ray&amp; r, hitable* world, int depth){ //这个“rec”会在sphere::hit ()中带上来被撞击球的材料属性（指向一个材质对象的指针mat_ptr）。 //根据这个指针可以获取材料对象的成员方法scatter()和成员变量albedo（反射衰减向量） hit_record rec; if (world-&gt;hit(r, 0.001f, FLT_MAX, rec)) { ray scattered; vec3 attenuation; if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) { //获取反射光线向量scattered和反射衰减向量attenuation return attenuation * Color(scattered, world, depth + 1); //反射光线的强度需要乘以反射衰减向量（对应坐标相乘作为新的向量）。 //然后反射光线就扮演之前“原始光线”的角色。如果再次撞击到小球，就再次反射，直到不再撞击到任何球为止 } else { return vec3(0.0f, 0.0f, 0.0f); } } else { //绘制背景 vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f); //注意这里，原始光线和反射光线最后都会跑到这里来。 //背景的颜色：原始光线的方向向量的映射 //漫反射材料和镜面材料的颜色：最后一次反射光线的方向向量的映射 \\* 所有反射衰减系数的乘积。 //漫反射和镜面反射的区别在于，漫反射的每次反射方向是随机的 }} hitable* RandomScene(){ int n = 500; hitable** list = new hitable*[n + 1]; /*定义一个包含n+1个元素的数组，数组的每个元素是指向hitable对象的指针。然后将数组的指针赋值给list。所以，list是指针的指针。*/ list[0] = new sphere(vec3(0, -1000, 0), 1000, new lambertian(vec3(0.5, 0.5, 0.5))); /*先创建一个中心在（0，-1000，0）半径为1000的超大漫射球，将其指针保存在list的第一个元素中。*/ int i = 1; for (int a = -11; a &lt; 11; a++) { for (int b = -11; b &lt; 11; b++) { /*两个for循环中会产生（11+11）*(11+11)=484个随机小球*/ float choose_mat = (rand() % (100) / (float)(100)); /*产生一个（0，1）的随机数，作为设置小球材料的阀值*/ vec3 center(a + 0.9 * (rand() % (100) / (float)(100)), 0.2, b + 0.9 * (rand() % (100) / (float)(100))); /*” a+0.9*(rand()%(100)/(float)(100))”配合[-11,11]产生（-11，11）之间的随机数，而不是[-11,11)之间的22个整数。使得球心的x,z坐标是（-11，11）之间的随机数*/ if ((center - vec3(4, 0.2, 0)).length() &gt; 0.9) { /*避免小球的位置和最前面的大球的位置太靠近*/ if (choose_mat &lt; 0.8) { //diffuse /*材料阀值小于0.8，则设置为漫反射球，漫反射球的衰减系数x,y,z都是（0，1）之间的随机数的平方*/ list[i++] = new sphere(center, 0.2, new lambertian(vec3( (rand() % (100) / (float)(100)) * (rand() % (100) / (float)(100)), (rand() % (100) / (float)(100)) * (rand() % (100) / (float)(100)), (rand() % (100) / (float)(100)) * (rand() % (100) / (float)(100))))); } else if (choose_mat &lt; 0.95) { /*材料阀值大于等于0.8小于0.95，则设置为镜面反射球，镜面反射球的衰减系数x,y,z及模糊系数都是（0，1）之间的随机数加一再除以2*/ list[i++] = new sphere(center, 0.2, new metal(vec3(0.5 * (1 + (rand() % (100) / (float)(100))), 0.5 * (1 + (rand() % (100) / (float)(100))), 0.5 * (1 + (rand() % (100) / (float)(100)))), 0.5 * (1 + (rand() % (100) / (float)(100))))); } else { /*材料阀值大于等于0.95，则设置为介质球*/ list[i++] = new sphere(center, 0.2, new dielectric(1.5)); } } } } list\\[i++\\] = new sphere(vec3(0, 1, 0), 1.0, new dielectric(1.5)); list\\[i++\\] = new sphere(vec3(-4, 1, 0), 1.0, new lambertian(vec3(0.4, 0.2, 0.1))); list\\[i++\\] = new sphere(vec3(4, 1, 0), 1.0, new metal(vec3(0.7, 0.6, 0.5), 0.0)); /\\*定义三个大球\\*/ return new hitable\\_list(list, i);} //And add some metal spheresint main(){ ofstream outfile; outfile.open(“IMG.ppm”); int nx = 2000; int ny = 1000; //采样次数 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* world = RandomScene(); vec3 lookform(13.0f, 2.0f, 3.0f); vec3 lookat(0, 0, 0); float dist\\_to\\_focus = (lookform - lookat).length(); float aperture = 0.0f; camera cam(lookform, lookat, vec3(0, 1, 0), 20, float(nx) / float(ny), aperture, 0.7 \\* dist\\_to\\_focus); //随机数 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //vec3 p = r.point\\_at\\_parameter(2.0); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world, 0); } //获得区域的颜色均值 col /= float(ns); //gamma矫正 col = vec3(sqrt(col\\[0\\]), sqrt(col\\[1\\]), sqrt(col\\[2\\])); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最终运行效果： 200乘100大小，每个像素点10条采集光线，运行时间2分钟： 2000乘1000大小，每个像素点100条采集光线，运行时间14小时： 虚拟世界真是有趣，再放一张没有水印的： 我们已经有了一个很酷的光线追踪器，接下来做些什么呢？ 1. Lights. You can do this explicitly, by sending shadow rays to lights. Or it can be done implicitly by making some objects emit light, 2. biasing scattered rays toward them, and then downweighting those rays to cancel out the bias. Both work. I am in the minority in favoring the latter approach. 3. Triangles. Most cool models are in triangle form. The model I/O is the worst and almost everybody tries to get somebody else’s code to do this. 4. Surface textures. This lets you paste images on like wall paper. Pretty easy and a good thing to do. 5. Solid textures. Ken Perlin has his code online. Andrew Kensler has some very cool info at his blog. 6. Volumes and media. Cool stuff and will challenge your software architecture. I favor making volumes have the hitable interface and probabilistically have intersections based on density. Your rendering code doesn’t even have to know it has volumes with that method. 7. Parallelism. Run N copies of your code on N cores with different random seeds. Average the N runs. This averaging can also be done hierarchically where N/2 pairs can be averaged to get N/4 images, and pairs of those can be averaged. That method of parallelism should extend well into the thousands of cores with very little coding. 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch11：Defocus Blur","slug":"rtiow-ch11：defocus-blur","date":"2018-05-18T16:51:17.000Z","updated":"2020-07-05T08:56:51.326Z","comments":false,"path":"2018/05/19/rtiow-ch11：defocus-blur/","link":"","permalink":"http://yoursite.com/2018/05/19/rtiow-ch11%EF%BC%9Adefocus-blur/","excerpt":"","text":"散焦模糊”在摄影上又称“景深”。 在现实的相机中，我们需要做“散焦模糊”的原因是：我们需要一个更大的孔来收集光线增加图片的亮度（而不是“针孔”）。我们称“更大的孔”为“光圈”。 光圈的增大，导致图片出现散焦而模糊。 但是我们可以调节成像的位置，改变图片的清晰度，使图片在当前光圈条件下尽可能清晰。 所以，接下来，我们会引入两个参数：aperture（光圈）和focus_dist（成像位置）。 camera.h： #ifndef cameraH#define cameraH //M_PI 是一个宏定义，圆周率的定义，math文件中也有这家伙。#define M_PI 3.14159265358979323846 #include “ray.h” vec3 random_in_unit_disk(){ /*在z=0平面上产生一个“起点在原点，长度小于1，方向随机”的向量。 为什么是z=0平面，这个和相机的倾斜方向有关。 （相机的倾斜方向为view up （简称vup，一般设置为（0，1，0））） */ vec3 p; do{ //p = 2.0*vec3(drand48(),drand48(),0) - vec3(1,1,0); p = 2.0 * vec3((rand() % (100) / (float)(100)), (rand() % (100) / (float)(100)), 0) - vec3(1, 1, 0); } while (dot(p, p) &gt;= 1.0); return p;} class camera{ vec3 origin; vec3 lower_left_corner; vec3 horizontal; vec3 vertical; vec3 u, v, w; float lens_radius; public: camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focus\\_dist) { lens\\_radius = aperture / 2; float theta = vfov \\* M\\_PI / 180; float half\\_height = tan(theta / 2); float half\\_width = aspect \\* half\\_height; origin = lookfrom; w = unit\\_vector(lookfrom - lookat); u = unit\\_vector(cross(vup, w)); v = cross(w, u); lower\\_left\\_corner = origin - half\\_width \\* focus\\_dist \\* u - half\\_height \\* focus\\_dist \\* v - focus\\_dist \\* w; horizontal = 2 \\* half\\_width \\* focus\\_dist \\* u; vertical = 2 \\* half\\_height \\* focus\\_dist \\* v; } ray getray(float s, float t) { vec3 rd = lens\\_radius \\* random\\_in\\_unit\\_disk(); vec3 offset = u \\* rd.x() + v \\* rd.y(); return ray(origin + offset, lower\\_left\\_corner + s \\* horizontal + t \\* vertical - origin - offset); }};#endif cpp： #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h”#include “material.h” using namespace std; //获得反射射线vec3 RandomInUnitsphere(){ vec3 p; do{ p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (dot(p, p) &gt;= 1.0f); return p;} vec3 Color(const ray&amp; r, hitable* world, int depth){ //这个“rec”会在sphere::hit ()中带上来被撞击球的材料属性（指向一个材质对象的指针mat_ptr）。 //根据这个指针可以获取材料对象的成员方法scatter()和成员变量albedo（反射衰减向量） hit_record rec; if (world-&gt;hit(r, 0.001f, FLT_MAX, rec)) { ray scattered; vec3 attenuation; if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) { //获取反射光线向量scattered和反射衰减向量attenuation return attenuation * Color(scattered, world, depth + 1); //反射光线的强度需要乘以反射衰减向量（对应坐标相乘作为新的向量）。 //然后反射光线就扮演之前“原始光线”的角色。如果再次撞击到小球，就再次反射，直到不再撞击到任何球为止 } else { return vec3(0.0f, 0.0f, 0.0f); } } else { //绘制背景 vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f); //注意这里，原始光线和反射光线最后都会跑到这里来。 //背景的颜色：原始光线的方向向量的映射 //漫反射材料和镜面材料的颜色：最后一次反射光线的方向向量的映射 \\* 所有反射衰减系数的乘积。 //漫反射和镜面反射的区别在于，漫反射的每次反射方向是随机的 }} //And add some metal spheresint main(){ ofstream outfile; outfile.open(“IMG.ppm”); int nx = 800; int ny = 400; //采样次数 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* list\\[5\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f, new lambertian(vec3(0.8f, 0.3f, 0.3f))); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f, new lambertian(vec3(0.8f, 0.8f, 0.0f))); list\\[2\\] = new sphere(vec3(1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.6f, 0.2f), 0.3f)); list\\[3\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new dielectric(1.5f)); list\\[4\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new dielectric(1.5f)); hitable\\* world = new hitable\\_list(list, 5); vec3 lookform(3, 3, 2); vec3 lookat(0, 0, -1); float dist\\_to\\_focus = (lookform - lookat).length(); float aperture = 2.0f; camera cam(lookform, lookat, vec3(0, 1, 0), 20, float(nx) / float(ny), aperture, dist\\_to\\_focus); //随机数 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //vec3 p = r.point\\_at\\_parameter(2.0); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world, 0); } //获得区域的颜色均值 col /= float(ns); //gamma矫正 col = vec3(sqrt(col\\[0\\]), sqrt(col\\[1\\]), sqrt(col\\[2\\])); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最终效果: 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch10：Positionable camera","slug":"rtiow-ch10：positionable-camera","date":"2018-05-17T13:08:49.000Z","updated":"2020-07-05T08:56:51.323Z","comments":false,"path":"2018/05/17/rtiow-ch10：positionable-camera/","link":"","permalink":"http://yoursite.com/2018/05/17/rtiow-ch10%EF%BC%9Apositionable-camera/","excerpt":"","text":"我们的相机之前一直都是固定死的，这次让我们来做些改变，让我们使用一个可调整的视野（fov）。 先看一下我们之前是如何设置camera的：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051706.png) 特别需要注意的是，这是在z=-1的平面上。 当时是这么说的：已知Z=-1平面上四点的坐标，我们可以求出下面三个值。 vec3 lower_left_corner(-2.0, -1.0, -1.0); vec3 horizontal(4.0, 0.0, 0.0); vec3 vertical(0.0, 2.0, 0.0); 然后，光线和平面的交点坐标可以表示为向量：lower_left_corner + u*horizontal + v*vertical。这个即为光线的方向向量。 我们要重新配置camera，引入张角 theta 和画面宽高比 aspect： [ 设整个画面的高为 half_width = aspect * half_height 所以： vec3 lower_left_corner(-half_width, -half_height,-1.0);vec3 horizontal(2*half_width, 0.0, 0.0);vec3 vertical(0.0, 2*half_height, 0.0); 在运算时，theta一般用的是弧度，而我们在给函数设置参数时使用角度更为方便。所以，引入角度vfov=theta*180/M_PI（即，theta = vfov * M_PI/180）。ofov有个专业的名称：fieldof view 对于任意观测点，我们称： 放相机的位置为lookfrom，我们看的点（画面中心点）为lookat，相机的倾斜方向为view up （简称vup，一般设置为（0，1，0）） [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051710.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051710.png) 有了这三个东东，我们现在就要找出相机在任意点的标准正交基（也就是相机要建立自己的坐标系，然后在自己的坐标系看之前坐标系的物体）。 w = unit_vector(lookfrom - lookat)（w相当于z） u = unit_vector(cross(vup, w))（u相当于x） v = cross(w, u)（v相当于y） [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051711.png) w为什么相当于z？这个是由放相机的位置（lookfrom）和目标点（lookat）确定的。 u为什么相当于x？因为相机倾斜方向vup和y比较接近，所以vup和w叉乘之后就是x。 v为什么相当于y？z、x都确定了，还有的选么？另外，w和u的叉乘相当于z、x的叉乘，结果也是y。 camera.h： #ifndef cameraH#define cameraH //M_PI 是一个宏定义，圆周率的定义，math文件中也有这家伙。#define M_PI 3.14159265358979323846 #include “ray.h” class camera{ vec3 origin; vec3 lower_left_corner; vec3 horizontal; vec3 vertical; public: camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect) { vec3 u, v, w; //theta张角 float theta = vfov \\* M\\_PI / 180; //一半的高度等于tan（theta/2） float half\\_height = tan(theta / 2); //aspect画面宽高比例 float half\\_width = aspect \\* half\\_height; //lookform相机位置 origin = lookfrom; //lookat相机看相的点 //w得到一个相机正前方的向量 //垂直于 w 与 view of up（简写为vup）的向量即为“平面上”横向的向量， //垂直于横向向量与 w 的向量即为竖向向量 w = unit\\_vector(lookfrom - lookat); u = unit\\_vector(cross(vup, w)); v = cross(w, u); lower\\_left\\_corner = origin - half\\_width \\* u - half\\_height \\* v - w; horizontal = 2 \\* half\\_width \\* u; vertical = 2 \\* half\\_height \\* v; } ray getray(float u, float v) { return ray(origin, lower\\_left\\_corner + u \\* horizontal + v \\* vertical - origin); }};#endif cpp： #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h”#include “material.h” using namespace std; //获得反射射线vec3 RandomInUnitsphere(){ vec3 p; do{ p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (dot(p, p) &gt;= 1.0f); return p;} vec3 Color(const ray&amp; r, hitable* world, int depth){ //这个“rec”会在sphere::hit ()中带上来被撞击球的材料属性（指向一个材质对象的指针mat_ptr）。 //根据这个指针可以获取材料对象的成员方法scatter()和成员变量albedo（反射衰减向量） hit_record rec; if (world-&gt;hit(r, 0.001f, FLT_MAX, rec)) { ray scattered; vec3 attenuation; if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) { //获取反射光线向量scattered和反射衰减向量attenuation return attenuation * Color(scattered, world, depth + 1); //反射光线的强度需要乘以反射衰减向量（对应坐标相乘作为新的向量）。 //然后反射光线就扮演之前“原始光线”的角色。如果再次撞击到小球，就再次反射，直到不再撞击到任何球为止 } else { return vec3(0.0f, 0.0f, 0.0f); } } else { //绘制背景 vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f); //注意这里，原始光线和反射光线最后都会跑到这里来。 //背景的颜色：原始光线的方向向量的映射 //漫反射材料和镜面材料的颜色：最后一次反射光线的方向向量的映射 \\* 所有反射衰减系数的乘积。 //漫反射和镜面反射的区别在于，漫反射的每次反射方向是随机的 }} //And add some metal spheresint main(){ ofstream outfile; outfile.open(“IMG2.ppm”); int nx = 800; int ny = 400; //采样次数 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* list\\[5\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f, new lambertian(vec3(0.8f, 0.3f, 0.3f))); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f, new lambertian(vec3(0.8f, 0.8f, 0.0f))); list\\[2\\] = new sphere(vec3(1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.6f, 0.2f), 0.3f)); list\\[3\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new dielectric(1.5f)); list\\[4\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new dielectric(1.5f)); hitable\\* world = new hitable\\_list(list, 5); camera cam(vec3(-2.0f, 2.0f, 1.0f), vec3(0.0f, 0.0f, -1.0f), vec3(0.0f, 1.0f, 0.0f), 60, float(nx) / float(ny)); //随机数 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //vec3 p = r.point\\_at\\_parameter(2.0); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world, 0); } //获得区域的颜色均值 col /= float(ns); //gamma矫正 col = vec3(sqrt(col\\[0\\]), sqrt(col\\[1\\]), sqrt(col\\[2\\])); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 设置fov为60度时，效果如下： 设置fov为90度时，效果如下： 参考链接：https://blog.csdn.net/libing\\_zeng/article/details/54560334 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch9：Dielectrics","slug":"rtiow-ch9：dielectrics","date":"2018-05-17T06:23:53.000Z","updated":"2020-07-05T08:56:51.321Z","comments":false,"path":"2018/05/17/rtiow-ch9：dielectrics/","link":"","permalink":"http://yoursite.com/2018/05/17/rtiow-ch9%EF%BC%9Adielectrics/","excerpt":"","text":"透明材料如水，玻璃和钻石是电介质。 当光线照射到它们时，它会分裂成反射光线和折射（透射）光线。 我们将通过在反射或折射之间随机选择并仅产生一个散射射线来处理这个问题。 反射光线的方向向量： 漫反射：n + p。其中n为单位法向量，p为“起点在原点，长度小于1，方向随机”的随机向量。 镜面反射：v - 2*dot(v,n)*n。其中n为单位法向量，v为入射光线的方向向量。 折射光线的方向向量： 斯奈尔定律描述了折射： n sin（theta）= n’sin（theta’） 其中n和n’是折射率（典型地，空气= 1，玻璃= 1.3-1.7，金刚石= 2.4） [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051704.png) 当射线处于更高的材料中时的折射率，斯奈尔定律没有真正的解决方案，因此没有折射可能。在这里所有的光线都会被反射出来，因为在实践中这通常都是固体对象，它被称为“全内反射”。这就是为什么有时候水 - 空气，当你被淹没时，边界就像一面完美的镜子。 菲涅尔反射定律：在真实世界中，除了金属之外，其它物质均有不同程度的“菲涅尔效应”。视线垂直于表面时，反射较弱，而当视线非垂直表面时，夹角越小，反射越明显。如果你看向一个圆球，那圆球中心的反射较弱，靠近边缘较强。不过这种过度关系被折射率影响。 实际的生活经验告诉我们，光在不同介质表面会同时发生折射和反射。如果你站在湖边，低头看脚下的水，你会发现水是透明的，反射不是特别强烈；如果你看远处的湖面，你会发现水并不是透明的，波光粼粼，反射非常强烈，这就是“菲涅尔效应”。通过菲涅尔反射定律，我们可以计算出光分裂之后的反射折射比。 material.h新加的内容： //菲涅尔反射，这里用的是Schlick近似float schlick(float cosine, float ref_idx){ float r0 = (1 - ref_idx) / (1 + ref_idx); r0 = r0 * r0; return r0 + (1 - r0) * pow((1 - cosine), 5);} //计算折射光线的方向向量。ni_over_nt 为入射介质的折射指数和折射介质的折射指数的比值。bool refract(const vec3&amp; v, const vec3&amp; n, float ni_over_nt, vec3&amp; refracted){ vec3 uv = unit_vector(v); float dt = dot(uv, n); float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1 - dt * dt); if (discriminant &gt; 0) { refracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant); return true; } else //根号里面的内容小于零，说明折射光线的方向向量无实根，即没有折射光线，即出现全反射。 //所以，折射光线函数return false return false;} //通过入射光线，计算反射光线vec3 reflect(const vec3&amp; v, const vec3&amp; n){ return v - 2 * dot(v, n) * n;} //透明折射模型class dielectric : public material {public: //相对于空气的折射率 float ref_idx; dielectric(float ri) : ref\\_idx(ri) { } virtual bool scatter(const ray&amp; r\\_in, const hit\\_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const { vec3 outward\\_normal; vec3 reflected = reflect(r\\_in.direction(), rec.normal); //ni\\_over\\_nt为入射介质的折射指数和折射介质的折射指数的比值 float ni\\_over\\_nt; //介质的衰减向量为（1，1，1）不是光线不衰减 attenuation = vec3(1.0, 1.0, 1.0); vec3 refracted; float reflect\\_prob; float cosine; if (dot(r\\_in.direction(), rec.normal) &gt; 0) { outward\\_normal = -rec.normal; /\\*光线的方向向量和球的法向量的点乘大于零，说明光线是从球体内部射入空气。 所以，入射时的法向量和球的法向量方向相反；注意，ref\\_idx是指光密介质的折射指数和光疏介质的折射指数的比值， 此时入射介质是光密介质，折射介质是光疏介质，所以ni\\_over\\_nt=ref\\_idx\\*/ ni\\_over\\_nt = ref\\_idx; //cosine = ref\\_idx \\* dot(r\\_in.direction(), rec.normal) / r\\_in.direction().length(); cosine = dot(r\\_in.direction(), rec.normal) / r\\_in.direction().length(); cosine = sqrt(1 - ref\\_idx\\* ref\\_idx\\*(1-cosine\\* cosine)); } else{ outward\\_normal = rec.normal; /\\*光线的方向向量和球的法向量的点乘bu大于零，说明光线是从空气射入球体气。 所以，入射时的法向量和球的法向量方向同向；注意，ref\\_idx是指光密介质的折射指数和光疏介质的折射指数的比值， 此时入射介质是光疏介质，折射介质是光密介质，所以ni\\_over\\_nt=1.0/ref\\_idx\\*/ ni\\_over\\_nt = 1.0 / ref\\_idx; cosine = -dot(r\\_in.direction(), rec.normal) / r\\_in.direction().length(); } if (refract(r\\_in.direction(), outward\\_normal, ni\\_over\\_nt, refracted)) reflect\\_prob = schlick(cosine, ref\\_idx); else reflect\\_prob = 1.0; //if (drand48() &lt; reflect\\_prob) if ((rand() % (100) / (float)(100)) &lt; reflect\\_prob) scattered = ray(rec.p, reflected); else scattered = ray(rec.p, refracted); return true; }}; cpp： #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h”#include “material.h” using namespace std; //获得反射射线vec3 RandomInUnitsphere(){ vec3 p; do{ p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (dot(p, p) &gt;= 1.0f); return p;} vec3 Color(const ray&amp; r, hitable* world, int depth){ //这个“rec”会在sphere::hit ()中带上来被撞击球的材料属性（指向一个材质对象的指针mat_ptr）。 //根据这个指针可以获取材料对象的成员方法scatter()和成员变量albedo（反射衰减向量） hit_record rec; if (world-&gt;hit(r, 0.001f, FLT_MAX, rec)) { ray scattered; vec3 attenuation; if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) { //获取反射光线向量scattered和反射衰减向量attenuation return attenuation * Color(scattered, world, depth + 1); //反射光线的强度需要乘以反射衰减向量（对应坐标相乘作为新的向量）。 //然后反射光线就扮演之前“原始光线”的角色。如果再次撞击到小球，就再次反射，直到不再撞击到任何球为止 } else { return vec3(0.0f, 0.0f, 0.0f); } } else { //绘制背景 vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f); //注意这里，原始光线和反射光线最后都会跑到这里来。 //背景的颜色：原始光线的方向向量的映射 //漫反射材料和镜面材料的颜色：最后一次反射光线的方向向量的映射 \\* 所有反射衰减系数的乘积。 //漫反射和镜面反射的区别在于，漫反射的每次反射方向是随机的 }} //And add some metal spheresint main(){ ofstream outfile; outfile.open(“IMG2.ppm”); int nx = 800; int ny = 400; //采样次数 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* list\\[5\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f, new lambertian(vec3(0.8f, 0.3f, 0.3f))); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f, new lambertian(vec3(0.8f, 0.8f, 0.0f))); list\\[2\\] = new sphere(vec3(1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.6f, 0.2f), 0.3f)); list\\[3\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new dielectric(1.5f)); list\\[4\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), -0.45f, new dielectric(1.5f)); hitable\\* world = new hitable\\_list(list, 5); camera cam; //随机数 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //vec3 p = r.point\\_at\\_parameter(2.0); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world, 0); } //获得区域的颜色均值 col /= float(ns); //gamma矫正 col = vec3(sqrt(col\\[0\\]), sqrt(col\\[1\\]), sqrt(col\\[2\\])); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最终效果： 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch8：Metal","slug":"rtiow-ch8：metal","date":"2018-05-16T16:16:20.000Z","updated":"2020-07-05T08:56:51.318Z","comments":false,"path":"2018/05/17/rtiow-ch8：metal/","link":"","permalink":"http://yoursite.com/2018/05/17/rtiow-ch8%EF%BC%9Ametal/","excerpt":"","text":"我们希望不同的物体有不同的材质，所以我们可以搞个material类。 射线如何从金属镜面反射出来： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051701.png) 红色的反射光线方向正好是（v + 2B）。 在我们的设计中，N是一个单位矢量，但是v未必。 B的长度应该是点（v，N）。 因为v指向，我们将需要一个相减运算。 我们可以将镜面反射和漫反射模型结合起来，营造出蒙蒙的镜面效果。通过一个名为fuzz的参数约束漫反射的收束程度，当fuzz=0的时候，就是理想的镜面反射效果： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051703.png) material.h： #ifndef MATERIALH#define MATERIALH struct hit_record; #include “ray.h”#include “hitable.h” //通过入射光线，计算反射光线vec3 reflect(const vec3&amp; v, const vec3&amp; n){ return v - 2 * dot(v, n) * n;} //生成随机方向的标准向量//产生一个“起点在原点，长度小于1，方向随机”的向量，该向量和交点处单位法向量相加就得到交点处反射光线随机的方向向量vec3 random_in_unit_sphere(){ vec3 p; do{ //p = 2.0*vec3(drand48(),drand48(),drand48()) - vec3(1,1,1); p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (p.squared_length() &gt;= 1.0); return p;} //材质抽象类class material{ public: virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const = 0;}; //漫反射材质class lambertian : public material { public: lambertian(const vec3&amp; a) : albedo(a) { } //将求反射光线的部分放到了材质类的scatter()方法里，每个材质可以自己定义其反射光线 //获取漫反射的反射光线；获取材料的衰减系数; virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const { vec3 target = rec.p + rec.normal + random_in_unit_sphere(); scattered = ray(rec.p, target-rec.p); attenuation = albedo; return true; } vec3 albedo;}; //镜面反射材质，金属材质用这个反射光线class metal : public material { public: //f为零，说明没有模糊 metal(const vec3&amp; a, float f) : albedo(a) { if (f &lt; 1) fuzz = f; else fuzz = 1; } //metal (const vec3&amp; a):albedo(a){} virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const { vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal); scattered = ray(rec.p, reflected + fuzz* random_in_unit_sphere()); attenuation = albedo; return (dot(scattered.direction(), rec.normal) &gt; 0); } vec3 albedo; float fuzz;}; #endif cpp： #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h”#include “material.h” using namespace std; //获得反射射线vec3 RandomInUnitsphere(){ vec3 p; do{ p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (dot(p, p) &gt;= 1.0f); return p;} vec3 Color(const ray&amp; r, hitable* world, int depth){ //这个“rec”会在sphere::hit ()中带上来被撞击球的材料属性（指向一个材质对象的指针mat_ptr）。 //根据这个指针可以获取材料对象的成员方法scatter()和成员变量albedo（反射衰减向量） hit_record rec; if (world-&gt;hit(r, 0.001f, FLT_MAX, rec)) { ray scattered; vec3 attenuation; if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) { //获取反射光线向量scattered和反射衰减向量attenuation return attenuation * Color(scattered, world, depth + 1); //反射光线的强度需要乘以反射衰减向量（对应坐标相乘作为新的向量）。 //然后反射光线就扮演之前“原始光线”的角色。如果再次撞击到小球，就再次反射，直到不再撞击到任何球为止 } else { return vec3(0.0f, 0.0f, 0.0f); } } else { //绘制背景 vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f); //注意这里，原始光线和反射光线最后都会跑到这里来。 //背景的颜色：原始光线的方向向量的映射 //漫反射材料和镜面材料的颜色：最后一次反射光线的方向向量的映射 \\* 所有反射衰减系数的乘积。 //漫反射和镜面反射的区别在于，漫反射的每次反射方向是随机的 }} //And add some metal spheresint main(){ ofstream outfile; outfile.open(“IMG3.ppm”); int nx = 800; int ny = 400; //采样次数 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* list\\[4\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f, new lambertian(vec3(0.8f, 0.3f, 0.3f))); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f, new lambertian(vec3(0.8f, 0.8f, 0.0f))); list\\[2\\] = new sphere(vec3(1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.6f, 0.2f), 0.1f)); list\\[3\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.8f, 0.8f), 0.1f)); /\\*list\\[2\\] = new sphere(vec3(1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.6f, 0.2f))); list\\[3\\] = new sphere(vec3(-1.0f, 0.0f, -1.0f), 0.5f, new metal(vec3(0.8f, 0.8f, 0.8f)));\\*/ hitable\\* world = new hitable\\_list(list, 4); camera cam; //随机数 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world, 0); } //获得区域的颜色均值 col /= float(ns); //gamma矫正 col = vec3(sqrt(col\\[0\\]), sqrt(col\\[1\\]), sqrt(col\\[2\\])); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最终效果： 左右两个球是镜面材质球，每个球中都有其他两个球的镜像。注意是镜像，不是透明。 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch7：Diffuse Materials","slug":"triow-ch7：diffuse-materials","date":"2018-05-16T10:55:19.000Z","updated":"2020-07-05T08:56:51.316Z","comments":false,"path":"2018/05/16/triow-ch7：diffuse-materials/","link":"","permalink":"http://yoursite.com/2018/05/16/triow-ch7%EF%BC%9Adiffuse-materials/","excerpt":"","text":"现在我们每个像素都有对象和多条光线，我们可以做出一些逼真的外观材质。我们将从漫反射（无光泽）材质开始。 不发光的漫反射物体仅仅呈现周围的颜色，从漫反射表面反射的光有其随机的方向。现实生活中，我们经常接触到一些看起来暗淡粗糙的物体，他们之所以显得不那么光鲜，是因为当光线照射到他们之上时，其凹凸不平的表面令光线缺乏统一的反射方向。所以，如果我们发送三条光线进入两​​个漫射之间的裂缝表面他们将有不同的随机行为： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051604.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051604.png) 某些光线也可能被吸收而不是被反射。表面越黑暗，越有可能吸收，这就是为什么它是黑暗的原因。 法向量N，撞点p，随机点s。从与击中点相切的单位半径球体中选取一个随机点s，并发送一个从命中点p到随机点s的射线，这条射线就是我们反射出去的射线。[![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051605.png) cpp: #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h” using namespace std; //获得反射射线vec3 RandomInUnitSphere(){ vec3 p; do { p = 2.0f * vec3((rand() % 100 / float(100)), (rand() % 100 / float(100)), (rand() % 100 / float(100))) - vec3(1.0f, 1.0f, 1.0f); } while (dot(p, p) &gt;= 1.0f); return p;} vec3 Color(const ray&amp; r, hitable* world){ hit_record rec; if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) { vec3 target = rec.p + rec.normal + RandomInUnitSphere(); //递归，每次吸收50%的能量 return 0.5f * Color(ray(rec.p, target - rec.p), world); } else { vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended_value = (1-t)*start_value + t*end_value return (1.0f - t) * vec3(1.0f, 1.0f, 1.0f) + t * vec3(0.5f, 0.7f, 1.0f); }} int main(){ ofstream outfile; outfile.open(“IMG01.ppm”); int nx = 800; int ny = 400; //采样次数 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* list\\[2\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f); hitable\\* world = new hitable\\_list(list, 2); camera cam; //随机数，每个像素点的区域是以像素中心点为中心向外距离为1的范围 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //vec3 p = r.point\\_at\\_parameter(2.0); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world); } //获得区域的颜色均值 col /= float(ns); //gamma矫正 col = vec3(sqrt(col\\[0\\]), sqrt(col\\[1\\]), sqrt(col\\[2\\])); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最终效果： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051606.jpg) gamma矫正： //获得区域的颜色均值col /= float(ns);//gamma矫正col = vec3(sqrt(col[0]), sqrt(col[1]), sqrt(col[2]));int ir = int(255.99 * col[0]);int ig = int(255.99 * col[1]);int ib = int(255.99 * col[2]);outfile &lt;&lt; ir &lt;&lt; “ “ &lt;&lt; ig &lt;&lt; “ “ &lt;&lt; ib &lt;&lt; “\\n”; 未gamma矫正的效果如下： 注意球体下的阴影。这张照片非常黑暗，但我们的球体只每次反弹吸收一半的能量，所以它们是50％的反射，这些阴影本应该是浅灰色的。作者的观点： To a first approximation, we can use “gamma 2” which means raising the color to the power 1/gamma, or in our simple case ½, which is just square-root。 第一个近似值，我们可以使用“gamma 2”，这意味着增加颜色的作用1/gamma，或者在我们的简单些情况里，这仅仅是平方根。 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch6：Antialiasing","slug":"rtiow-ch6：antialiasing","date":"2018-05-15T19:32:23.000Z","updated":"2020-07-05T08:56:51.313Z","comments":false,"path":"2018/05/16/rtiow-ch6：antialiasing/","link":"","permalink":"http://yoursite.com/2018/05/16/rtiow-ch6%EF%BC%9Aantialiasing/","excerpt":"","text":"Antialiasing：抗锯齿，反走样。 先看上一节的这张图，可以看出有一些锯齿存在，我们需要模糊化处理这些锯齿： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051601-300x276.png) 边缘像素是一些前景和某些背景的混合物。我使用的是800乘400的大小，也就是有320000个像素点。之前的图是每个像素点设置一个颜色值，相当于将像素中心位置的颜色设置给了整个像素。所以，如果两个像素点中心位置的颜色值相差比较大时，这两个像素点就会产生清晰的边界。 而我们要做的就是针对每一个像素点，颜色取样一百次，求平均值，这个平均值就是这个像素点的颜色，这样就达到了一种模糊的效果，从而有效降低锯齿。 蒙特卡罗方法： 蒙特卡罗方法又称统计模拟法、随机抽样技术，是一种随机模拟方法，以概率和统计理论方法为基础的一种计算方法，是使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。将所求解的问题同一定的概率模型相联系，用电子计算机实现统计模拟或抽样，以获得问题的近似解。为象征性地表明这一方法的概率统计特征，故借用赌城蒙特卡罗命名。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051603.png) 将之前的camera封装起来： camera.h： #ifndef cameraH#define cameraH #include “ray.h” class camera{ public: camera() { lower_left_corner = vec3(-2.0f, -1.0f, -1.0f); horizontal = vec3(4.0f, 0.0f, 0.0f); vertical = vec3(0.0f, 2.0f, 0.0f); origin = vec3(0.0f, 0.0f, 0.0f); } ray getray(float u, float v) { return ray(origin, lower\\_left\\_corner + u \\* horizontal + v \\* vertical - origin); } vec3 origin; vec3 lower\\_left\\_corner; vec3 horizontal; vec3 vertical;};#endif cpp： #include #include #include #include “sphere.h”#include “hitable_list.h”#include “camera.h” using namespace std; vec3 Color(const ray&amp; r, hitable* world){ hit_record rec; if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) { return 0.5f * vec3(rec.normal.x() + 1.0f, rec.normal.y() + 1.0f, rec.normal.z() + 1.0f); } else { vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended_value = (1-t)*start_value + t*end_value return (1.0f - t) * vec3(1.0f, 1.0f, 1.0f) + t * vec3(0.5f, 0.7f, 1.0f); }} int main(){ ofstream outfile; outfile.open(“IMG.ppm”); int nx = 800; int ny = 400; //采样次数100次 int ns = 100; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; hitable\\* list\\[2\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f); hitable\\* world = new hitable\\_list(list, 2); camera cam; //随机数，每个像素点的区域是以像素中心点为中心向外距离为1的范围 default\\_random\\_engine reng; uniform\\_real\\_distribution&lt;float&gt; uni\\_dist(0.0f, 1.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 col(0.0f, 0.0f, 0.0f); //每个区域采样ns次 for (int s = 0; s &lt; ns; s++) { float u = float(i + uni\\_dist(reng)) / float(nx); float v = float(j + uni\\_dist(reng)) / float(ny); ray r = cam.getray(u, v); //vec3 p = r.point\\_at\\_parameter(2.0); //将本区域（(u,v)到(u+1,v+1)）的颜色值累加 col += Color(r, world); } //获得区域的颜色均值 col /= float(ns); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 每个像素点都采样100次，明显感觉渲染速度变慢了。 抗锯齿之后的效果图： 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch5：Surface normals and multiple objects","slug":"rtiow-ch5：surface-normals-and-multiple-objects","date":"2018-05-15T12:40:48.000Z","updated":"2020-07-05T08:56:51.311Z","comments":false,"path":"2018/05/15/rtiow-ch5：surface-normals-and-multiple-objects/","link":"","permalink":"http://yoursite.com/2018/05/15/rtiow-ch5%EF%BC%9Asurface-normals-and-multiple-objects/","excerpt":"","text":"法向量，垂直于表面，方向为相交点p减去球心点c的方向向量。 用色彩表可视化单位法向量，让法向量的XYZ值映射到RGB值，使得球有一个渐变的效果，具体做法：考虑x/y/z在[-1,1]，r/g/b在[0,1]，怎么映射？x/y/z分别+1然后/2 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051503-300x137.png) cpp: #include #include #include “ray.h”using namespace std; //此时该函数的返回值从ch4的bool变为floatfloat hit_sphere(const vec3&amp; center, float radius, const ray&amp; r){ vec3 oc = r.origin() - center; float a = dot(r.direction(), r.direction()); float b = 2.0f * dot(oc, r.direction()); float c = dot(oc, oc) - radius * radius; //判断这个方程有没有根，如果有2个根就是击中 float discrimiant = b * b - 4.0f * a * c; if (discrimiant &lt; 0.0f) { return -1.0f; } else { return (-b - sqrt(discrimiant)) / (2.0f * a); }} vec3 Color(const ray&amp; r){ float t = hit_sphere(vec3(0.0f, 0.0f, -1.0f), 0.5, r); if (t &gt; 0.0f) { //法向量 vec3 N = unit_vector(r.point_at_parameter(t) - vec3(0.0f, 0.0f, -1.0f)); return 0.5f * vec3(N.x() + 1.0f, N.y() + 1.0f, N.z() + 1.0f); } //绘制背景 vec3 unit_direction = unit_vector(r.direction()); //t从0到1 t = 0.5f * (unit_direction.y() + 1.0f); //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f);} int main(){ ofstream outfile; outfile.open(“IMG.ppm”); int nx = 800; int ny = 400; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; //视锥体左下角 vec3 lower\\_left\\_corner(-2.0f, -1.0f, -1.0f); //距离左下角的水平距离 vec3 horizontal(4.0f, 0.0f, 0.0f); //距离左下角的垂直距离 vec3 vertical(0.0f, 2.0f, 0.0f); //起始点 vec3 origin(0.0f, 0.0f, 0.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { //u从0开始越来越接近1；v从无限接近1开始，越来越接近0 float u = float(i) / float(nx); float v = float(j) / float(ny); ray r(origin, lower\\_left\\_corner +u \\* horizontal + v \\* vertical); vec3 col = Color(r); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 运行效果： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051501.jpg) 下面是多个球的出现： hitable.h 抽象类： #ifndef hitableH#define hitableH #include “ray.h”class material; //撞击点信息struct hit_record{ //射线参数t float t; //撞击点位置向量p vec3 p; //撞击点位置向量N vec3 normal; material* mat_ptr;}; //所有能被射线撞击的物体的父类class hitable{ public: //hit()虚函数 virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0;}; #endif sphere.h： #ifndef sphereH#define sphereH #include “hitable.h” class sphere : public hitable { public: sphere(){ } //sphere(vec3 cen, float r, material *m) : center(cen), radius(r), mat_ptr(m) {}; sphere(vec3 cen, float r) : center(cen), radius(r) { }; virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const; vec3 center; float radius; material* mat_ptr;}; bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const { vec3 oc = r.origin() - center; float a = dot(r.direction(), r.direction()); float b = dot(oc, r.direction()); float c = dot(oc, oc) - radius * radius; float discriminant = b * b - a * c; if (discriminant &gt; 0) { float temp = (-b - sqrt(discriminant)) / a; if (temp&lt;t_max &amp;&amp; temp&gt; t_min) { rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; rec.mat_ptr = mat_ptr; return true; } temp = (-b + sqrt(discriminant)) / a; if (temp&lt;t_max &amp;&amp; temp&gt; t_min) { rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; rec.mat_ptr = mat_ptr; return true; } } return false;} #endif hitable_list.h： #ifndef hitableLISTH#define hitableLISTH #include “hitable.h” class hitable_list : public hitable { public: hitable_list(){ } hitable_list(hitable** l, int n){ list = l; list_size = n; } virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const; hitable** list; int list_size;}; bool hitable_list::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const { hit_record temp_rec; bool hit_anything = false; double closest_so_far = t_max; //依次判断列表中所有物体是否被光线撞到 for (int i = 0; i&lt;list_size; i++) { if (list[i]-&gt;hit(r, t_min, closest_so_far, temp_rec)) { hit_anything = true; closest_so_far = temp_rec.t; rec = temp_rec; } } return hit_anything;} #endif cpp： #include #include #include “sphere.h”#include “hitable_list.h” using namespace std; vec3 Color(const ray&amp; r, hitable* world){ hit_record rec; if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) { return 0.5f * vec3(rec.normal.x() + 1.0f, rec.normal.y() + 1.0f, rec.normal.z() + 1.0f); } else { vec3 unit_direction = unit_vector(r.direction()); float t = 0.5f * (unit_direction.y() + 1.0f); return (1.0f - t) * vec3(1.0f, 1.0f, 1.0f) + t * vec3(0.5f, 0.7f, 1.0f); }} int main(){ ofstream outfile; outfile.open(“IMG2.ppm”); int nx = 800; int ny = 400; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; vec3 lower\\_left\\_corner(-2.0f, -1.0f, -1.0f); vec3 horizontal(4.0f, 0.0f, 0.0f); vec3 vertical(0.0f, 2.0f, 0.0f); vec3 origin(0.0f, 0.0f, 0.0f); hitable\\* list\\[2\\]; list\\[0\\] = new sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f); list\\[1\\] = new sphere(vec3(0.0f, -100.5f, -1.0f), 100.0f); hitable\\* world = new hitable\\_list(list, 2); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { float u = float(i) / float(nx); float v = float(j) / float(ny); ray r(origin, lower\\_left\\_corner +u \\* horizontal + v \\* vertical); vec3 p = r.point\\_at\\_parameter(2.0); vec3 col = Color(r, world); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最终效果： 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch4：Adding a sphere","slug":"1225","date":"2018-05-13T18:24:49.000Z","updated":"2020-07-05T11:16:12.998Z","comments":false,"path":"2018/05/14/1225/","link":"","permalink":"http://yoursite.com/2018/05/14/1225/","excerpt":"","text":"球体是非常简单的形体，因为只需要一个球心和一个半径，就能确认球体的位置。 若我们在场景中放置一个球体，那么对球体进行采样的时候就会涉及到如何判断射线与球体相交的问题。 对于中心在C(cx,cy,cz)的球体：有方程(x−cx)∗(x−cx)+(y−cy)∗(y−cy)+(z−cz)∗(z−cz)=R∗R p点（x,y,z）满足x∗x+y∗y+z∗z=R∗R，就表明p点在球上。 上面两个式子可以写成： dot((p−C),(p−C))=R∗R=(x−cx)∗(x−cx)+(y−cy)∗(y−cy)+(z−cz)∗(z−cz) 把点 p 换做 ray 上一点 p(t)：dot((p(t)−C),(p(t)−C))=R∗R 也可以写成：dot((A+t∗B−C),(A+t∗B−C))=R∗R 可以进一步写成：t∗t∗dot(B,B)+2∗t∗dot(A−C,A−C)+dot(C,C)−R∗R=0 这是个一元二次方程，根据求根公式就可判断方程有无根，即射线有没有与球体相交。 cpp： #include #include #include “ray.h”using namespace std; bool hit_sphere(const vec3&amp; center, float radius, const ray&amp; r){ vec3 oc = r.origin() - center; float a = dot(r.direction(), r.direction()); float b = 2.0f * dot(oc, r.direction()); float c = dot(oc, oc) - radius * radius; //判断这个方程有没有根，如果有2个根就是击中 float discrimiant = b * b - 4.0f * a * c; return (discrimiant &gt; 0.0f);} vec3 Color(const ray&amp; r){ //如果相交，则返回红色 if (hit_sphere(vec3(0.0f, 0.0f, -1.0f), 0.5f, r)) return vec3(1.0f, 0.0f, 0.0f); vec3 unit\\_direction = unit\\_vector(r.direction()); //t从0到1 float t = 0.5f \\* (unit\\_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0f, 1.0f, 1.0f) + t \\* vec3(0.5f, 0.7f, 1.0f);} int main(){ ofstream outfile; outfile.open(“IMG.ppm”); int nx = 800; int ny = 400; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; //视锥体左下角 vec3 lower\\_left\\_corner(-2.0f, -1.0f, -1.0f); //距离左下角的水平距离 vec3 horizontal(4.0f, 0.0f, 0.0f); //距离左下角的垂直距离 vec3 vertical(0.0f, 2.0f, 0.0f); //起始点 vec3 origin(0.0f, 0.0f, 0.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { //u从0开始越来越接近1；v从无限接近1开始，越来越接近0 float u = float(i) / float(nx); float v = float(j) / float(ny); ray r(origin, lower\\_left\\_corner +u \\* horizontal + v \\* vertical); vec3 col = Color(r); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 运行效果： 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch3：Rays, a simple camera, and background","slug":"rtiow-rays-a-simple-camera-and-background","date":"2018-05-13T16:24:31.000Z","updated":"2020-07-05T08:56:51.307Z","comments":false,"path":"2018/05/14/rtiow-rays-a-simple-camera-and-background/","link":"","permalink":"http://yoursite.com/2018/05/14/rtiow-rays-a-simple-camera-and-background/","excerpt":"","text":"所有光线追踪器所具有的一件事就是ray类射线进行像素颜色的采集。 让我们将射线看作函数p（t）= A + t * B。这里p是一个3D位置，沿着3D线。 A是射线源，B是射线方向，射线参数是t。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051401.png) ray.h： #ifndef RAYH#define RAYH#include “vec3.h” class ray{ public: ray() { } ray(const vec3&amp; a, const vec3&amp; b) { A = a; B = b; } vec3 origin() const { return A; } vec3 direction() const { return B; } vec3 point_at_parameter(float t) const { return A + t* B; } vec3 A; vec3 B;}; #endif 假定观测者位于原点处，他将观测上图所示的截面。为了获得每个像素的颜色，观测者将向该像素所在的位置发射出一条射线（ray）进行采样。 作者使用右手坐标系，观察点在（0，0，0），y轴向上，x轴向右，屏幕里面是z的负轴，u，v偏移量表示距离左下角的距离。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051402.png) At the core of a ray tracer is to send rays through pixels and compute what color is seen in the direction of those rays. This is of the form calculate which ray goes from the eye to a pixel, compute what that ray intersects, and compute a color for that intersection point. 射线追踪器的核心是发送射线，计算在这些射线的方向上看到的是什么颜色。 这是计算哪一条射线从观察点到一个像素的计算方法，可以计算出射线方向上的颜色。 cpp： #include #include #include “ray.h”using namespace std; vec3 Color(const ray&amp; r){ vec3 unit_direction = unit_vector(r.direction()); //t从0到1 float t = 0.5f \\* (unit\\_direction.y() + 1.0f); //线性混合，t=1时蓝色，t=0时白色，t介于中间时是混合颜色 //blended\\_value = (1-t)\\*start\\_value + t\\*end\\_value return (1.0f - t) \\* vec3(1.0, 1.0, 1.0) + t \\* vec3(0.5, 0.7, 1.0);} int main(){ ofstream outfile; outfile.open(“IMG.ppm”); int nx = 800; int ny = 400; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; //视锥体左下角 vec3 lower\\_left\\_corner(-2.0f, -1.0f, -1.0f); //距离左下角的水平距离 vec3 horizontal(4.0f, 0.0f, 0.0f); //距离左下角的垂直距离 vec3 vertical(0.0f, 2.0f, 0.0f); //起始点 vec3 origin(0.0f, 0.0f, 0.0f); for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { //u从0开始越来越接近1；v从无限接近1开始，越来越接近0 float u = float(i) / float(nx); float v = float(j) / float(ny); ray r(origin, lower\\_left\\_corner +u \\* horizontal + v \\* vertical); vec3 col = Color(r); int ir = int(255.99 \\* col\\[0\\]); int ig = int(255.99 \\* col\\[1\\]); int ib = int(255.99 \\* col\\[2\\]); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 运行效果： 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch2：The vec3 class","slug":"rtiow-ch2：the-vec3-class","date":"2018-05-13T10:15:02.000Z","updated":"2020-07-05T08:56:51.305Z","comments":false,"path":"2018/05/13/rtiow-ch2：the-vec3-class/","link":"","permalink":"http://yoursite.com/2018/05/13/rtiow-ch2%EF%BC%9Athe-vec3-class/","excerpt":"","text":"几乎所有的图形程序都有一些用于存储几何向量的类颜色。 在许多系统中，这些向量是4D（3D加上一个齐次坐标）几何图形和RGB加上颜色的Alpha透明度通道）。 为了我们的目的，三个坐标就足够了。 我们将使用相同的类vec3颜色，位置，方向，偏移量等等。 类vec3.h： #ifndef VEC3H#define VEC3H #include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include class vec3{ public: vec3() { } vec3(float e0, float e1, float e2) { e[0] = e0; e[1] = e1; e[2] = e2; } inline float x() const { return e[0]; } inline float y() const { return e[1]; } inline float z() const { return e[2]; } inline float r() const { return e[0]; } inline float g() const { return e[1]; } inline float b() const { return e[2]; } inline const vec3&amp; operator +() const { return \\* this; } inline vec3 operator -() const { return vec3(-e\\[0\\], -e\\[1\\], -e\\[2\\]); } inline float operator\\[\\](int i) const { return e\\[i\\]; } inline float&amp; operator\\[\\] (int i) { return e\\[i\\]; }; inline vec3&amp; operator+=(const vec3 &amp;v2); inline vec3&amp; operator-=(const vec3 &amp;v2); inline vec3&amp; operator\\*=(const vec3 &amp;v2); inline vec3&amp; operator/=(const vec3 &amp;v2); inline vec3&amp; operator\\*=(const float t); inline vec3&amp; operator/=(const float t); inline float length() const { return sqrt(e\\[0\\]\\*e\\[0\\] + e\\[1\\]\\*e\\[1\\] + e\\[2\\]\\*e\\[2\\]); } inline float squared\\_length() const { return e\\[0\\]\\* e\\[0\\] + e\\[1\\]\\* e\\[1\\] + e\\[2\\]\\* e\\[2\\]; } inline void make\\_unit\\_vector(); float e\\[3\\];}; //输入流inline std::istream&amp; operator&gt;&gt;(std::istream &amp;is, vec3 &amp;t){ is &gt;&gt; t.e[0] &gt;&gt; t.e[1] &gt;&gt; t.e[2]; return is;} //输出流inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os, const vec3 &amp;t){ os &lt;&lt; t.e[0] &lt;&lt; “ “ &lt;&lt; t.e[1] &lt;&lt; “ “ &lt;&lt; t.e[2]; return os;} //生成单位向量inline void vec3::make_unit_vector(){ float k = 1.0 / sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]); e[0] *= k; e[1] *= k; e[2] *= k;} //向量加，减，乘，除inline vec3 operator +(const vec3 &amp;v1, const vec3 &amp;v2){ return vec3(v1.e[0] + v2.e[0], v1.e[1] + v2.e[1], v1.e[2] + v2.e[2]);} inline vec3 operator -(const vec3 &amp;v1, const vec3 &amp;v2){ return vec3(v1.e[0] - v2.e[0], v1.e[1] - v2.e[1], v1.e[2] - v2.e[2]);} inline vec3 operator *(const vec3 &amp;v1, const vec3 &amp;v2){ return vec3(v1.e[0] * v2.e[0], v1.e[1] * v2.e[1], v1.e[2] * v2.e[2]);} inline vec3 operator /(const vec3 &amp;v1, const vec3 &amp;v2){ return vec3(v1.e[0] / v2.e[0], v1.e[1] / v2.e[1], v1.e[2] / v2.e[2]);} //标量，向量之间的相互乘，除inline vec3 operator *(float t, const vec3 &amp;v){ return vec3(t * v.e[0], t * v.e[1], t * v.e[2]);} inline vec3 operator /(vec3 v, float t){ return vec3(v.e[0] / t, v.e[1] / t, v.e[2] / t);} inline vec3 operator *(const vec3 &amp;v, float t){ return vec3(t * v.e[0], t * v.e[1], t * v.e[2]);} //两向量点乘inline float dot(const vec3 &amp;v1, const vec3 &amp;v2){ return v1.e[0] * v2.e[0] + v1.e[1] * v2.e[1] + v1.e[2] * v2.e[2];} //两向量叉乘inline vec3 cross(const vec3 &amp;v1, const vec3 &amp;v2){ return vec3((v1.e[1] * v2.e[2] - v1.e[2] * v2.e[1]), (-(v1.e[0] * v2.e[2] - v1.e[2] * v2.e[0])), (v1.e[0] * v2.e[1] - v1.e[1] * v2.e[0]));} //重载类中声明过的运算符inline vec3&amp; vec3::operator+=(const vec3 &amp;v){ e[0] += v.e[0]; e[1] += v.e[1]; e[2] += v.e[2]; return *this;} inline vec3&amp; vec3::operator*=(const vec3 &amp;v){ e[0] *= v.e[0]; e[1] *= v.e[1]; e[2] *= v.e[2]; return *this;} inline vec3&amp; vec3::operator/=(const vec3 &amp;v){ e[0] /= v.e[0]; e[1] /= v.e[1]; e[2] /= v.e[2]; return *this;} inline vec3&amp; vec3::operator-=(const vec3&amp; v){ e[0] -= v.e[0]; e[1] -= v.e[1]; e[2] -= v.e[2]; return *this;} inline vec3&amp; vec3::operator*=(const float t){ e[0] *= t; e[1] *= t; e[2] *= t; return *this;} inline vec3&amp; vec3::operator/=(const float t){ float k = 1.0 / t; e\\[0\\] \\*= k; e\\[1\\] \\*= k; e\\[2\\] \\*= k; return \\*this;} //归一化向量inline vec3 unit_vector(vec3 v){ return v / v.length();} #endif wjg.cpp中的main方法改为这样写： #include #include “vec3.h”#include using namespace std; int main(){ ofstream outfile; outfile.open(“IMG.txt”); int nx = 800, ny = 400; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { vec3 vecTemp(float(i) / float(nx), float(j) / float(ny), 0.2); int iRed = int(255.99 \\* vecTemp\\[0\\]); int iGreen = int(255.99 \\* vecTemp\\[1\\]); int iBlue = int(255.99 \\* vecTemp\\[2\\]); outfile &lt;&lt; iRed &lt;&lt; &quot; &quot; &lt;&lt; iGreen &lt;&lt; &quot; &quot; &lt;&lt; iBlue &lt;&lt; &quot;\\\\n&quot;;}} outfile.close(); return 0;} 修改txt文件为ppm，结果依然是： 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"RTIOW-ch1：Output an image","slug":"《ray-tracing-in-one-weekend》ch1：output-an-image","date":"2018-05-13T09:15:51.000Z","updated":"2020-07-05T11:16:01.440Z","comments":false,"path":"2018/05/13/《ray-tracing-in-one-weekend》ch1：output-an-image/","link":"","permalink":"http://yoursite.com/2018/05/13/%E3%80%8Aray-tracing-in-one-weekend%E3%80%8Bch1%EF%BC%9Aoutput-an-image/","excerpt":"","text":"使用C++代码生成一张图片，需要用到PPM图像格式。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051301-300x101.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051301.png) PPM格式介绍： PBM 是位图（bitmap），仅有黑与白，没有灰 PGM 是灰度图（grayscale） **PPM 是通过RGB三种颜色显现的图像（pixmaps）** 每个图像文件的开头都通过2个字节「magic number」来表明文件格式的类型（PBM, PGM, PPM），以及编码方式（ASCII 或 Binary），magic number分别为P1、P2、P3、P4、P5、P6 [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18051305-300x120.png) 编码方式： ASCII格式适合人类阅读理解，可以用文本编辑器打开，读取对应图像的数据（比如PPM格式的RGB值）。 Binary格式适合机器阅读，按照二进制形式，顺序存储图像信息，不用空格分隔，所以图像处理起来更有效率，占用空间容量更少（由于缺少空格）。 PPM格式： ** PPM图像格式分为两部分，分别为头部分和图像数据部分。** ** 头部分：由3部分组成，通过换行或空格进行分割，一般PPM的标准是空格。** ** 第1部分：P3或P6，指明PPM的编码格式，** ** 第2部分：图像的宽度和高度，通过ASCII表示，** ** 第3部分：最大像素值，0-255字节表示。** 图像数据部分： ASCII格式：按RGB的顺序排列，RGB中间用空格隔开，图片每一行用回车隔开。 Binary格式：PPM用24bits代表每一个像素，红绿蓝分别占用8bits。 代码： #include #include using namespace std; int main(){ ofstream outfile; outfile.open(“IMG.txt”); int nx = 800; int ny = 400; outfile &lt;&lt; &quot;P3\\\\n&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\\\\n255\\\\n&quot;; for (int j = ny - 1; j &gt;= 0; j--) { for (int i = 0; i &lt; nx; i++) { //从左到右，红色通道值增加 float r = float(i) / float(nx); //从上到下，绿色通道值减小 float g = float(j) / float(ny); //蓝色通道值不变 float b = 0.2f; int ir = int(255.99f \\* r); int ig = int(255.99f \\* g); int ib = int(255.99f \\* b); outfile &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; ig &lt;&lt; &quot; &quot; &lt;&lt; ib &lt;&lt; &quot;\\\\n&quot;; } } outfile.close(); return 0;} 最后生成一个txt文件，修改后缀为ppm： 用photoshop打开ppm文件，最后的效果图如下： PPM参考链接：https://www.jianshu.com/p/e809269b4ad7 参考书籍：《Ray Tracing in One Weekend》 RTIOW系列项目地址：GitHub RTIOW系列笔记： RTIOW-ch1：Output an image RTIOW-ch2：The vec3 class RTIOW-ch3：Rays, a simple camera, and background RTIOW-ch4：Adding a sphere RTIOW-ch5：Surface normals and multiple objects RTIOW-ch6：Antialiasing RTIOW-ch7：Diffuse Materials RTIOW-ch8：Metal RTIOW-ch9：Dielectrics RTIOW-ch10：Positionable camera RTIOW-ch11：Defocus Blur RTIOW-ch12：Where next","categories":[],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"}]},{"title":"实现3D向量类Vector3","slug":"实现3d向量类vector3","date":"2018-05-08T13:24:42.000Z","updated":"2020-07-05T08:56:51.300Z","comments":false,"path":"2018/05/08/实现3d向量类vector3/","link":"","permalink":"http://yoursite.com/2018/05/08/%E5%AE%9E%E7%8E%B03d%E5%90%91%E9%87%8F%E7%B1%BBvector3/","excerpt":"","text":"Vector3类用来存储3D向量的x，y，z分量 这个类应该具有的功能有： 1.存取向量的各分量（x，y，z） 2.向量间的赋值操作 3.比较两向量是否相同 4.将向量置为零向量 5.向量求负 6.求向量的模 7.向量与标量的乘除法 8.向量标准化 9.向量加减法 10.计算两点（点用向量表示）间距离 11.向量点乘 12.向量叉乘 Vector3.h：#ifndef __VECTOR3_H_INCLUDED__#define __VECTOR3_H_INCLUDED__ #include &lt;math.h&gt; class Vector3{ public: float x, y, z; // 默认构造函数，不执行任何操作 Vector3() { } // 复制构造函数 Vector3(const Vector3 &amp;a) : x(a.x), y(a.y), z(a.z) { } // 带参数的构造函数，用三个值完成初始化 Vector3(float nx, float ny, float nz) : x(nx), y(ny), z(nz) { } // 标准对象操作 // 重载赋值运算符，并返回引用，以实现左值 Vector3 &amp;operator =(const Vector3 &amp;a) { x = a.x; y = a.y; z = a.z; return \\*this; }//重载“==”操作符bool operator ==(const Vector3 &amp;a) const { return x==a.x &amp;&amp; y==a.y &amp;&amp; z==a.z; } bool operator !=(const Vector3 &amp;a) const { return x!=a.x || y!=a.y || z!=a.z; }// 向量运算 // 置为零向量 void zero() { x = y = z = 0.0f; } // 重载一元“-”运算符Vector3 operator -() const { return Vector3(-x,-y,-z); } // 重载二元“+”和“-”运算符 Vector3 operator +(const Vector3 &amp;a) const { return Vector3(x + a.x, y + a.y, z + a.z); } Vector3 operator -(const Vector3 &amp;a) const { return Vector3(x - a.x, y - a.y, z - a.z); } // 与标量的乘法，除法 Vector3 operator \\*(float a) const { return Vector3(x\\* a, y\\* a, z\\* a); } Vector3 operator /(float a) const { float oneOverA = 1.0f / a; // 注意，这里不对除零进行检查 return Vector3(x\\* oneOverA, y\\* oneOverA, z\\* oneOverA); } // 重载自反运算符 Vector3 &amp;operator +=(const Vector3 &amp;a){ x += a.x; y += a.y; z += a.z; return *this;}Vector3 &amp;operator -=(const Vector3 &amp;a){ x -= a.x; y -= a.y; z -= a.z; return *this;}Vector3 &amp;operator *=(float a){ x *= a; y *= a; z *= a; return *this;}Vector3 &amp;operator /=(float a){ float oneOverA = 1.0f / a; x *= oneOverA; y *= oneOverA; z *= oneOverA; return *this;} // 向量标量化void normalize(){ float magSq = x * x + y * y + z * z; if (magSq &gt; 0.0f) { // 检查除零 float oneOverMag = 1.0f / sqrt(magSq); x *= oneOverMag; y *= oneOverMag; z *= oneOverMag; }} //向量点乘，重载标准的乘法运算符float operator *(const Vector3 &amp;a) const { return x* a.x + y* a.y + z* a.z; }}; ///////////////////////////////////////////////////////////////////////////////// 非成员函数///////////////////////////////////////////////////////////////////////////////// 求向量模inline float vectorMag(const Vector3 &amp;a){ return sqrt(a.x * a.x + a.y * a.y + a.z * a.z);} //计算两向量的叉乘（切记不要重载叉乘）inline Vector3 crossProduct(const Vector3 &amp;a, const Vector3 &amp;b){ return Vector3( a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x );} //实现标量左乘inline Vector3 operator *(float k, const Vector3 &amp;v){ return Vector3(k * v.x, k * v.y, k * v.z);} //计算两点之间的距离inline float distance(const Vector3 &amp;a, const Vector3 &amp;b){ float dx = a.x - b.x; float dy = a.y - b.y; float dz = a.z - b.z; return sqrt(dx * dx + dy * dy + dz * dz);} ///////////////////////////////////////////////////////////////////////////////// 全局变量///////////////////////////////////////////////////////////////////////////////// 提供一个全局零向量 extern const Vector3 kZeroVector; #endif 设计细节：1.float与double，类采用了float，是因为float的精度够用。相比于使用double，float可以节省可观的内存资源并且还能获得更好的性能。 2.避免处理标量的函数。例如，您可能认为一个接收标量k并使三个分量都等于k的构造函数会非常有用。但在创建这个很少会用到的函数时，引入了各种突然将标量转换到向量的可能性。 3.有些代码会通过重载数组运算符（[]）或转化成float*来访问分量，但是对于一个应用在几何问题上的向量类，我们一般用名字（x，y，z）访问分量，而不是下标。 4.不要重载叉乘。C语言中，只有“*”表示乘，C语言中也不存在叉号运算符，所以重载运算符并不比直接调用叉乘函数（如：crossProduct()）更“优雅”。 5.应该尽可能的使用const成员函数。const成员函数是一种方法，让函数对调用者承诺“不会修改对象”，而编译器确保这个承诺。这是一个保证代码没有副作用的好方法，不会在任何您不知道的情况下改变对象。 6.使用const引用参数。除了使用const成员函数外，所有以向量为参数的函数都接受向量的const引用（const&amp;）。以传值方式传参会调用一次构造函数，传const引用在形式上是传值，而实际上是传址（传引用），避免了调用构造函数，这有助于提高效率。另外，如果函数不是内联的，传值方式比传址方式需要更多的堆栈空间和更长的参数压栈时间。 当把vector的变量作为实参，传递给接收const引用的函数时，实参的地址被传递。当把vector的表达式作为实参，传递给接受const引用的函数时，编译器产生临时代码来计算表达式，并把结果保存到临时变量中，接着将临时变量的地址传递给函数。这样我们就分别得到了传址与传值的优点。形式上是传值，使我们能够传递相量表达式，让编译器去创建临时变量。实际上传递的还是地址，提高了速度。 7.某些操作被设计成了非成员函数，而不是成员函数。成员函数在类定义中声明，作为类的成员被调用，它包含一个隐式的this指针作为形参。（例如，zero()就是一个成员函数）。非成员函数是不包含隐式this指针的普通函数，（例如，vectorMag()函数）。那些只接收一个vector实参的操作，既可以被设计为成员函数，也可以被设计为非成员函数，此时我们一般使用非成员函数，因为在vector表达式中使用这种操作时，非成员函数更易懂。 非成员函数：求模，向量叉乘，求两点见距离 成员函数(不包括运算符重载)：zero()，normalize，因为我们不会在vector表达式中调用这些函数。 8.不要使用虚函数，原因如下： 第一，“自定义”向量操作没有太大意义。点乘就是点乘，它永远是点乘。 第二，Vector3是一个严格要求速度的类，如果使用了虚函数，优化器通常不能产生成员函数的内联代码。 第三，虚函数需要指向虚函数表的指针，响亮定义时该指针必须被初始化，并使对象大小增加25%。存储包含向量的大数组是一种普遍需求，在这种情况下，虚函数表指针占用的空间大部分被浪费掉了。 9.全局常量：零。它用来向函数传递零向量，使我们不必每次都调用构造函数Vector3（0，0，0）来创建零向量。 10.不存在Point3类。如果决定对点和向量使用不同的类，那么将面临两种选择： 一，提供两个版本的函数，一个接受Vector参数，另一个接收Point3参数； 二，函数仅接收Vector3参数，当Point3类型传到函数时将它转换成Vector3类型(或者是相反的方法) 这两种选择都是不好的。来看下第二个选择，Vector3和Point3之间的转换可以是显示的也可以是隐式的。设想显示转换，这将使得向量和点之间的转换满天飞，而如果是隐式转换(可以定义一个构造函数或转换符)，将可以自由地转换点和向量，但这样将两个类分开的好处就大部分丧失了，不值得这么做。 结论是使用同一个类保存“点”和“向量”。 11.关于优化。如果真要对向量类进行优化，也仅能加速那些本应该用汇编写的代码，但还达不到真正汇编代码的速度。所以，不值得为如此小的回报增加向量类的复杂性。 有两种特别的代码需要仔细讨论。一个是定点数，另一个是返回临时变量的引用。 在旧时代，浮点数运算比整数慢得多。特别明显的是，浮点乘法非常慢。因此程序员使用定点数，企图绕过这个问题。定点数的基本思想就是用定点数保存小数位，例如，有8位小数位，意味着这个数应当乘以256再保存。所以3.25应该存为3.25×256=832。在过去，处理一些特殊场合，定点数是一种优化技术。当今的处理器不仅能以处理整数相同的周期处理浮点数，还会试图以向量处理器来执行浮点向量运算。 我们的向量类的许多向量运算都被写成返回实际的Vector3型变量。不同的编译器能以不同的方法实现这种返回操作。但返回类对象将导致至少一次构造函数调用(根据C++标准)。关于此优化的结论：保持类的简单性，仅在很少的情况下，构造函数或类似的调用会造成明显的问题。可以手动调整C++代码或者使用汇编。当然，也可以让函数接收一个指针参数，返回值存放在那里，而不是真正返回一个对象。不管怎么样，不要为2%的优化付出100%的代码复杂性。 参考书籍：《游戏引擎架构》 《3D Math Primer for graphics and game development》","categories":[],"tags":[{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"}]},{"title":"向量运算","slug":"向量运算","date":"2018-05-07T10:13:12.000Z","updated":"2020-07-05T08:56:51.297Z","comments":false,"path":"2018/05/07/向量运算/","link":"","permalink":"http://yoursite.com/2018/05/07/%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/","excerpt":"","text":"数学中专门研究向量的分支称作线性代数，向量在线性代数中只是一个数组。 向量与点的关系：点有位置，但没有实际的大小或者厚度；向量有大小和方向，但没有位置。点与向量在概念上完全不同，而在数学上却还是等价的。思考位置时，想象一个点，思考位移时，想象一个和向量和一个箭头。 零向量是唯一一个没有方向的向量。但是也不能将零向量认为是一个点，因为零向量没有定义某个位置。应该认为零向量表示的是“没有位移”，就像标量零表示的是“没有数量一样”。 标量与向量的乘法注意点：1.标量与向量相乘时，不需要写乘号，将两个挨着写即表示相乘（常将标量写在左边） 2.乘法和除法优先级高于加法和减法； 3.标量不能除以向量，并且向量不能除以另一个向量； 4.负向量被认为是乘法的特殊情况，乘以标量-1. 几何解释：几何意义上，向量乘以标量k的效果是以|k|缩放向量的长度。 向量的加法和减法：1.向量不能与标量或维数不同的向量相加减； 2.和标量加法一样，向量加法满足交换律，但向量减法不满足交换律。永远有a+b=b+a，但a-b=-(b-a)，仅当a=b时，a-b=b-a 几何解释：向量a和向量b的几何解释为：平移向量，使向量a的头连接b向量的尾，接着从a的尾向b的头画一个向量，这就是向量加法的“三角形法则”。 单位向量（unit vector）单位向量就是大小为1的向量，又称作“标准化向量”或“法线”。 标准化步骤：将向量除以它的大小(模)即可。 [ 几何解释：2D环境中，如果以原点为尾画一个单位向量，那么向量的头将接触到圆心在原点的单位圆(单位圆半径为1 ；在3D环境中，单位向量将触到单位球。 零向量不能被标准化。数学上这是不允许的，因为将导致除零。几何上也没有意义，因为零向量没有方向。 向量的距离公式[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050702-300x132.png) 向量点乘点乘，又称点积（dot product），标量积（scalar product），内积（inner product）； 向量点乘就是对应分量乘积的和，其结果是一个标量： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050703-300x289.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050703.png) 几何解释：点乘结果描述了两个向量的相似程度，点乘结果越大，两向量越相近。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050704-300x266.png) 向量投影[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050707-300x119.png) 向量叉乘叉乘，又称叉积（cross product），矢量积（vector product），外积（outer product） 和点乘不一样，点乘得到一个标量并满足交换律，向量叉乘得到一个向量并且不满足交换律。 两个向量叉乘得到的向量，该向量垂直于原来的两个相乘向量。 叉乘公式： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050705-300x162.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050705.png) 几何解释： [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050706-300x205.png) 如果a，b平行或者任意一个为0，则a与b的叉乘为0 叉乘对0的解释是：他平行于任意其他向量。注意这和点乘的解释不同，点乘的解释是和人以其他的向量垂直。（当然，定义零向量平行或垂直于任意向量都是不对的，因为零向量没有方向） 叉乘最重要的应用就是创建垂直于平面，三角形或多边形的垂直的向量。 参考书籍：《游戏引擎架构》 《3D Math Primer for graphics and game development》","categories":[],"tags":[{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"}]},{"title":"多坐标系","slug":"多坐标系","date":"2018-05-06T06:20:45.000Z","updated":"2020-07-05T08:56:51.295Z","comments":false,"path":"2018/05/06/多坐标系/","link":"","permalink":"http://yoursite.com/2018/05/06/%E5%A4%9A%E5%9D%90%E6%A0%87%E7%B3%BB/","excerpt":"","text":"理论上来说，所有点都能只用一个“世界”坐标系来描述。 但是，对于一个特殊点a，也许不知道他在世界坐标系的位置，但可能知道他在其他坐标系的坐标。 早在两千多年前，坐标系的选择就是讨论的热点了。亚里士多德提出了“地心说”，认为地球才是宇宙的原点。阿里斯塔克斯提出了“日心说”，认为太阳才是宇宙的原点。 转换相对论：没有哪个位置，方向，坐标系能被认为优于另一个。在某种意义上，它是正确的。 《动物庄园》：所有坐标系都是平等的，但某些可能比其他的更合适。 世界坐标系(World Space)原点，也就是世界的（0，0）点，由于某些历史原因被定于赤道与本初子午线的交点，本初子午线就是穿过英国格林威治皇家天文台的经线。 世界坐标系是一个特殊的坐标系，他建立了描述其他坐标系所需要的参考框架。从另一方面说，能够用世界坐标系描述其他坐标系的位置，而不能用更大的，外部的坐标系来描述世界坐标系。 世界坐标系也被称为全局坐标系或者宇宙坐标系。 关于世界坐标系的典型问题都是关于初始化位置和环境的，比如： 1.每个物体的位置和方向； 2.摄像机的位置和方向； 3.世界中的每一点的地形是什么（如山丘，建筑，湖泊等）； 4.各物体从哪里来，到哪里去（NPC的运动策略） 物体坐标系(Object Space)物体坐标系是和特定物体相关联的坐标系。 例如，我们每个人都带着自己的坐标系，如果我告诉您“向前走一步”，是在向您的物体坐标系发指令。 在驾驶时，别人对你说“向左”或“向东“，”向左“是物体坐标系的概念，”向东“则是世界坐标系中的概念。 某些情况下，物体坐标系也称为模型坐标系。因为模型定点的坐标都是在模型坐标系中描述的。 在物体坐标系中可能会遇到的问题，例如： 1.周围有需要相互作用的物体吗？（我要攻击它吗） 2.哪个方向？在我前面吗？我左边一点吗？右边？（我应该向他射击还是转身就跑？） 摄像机坐标系(View Space)摄像机坐标系是和观察者坐标系密切相关的坐标系，摄像机坐标系和屏幕坐标系相似，差别在于摄像机坐标系处于3D空间中而屏幕坐标系在2D空间中。 摄像机坐标系中，摄像机在原点，x轴向右，z轴向前（朝向屏幕内或摄像机方向），y轴向上（不是世界的上方而是摄像机的上方）。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050602.jpg) 关于屏幕坐标系的典型问题是哪些问题应该在屏幕上绘制出来，例如： 1.3D空间中的给定点在摄像机下方吗？ 2.3D空间中的给定点是在屏幕上，还是超出了摄像机平截锥体的左，右，上，下边界？（平截锥体就是摄像机能观察到的金字塔区域） 3.某个物体是否在屏幕上？他的部分在，或全部不在？ 4.两个物体，谁在前面？（该问题称作可见性检测） 惯性坐标系(Intertial Space)为了简化世界坐标系到物体坐标系的转化，人们引入了一种新的坐标系，叫做惯性坐标系。 惯性坐标系的原点和物体坐标系的原点重合，但惯性坐标系的轴平行于世界坐标系的轴。 为什么要引入惯性坐标系呢？ 因为从物体坐标系到惯性坐标系只需旋转，从惯性坐标系到世界坐标系只需要平移。 嵌套式坐标系物体坐标系在世界坐标系中运动，很自然的会想到将世界坐标系看作”父“空间而将物体坐标系看成”子“空间。 羊右耳朵的运动，在世界坐标系是一个很复杂的轨迹，跟中它将是程序员的噩梦。通过把羊打散成嵌套式的，按层次结构组吃的对象序列，这个动作就能很容易独立计算，并通过线性变换工具（如矩阵和向量组合）起来。 若认为羊坐标系相对于世界坐标系运动，羊头坐标系相对于羊坐标系运动，羊耳朵坐标系相对于羊头坐标系运动，这样将会很方便。 层次化的嵌套坐标系是动态的，能够以最方便于表达重要信息的方式进行组织。 坐标系转换利用惯性坐标系作为中介来转换世界和物体坐标系。 用旋转能从物体坐标系转换到惯性坐标系，用平移能从惯性坐标系转换到世界坐标系。 参考书籍：《游戏引擎架构》 《3D Math Primer for graphics and game development》","categories":[],"tags":[{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"}]},{"title":"笛卡尔坐标系统","slug":"笛卡尔坐标系统","date":"2018-05-05T11:17:21.000Z","updated":"2020-07-05T11:18:01.925Z","comments":false,"path":"2018/05/05/笛卡尔坐标系统/","link":"","permalink":"http://yoursite.com/2018/05/05/%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一. 1D数学 很久以前，牧羊人为了“数羊”而产生了自然数，一只羊，两只羊，三只羊……。 当羊非常多时，人们意识到这样数羊不行，于是放弃了计数而是用“很多羊”来代替。 不同的文明在不同点放弃了计数，智者定义了“零”的概念，即没有羊。 人们习惯性的把羊放成一排来计数，这导致了数轴概念的产生。 如果你要要卖你的10羊，而你其实并没有羊，这就产生了债务和负数的概念，你拥有“负十”只羊，这种情况又导致了整数的产生：由自然数和他们的相反数（负数）组成。 贫穷使有的人买不起整只羊，只能买的起四分之一只羊，这就产生了分数。比如2/5，134/1000等，为了方便，人们又发明了小数点表示法，用“3.1415”来代替冗长的31415/10000. 再后来，人们发现某些数字无法用有理数表示，比如π，这就产生了所谓的实数，实数包含有理数和π这样的无理数。 有理数可数，而实数不可数。 研究自然数和整数的领域称为离散数学，研究实数的领域称作连续数学。 也许宇宙中就存在着一个超越我们科技的文明，他们从来没听说连续数学，基本微积分理论，甚至是无限这样的概念，他们从不使用π，而是使用3.14159（或更精确些：3.1415926535897932382626433）就可以构造完美的世界。 为虚拟世界选择度量单位的关键是选择离散的精度，有一种错误的观点认为short，int是离散的，而float，double是连续的，而实际上这些数据都是离散的。 以前的计算机图形学教材通常建议选择整数，因为那时硬件处理浮点数的的能力要比处理整数弱，但对于现在的硬件，这种说法已经过时了。 计算机图形学第一准则：近似原则，如果它看上去是对的那它就是对的 二. 2D笛卡尔数学2D笛卡尔坐标系的两条定义： 1.每个2D笛卡尔坐标系都有一个特殊的点，称坐原点，它是坐标系的中心。 2.每个2D笛卡尔坐标系都有两条过原点的直线向两边无限延伸，称作“轴”（axis）。 所有2D坐标系都是等价的。例如，两个2D坐标系A和B，旋转坐标系A，总能使七x，y轴的指向和B的相同（假设坐标轴互相垂直） 三. 从2D到3D左手坐标系和右手坐标系： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050527.jpg) 3D坐标系之间是不一定等价的。如果同属于左手坐标系或右手坐标系，则可以通过旋转来重合，否则不可以。 左，右手坐标系可以相互转换，最简单的方法是只翻转一个轴的符号。注意如果同时翻转两个轴的符号，结果和不翻转是一样的。 不同领域使用不同的坐标系，传统的计算机图形学使用左手坐标系，而线性代数则倾向于使用右手坐标系。 当三维图形以左手坐标系渲染至二维屏幕时，，z轴坐标增加意味着场景的深度增加（即与虚拟摄像机的距离增加），此特性会应用到z缓冲方案中，以解决深度遮挡。 参考书籍：《游戏引擎架构》 《3D Math Primer for graphics and game development》","categories":[],"tags":[{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"}]},{"title":"CS：数据存储时的字节排列","slug":"cs：数据存储时的字节排列","date":"2018-05-05T07:08:18.000Z","updated":"2020-07-05T08:56:51.290Z","comments":false,"path":"2018/05/05/cs：数据存储时的字节排列/","link":"","permalink":"http://yoursite.com/2018/05/05/cs%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%97%B6%E7%9A%84%E5%AD%97%E8%8A%82%E6%8E%92%E5%88%97/","excerpt":"","text":"数据的存储和排列顺序• 80年代开始，几乎所有通用计算机都采用字节编址 • 在高级语言中声明的基本数据类型有char、short、int、long、long long、float、double、long double等各种不同长度数据 • 一个基本数据可能会占用多个存储单元 – 例如，若int型变量x=-10， x的存放地址为100，其机器数为FFFFFFF6H，占4个单元 -10=-1010B [-10]补=FFFFFFF6H • 需要考虑以下问题： – 变量的地址是其最大地址还是最小地址？ 最小地址，即x存放在100#~103#！ – 多个字节在存储单元中存放的顺序如何？ 大端方式/小端方式 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050523-300x198.png) 检测系统的字节顺序• union的存放顺序是所有成员从低地址开始，利用该特性可测试CPU的大/小端方式。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050524-300x143.jpg) 大端/小端方式举例假定小端方式机器中某条指令的地址为1000 该指令的汇编形式为：mov AX, 0x12345(BX) 其中操作码mov为40H，寄存器AX和BX的编号分别为0001B和0010B，立即数占32位，则存放顺序为： • 以下是一个由反汇编器生成的一行针对IA-32处理器的机器级代码表示文本： 80483d2: 89 85 a0 fe ff ff mov %eax, 0xfffffea0(%ebp) 其中，80483d2是十六进制表示的指令地址 89 85 a0 fe ff ff 是机器指令 mov %eax, 0xfffffea0(%ebp) 是对应的汇编指令 0xfffffea0是立即数 请问：立即数0xfffffea0的值和所存放地址分别是多少？IA-32是大端还是小端方式？ 立即数0xfffffea0所存放的地址为0x80483d4； 立即数0xfffffea0的值为-10110000B=-176； IA-32采用的是小端方式！ 字节交换问题[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050526-300x190.png) 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"CS：数据宽度和存储容量的单位","slug":"cs：数据宽度和存储容量的单位","date":"2018-05-05T06:48:52.000Z","updated":"2020-07-05T08:56:51.288Z","comments":false,"path":"2018/05/05/cs：数据宽度和存储容量的单位/","link":"","permalink":"http://yoursite.com/2018/05/05/cs%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E5%92%8C%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E5%8D%95%E4%BD%8D/","excerpt":"","text":"数据的基本宽度• 比特（bit，位）是计算机中处理、存储、传输信息的最小单位 • 二进制信息最基本的计量单位是“字节”(Byte) – 现代计算机中，存储器按字节编址 – 字节是最小可寻址单位(addressable unit ) – 如果以字节为一个排列单位，则LSB表示最低有效字节，MSB表示最高有效字节 • 除比特（位）和字节外，还经常使用“字”(word) 作为单位 – “字”和“字长”的概念不同 IA-32中的“字”有多少位？16位 字长多少位呢？32位 DWORD ：32位 QWORD：64位 • “字”和“字长”的概念不同 –“字长”指数据通路的宽度。 ”字长”等于CPU内部总线的宽度、运算器的位数、通用寄存器的宽度（这些部件的宽度都是一样的） –“字”表示被处理信息的单位，用来度量数据类型的宽度 –字和字长的宽度可以一样，也可不同 例1：对于x86体系结构，不管字长多少，定义“字”的宽度都为16位，而从386开始字长就是32位了。 例2：对于MIPS 32体系结构，其字和字长都是32位。 数据通路的宽度• 数据通路指CPU内部数据流经的路径以及路径上的部件，主要是CPU内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致，才能相互匹配。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050521-300x148.png) 数据量的度量单位• 存储二进制信息时的度量单位要比字节或字大得多 • 容量经常使用的单位有： – “千字节”(KB)，1KB=210字节=1024B – “兆字节”(MB)，1MB=220字节=1024KB – “千兆字节”(GB)，1GB=230字节=1024MB – “兆兆字节”(TB)，1TB=240字节=1024GB • 通信中的带宽使用的单位有： – “千比特/秒”(kb/s)，1kbps=103 b/s=1000 bps – “兆比特/秒”(Mb/s)，1Mbps=106 b/s =1000 kbps – “千兆比特/秒”(Gb/s)，1Gbps=109 b/s =1000 Mbps – “兆兆比特/秒”(Tb/s)，1Tbps=1012 b/s =1000 Gbps 如果把b换成B，则表示字节而不是比特（位） 例如，10MBps表示10兆字节/秒 程序中数据类型的宽度高级语言支持多种不同类型和不同长度的数据 – 例如，C语言中char类型的宽度为1个字节，可表示一个字符（非数值数据），也可表示 一个8位的整数（数值数据） – 不同机器上表示的同一种类型的数据可能宽度不同 • 必须确定相应的机器级数据表示方式和相应的处理指令 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050522-300x231.png) 从表中看出：同类型数据并不是所有机器都采用相同的宽度，分配的字节数随ISA、机器字长和编译器的不同而不同。 例如，ANSI C标准未规定long double的确切精度，所以对于不同平台有不同的实现。有的是8字节，有的是10字节，有的是12字节或16字节。 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"CS：非数值数据的编码表示","slug":"cs：非数值数据的编码表示","date":"2018-05-05T06:37:23.000Z","updated":"2020-07-05T08:56:51.287Z","comments":false,"path":"2018/05/05/cs：非数值数据的编码表示/","link":"","permalink":"http://yoursite.com/2018/05/05/cs%EF%BC%9A%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"逻辑数据的编码表示• 计算机中何时会用到逻辑数据？ – 表示逻辑（关系）表达式中的逻辑值：真/假 例如，对于关系表达式：(x&gt;0) 并且（y&lt;=0) “x&gt;0”、“y&lt;=0”、“(x&gt;0) 并且(y&lt;=0)”都是逻辑值 • 表示 • 用一位表示。N位二进制数（位串）可表示N个逻辑数据 • 运算 – 按位进行。如，按位与/ 按位或/ 逻辑左移/ 逻辑右移等 • 识别 – 逻辑数据和数值数据在形式上并无差别，也是一串0/1序列，计算机靠指令来识别。 西文字符的编码表示• 特点 – 是一种拼音文字，用有限几个字母可拼写出所有单词 – 只需对有限个字母和数学符号、标点符号等辅助字符编码 – 所有字符总数不超过256个，使用7或8个二进位可表示 • 表示（常用编码为7位ASCII码） – 十进制数字：0/1/2…/9 – 英文字母：A/B/…/Z/a/b/…/z – 专用符号：+/-/%/*/&amp;/…… – 控制字符（不可打印或显示） • 操作 – 字符串操作，如:传送/比较等 汉字及国际字符的编码表示• 汉字特点 – 汉字是表意文字，一个字就是一个方块图形。 – 汉字数量巨大，总数超过6万字，给汉字在计算机内部的表示、汉字的传输与交换、汉字的输入和输出等带来一系列问题。 • 编码形式 – 有以下几种汉字代码： 输入码：对汉字用相应按键进行编码表示，用于输入 内码：用于在系统中进行存储、查找、传送等处理 字模点阵或轮廓描述: 描述汉字字模点阵或轮廓，用于显示/打印汉字及国际字符的编码表示 问题：西文字符有没有输入码？有没有内码？有没有字模点阵或轮廓描述？ 答：西文字符没有输入码，因为它可以直接使用键盘上输入 A,B,C,D，而中文则不能直接输入汉字。汉字需要用西文字母或者数字来对汉字进行编码。 西文字符的内码就是ASCII码，有字模点阵或轮廓描述 GB2312-80字符集• 由三部分组成 ① 字母、数字和各种符号，包括英文、俄文、日文平假名与片假名、罗马字母、汉语拼音等共687个 ② 一级常用汉字，共3755个，按汉语拼音排列 ③ 二级常用汉字，共3008个，不太常用，按偏旁部首排列 • 汉字的区位码 – 码表由94行、94列组成，行号为区号，列号为位号，各占7位 – 指出汉字在码表中的位置，共14位，区号在左、位号在右 • 汉字的国标码 – 每个汉字的区号和位号各自加上32（20H），得到其“国标码” – 国标码中区号和位号各占7位。在计算机内部，为方便处理与存储，前面添一个0，构成一个字节 汉字内码• 至少需2个字节才能表示一个汉字内码。为什么？ –由汉字的总数（超过6万字）决定！ 2的16次方等于65536 • 可在GB2312国标码的基础上产生汉字内码 –为与ASCII码区别，将国标码的两个字节的第一位置“1”后得到一种汉字内码（可以有不同的编码方案） 例：汉字“大”在码表中位于第20行、第83列。因此区位码为0010100 1010011，在区、位码上各加32得到两个字节编码，即**00110100 01110011B=3473H。前面的34H和字符“4”的ACSII码相同，后面的73H和字符“s”的ACSII码相同，但是，将每个字节的最高位各设为“1”后，就得到其内码：B4F3H (1011010011110011B)，因而不会和ASCII码混淆。** 多媒体信息的表示• 图形、图像、音频、视频等信息在机器内部也用0和1表示 – 图形用构建图形的直线或曲线的坐标点及控制点来描述，而这些坐标点或控制点则用数值数据描述 – 图像用构成图像的点（像素）的亮度、颜色或灰度等信息来描述，这些亮度或颜色等值则用数值数据描述 – 音频信息通过对模拟声音进行采样、量化（用二进制编码）来获得，因此量化后得到的是一个数值数据序列（随时间变化） – 视频信息描述的是随时间变化的图像（每一幅图像称为一帧） – 音乐信息（MIDI）通过对演奏的乐器、乐谱等相关的各类信息用0和1进行编码来描述 – ……. 多媒体信息用一个复杂的数据结构来描述，其中的基本数据或者是数值数据，或者是用0/1编码的非数值数据 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"CS：浮点数的编码表示","slug":"cs：浮点数的编码表示","date":"2018-05-05T06:23:56.000Z","updated":"2020-07-05T08:56:51.284Z","comments":false,"path":"2018/05/05/cs：浮点数的编码表示/","link":"","permalink":"http://yoursite.com/2018/05/05/cs%EF%BC%9A%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"C语言支持的基本数据类型float：单精度浮点数，存储长度：32 double ：双精度浮点数，存储长度：64 long double ：扩展精度浮点数，存储长度：80 / 96 科学计数法(Scientific Notation)与浮点数[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050512-300x197.jpg) 浮点数(Floating Point)的表示范围[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050513-300x197.jpg) 浮点数的表示[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050514-300x200.png) IEEE 754 标准现在所有通用计算机都采用IEEE 754来表示浮点数 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050515-300x190.jpg) 机器数转换为真值[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050516-300x191.png) 真值转换为机器数已知float型变量x的值为-12.75，求x的机器数是多少？ -12.75=-1100.11B=-1.10011B x 23(2的3次方)，阶（指数）为3 因此，符号S=1 阶码E=127+3=128+2=1000 0010 显式表示的部分尾数Significant= 100 1100 0000 0000 0000 0000 x 的机器数表示为： 1| 1000 0010 |100 1100 0000 0000 0000 0000 转换为十六进制表示为：C14C0000H 0的机器数表示[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050517-300x189.png) +∞/-∞的机器数表示浮点数除0的结果是+/- ∞, 而不是溢出异常.（整数除0为异常） 为什么要这样处理? • 可以利用+∞/-∞作比较。例如：X/0&gt;Y可作为有效比较 How to represent +∞/-∞? • Exponent : all ones (11111111B = 255) • Significand: all zeros +∞ : 0 11111111 00000000000000000000000 -∞ : 1 11111111 00000000000000000000000 相关操作： 5.0 / 0 = +∞, -5.0 / 0 = -∞ 5+(+∞) = +∞, (+∞)+(+∞) = +∞ 5 - (+∞) = -∞, (-∞) - (+∞) = -∞ etc “非数”的表示Sqrt (- 4.0) = ? 0/0 = ? – 称为Not a Number (NaN) - “非数” How to represent NaN Exponent = 255 Significand: nonzero NaNs 可以帮助调试程序 相关操作： sqrt (-4.0) = NaN， 0/0 = NaN， op (NaN,x) = NaN ，+∞+(-∞) = NaN， +∞- (+∞) = NaN ，∞/∞ = NaN 非规格化数(Denorms)的表示[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050518-300x159.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050518.png) [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050519-300x167.png) 关于浮点数精度的一个例子[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050520-300x185.png) 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"CS：C语言中的整数","slug":"cs：c语言中的整数","date":"2018-05-05T06:04:17.000Z","updated":"2020-07-05T08:56:51.282Z","comments":false,"path":"2018/05/05/cs：c语言中的整数/","link":"","permalink":"http://yoursite.com/2018/05/05/cs%EF%BC%9Ac%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0/","excerpt":"","text":"C语言支持的基本数据类型[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050507-300x192.png) 无符号整数(Unsigned integer)• 机器中字的位排列顺序有两种方式：（例：32位字: 0…010112） – 高到低位从左到右：0000 0000 0000 0000 0000 0000 0000 1011 – 高到低位从右到左：1101 0000 0000 0000 0000 0000 0000 0000 – Leftmost 和rightmost 这两个词有歧义， 故用LSB(LeastSignificant Bit)来表示最低有效位，用MSB来表示最高有效位 – 高位到低位多采用从左往右排列 • 一般在全部是正数运算且不出现负值结果的场合下，可使用无符号数表示。例如，地址运算，编号表示，等等 • 无符号整数的编码中没有符号位 • 能表示的最大值大于位数相同的带符号整数的最大值（Why？） – 例如，8位无符号整数最大是255（1111 1111） 而8位带符号整数最大为127（0111 1111） • 总是整数，所以很多时候就简称为“无符号数” 带符号整数（Signed integer）• 计算机必须能处理正数(positive) 和负数(negative)，用MSB表示数符（0–正数，1–负数） • 有三种定点编码方式 – Signed and magnitude （原码） 定点小数，用来表示浮点数的尾数 – Excess (biased) notion （移码） 定点整数，用于表示浮点数的阶（指数） – Two’s complement （补码） 50年代以来，所有计算机都用补码来表示带符号整数 • 为什么用补码表示带符号整数？ – 补码运算系统是模运算系统，加、减运算统一 – 数0的表示唯一，方便使用 – 比原码多表示一个最小负数 C语言程序中的整数无符号数：unsigned int ( short / long)；带符号整数： int ( short / long) 常在一个数的后面加一个“u”或“U”表示无符号数 若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数 假定以下关系表达式在32位用补码表示的机器上执行，结果是什么？ [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050508-300x147.png) 例如，考虑以下C代码： int x = –1;unsigned u = 2147483648; printf ( “x = %u = %d\\n”, x, x);printf ( “u = %u = %d\\n”, u, u); 在32位机器上运行上述代码时，它的输出结果是什么？为什么？ x = 4294967295 = –1 u = 2147483648 = –2147483648 因为–1的补码整数表示为“11…1”，作为32位无符号数解释时，其值为232–1= 4 294 967 296–1 = 4 294 967 295。 231的无符号数表示为“100…0”，被解释为32位带符号整数时，其值为最小负数：–232-1 = –231 = –2 147 483 648。 编译器处理常量时默认的类型[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050509-300x186.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050509.png) 1）在有些32位系统上，C表达式-2147483648 < 2147483647的执行结果为false。Why？ 2）若定义变量“int i=-2147483648;”，则“i < 2147483647”的执行结果为true。Why？ 3）如果将表达式写成“-2147483647-1 < 2147483647”，则结果会怎样呢？Why？ [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050510-300x113.png) 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"CS：定点数的编码表示","slug":"cs：定点数的编码表示","date":"2018-05-05T05:17:32.000Z","updated":"2020-07-05T08:56:51.278Z","comments":false,"path":"2018/05/05/cs：定点数的编码表示/","link":"","permalink":"http://yoursite.com/2018/05/05/cs%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"原码（Sign and Magnitude）表示[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050501-300x204.png) 补码- 模运算（modular运算）重要概念：在一个模运算系统中，一个数与它除以“模”后的余数等价。 现实世界中的模运算系统，时钟是一种模12系统 假定钟表时针指向10点，要将它拨向6点， 则有两种拨法： ① 倒拨4格：10- 4 = 6 ② 顺拨8格：10+8 = 18 ≡ 6 (mod 12) 模12系统中： 10- 4 ≡ 10+8 (mod 12) - 4 ≡ 8 (mod 12) 则，称8是- 4对模12的补码（即：- 4的模12补码等于8）。 同样有-3 ≡ 9 （mod 12） -5 ≡ 7 （mod 12）等 结论1： 一个负数的补码等于模减该负数的绝对值。 结论2： 对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替。 补码（modular运算）：+ 和– 的统一 补码（2’s comlement）的表示现实世界的模运算系统举例 例1：“钟表”模运算系统 假定时针只能顺拨，从10点倒拨4格后是几点？ 10- 4 = 10+(12- 4) = 10+8 = 6（mod 12） 例2：“4位十进制数” 模运算系统 假定算盘只有四档，且只能做加法，则在算盘上计算9828-1928等于多少？ 9828-1928=9828+(104-1928) =9828+8072 = 1 7900 =7900（mod 104） 取模即只留余数，高位“1”被丢弃！相当于只有低4位留在算盘上。 计算机中的运算器是模运算系统：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050502-300x123.jpg) 求特殊数的补码：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050503-300x143.png) 变形补码（4’s comlement）的表示：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050504-300x200.png) 求真值的补码就比如-9 补码是11110111。 9的源码为00001001，如果是负数的话，补码为最高位置1，其余取反也就是11110110， 然后在最低位加1即可即11110111。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050505-300x181.png) 求补码的真值：理论上的求法： 令：[A]补= an-1an-2…… a1a0 则： A= -an-1.2n-1+an-2 .2n-2+ …… a1 .21+ a0 .20 例如： 补码“11010110”的真值为 -27+26+24+22+2=-128+64+16+4+2=-42 补码“01010110”的真值为 -0.27+26+24+22+2=64+16+4+2=86 简便求法： 符号为0，则为正数，数值部分相同 符号为1，则为负数，数值各位取反，末位加1 例如：补码“01010110”的真值为+1010110=64+16+4+2=86 例如：补码“11010110”的真值为-0101010=-(32+8+2)=-42 移码表示Excess (biased) notion：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050506-300x206.png) 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"CS：数值和编码","slug":"计算机系统：数值和编码","date":"2018-05-05T05:04:07.000Z","updated":"2020-07-05T08:56:51.276Z","comments":false,"path":"2018/05/05/计算机系统：数值和编码/","link":"","permalink":"http://yoursite.com/2018/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%95%B0%E5%80%BC%E5%92%8C%E7%BC%96%E7%A0%81/","excerpt":"","text":"信息的二进制编码:• 机器级数据分两大类 – 数值数据：无符号整数、带符号整数、浮点数（实数） – 非数值数据：逻辑数（包括位串）、西文字符和汉字 • 计算机内部所有信息都用二进制（即：0和1）进行编码 • 用二进制编码的原因 – 制造二个稳定态的物理器件容易(电位高/低，脉冲有/无，正/负极) – 二进制编码、计数、运算规则简单 – 正好与逻辑命题真/假对应，便于逻辑运算 – 可方便地用逻辑电路实现算术运算 • 真值和机器数( 非常重要的概念！) – 机器数：用0和1编码的计算机内部的0/1序列 – 真值：真正的值，即：现实中带正负号的数 例：unsigned short型变量x的真值是127，其机器数是多少？ 127=27-1，其机器数为0000 0000 0111 1111 数值数据的表示• 数值数据表示的三要素 – 进位计数制 – 定、浮点表示 – 如何用二进制编码 即：要确定一个数值数据的值必须先确定这三个要素。 例如，20137564的值是多少？ • 进位计数制 – 十进制、二进制、十六进制、八进制数及其相互转换 • 定/浮点表示（解决小数点问题） – 定点整数、定点小数 – 浮点数（可用一个定点小数和一个定点整数来表示） • 定点数的编码（解决正负号问题） – 原码、补码、反码、移码（反码很少用） R进位计数制日常生活中用十进制表示数值，计算机中用二进制表示所有信息！那为什么还要引入八进制/ 十六进制呢？ 八进制/ 十六进制是二进制的简便表示。便于阅读和书写！ 它们之间对应简单，转换容易。 在机器内部用二进制表示，在屏幕或其他设备上表示时，转换为八进制/十六进制数，可缩短长度。 八进制：Octal （用后缀“O”表示） 十六进制：Hexadecimal （用后缀“H”，或前缀“0x”表示） 后缀“B”表示二进制数，如01011010B 例：1010 1100 0100 0101 0001 0000 1000 1101B可写成 0xac45108d 0xAC45108D 或ac45108dH AC45108DH 或8进制：25421210215O 010 101 100 010 001 010 001 000 010 001 101 现代计算机系统多用十六进制表示机器数 十进制数与R进制数之间的转换(1) R进制数=&gt; 十进制数 按“权”展开 例1: (10101.01)2=1x24+1x 22+1x20+1x2-2=(21.25)10 例2: (307.6)8=3x82+7x80+6x8-1=(199.75)10 例1: (3A. 1)16=3x161+10x160+1x16-1=(58.0625)10 (2)十进制数=&gt; 二进制数，再将二进制转换为16或8进制 整数部分和小数部分分别转换 ① 整数—-“除基取余，上右下左” ② 小数—-“乘基取整，上左下右” 上面这只是理论上的做法 实际上，记住1、2、4、8、16、32、64、128、256、512、1024、2048、4096、8192、16384、32768、65536，…..就可简单进行整数部分的转换记住0.5、0.25、0.125、0.0625、…… 就可简单进行小数部分的转换 十进制数与二进制数之间的转换： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050301-300x206.png)](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050301.png) **十进制数与8进制数之间的转换：** [![](http://www.wjgbaby.com/wp-content/uploads/2018/05/18050302-300x216.png) 定点数和浮点数• 计算机中只有0和1，数值数据中的小数点怎么表示呢？ – 计算机中只能通过约定小数点的位置来表示 • 小数点位置约定在固定位置的数称为定点数 • 小数点位置约定为可浮动的数称为浮点数 • 定点小数用来表示浮点数的尾数部分 • 定点整数用来表示整数，分带符号整数和无符号整数 • 任何实数：X=(-1)s ×M×RE 其中，S取值为0或1，用来决定数X的符号；M是一个二进制定点小数**，称为数X的尾数（mantissa）；E是一个二进制定点整数，称为数X的阶或指数（exponent）；R是基数（radix、base），可以为2、4和16等。计算机中只要表示S、M和E三个信息，就能确定X的值，这**称为浮点数 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux 0.11实验一：环境配置","slug":"linux0-11实验一：环境配置","date":"2018-04-30T08:22:14.000Z","updated":"2020-07-05T08:56:51.270Z","comments":false,"path":"2018/04/30/linux0-11实验一：环境配置/","link":"","permalink":"http://yoursite.com/2018/04/30/linux0-11%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"主要平台和工具简介x86模拟器BochsBochs是一个免费且开放源代码的IA-32(x86)架构PC机模拟器。在它模拟出的环境中可以运行Linux、DOS和各种版本的Windows等多种操作系统。而Bochs本身具有很高的移植性，可以运行在多种软硬件平台之上，这也是我们选择它做为本书的指定模拟器的主要原因。如果您想拥抱自由的Linux，那么Bochs几乎是您的不二选择。如果您想继续把自己绑定在Windows平台上，那么除了Bochs，您还可以选用VMware或者Microsoft Virtual PC。它们是最著名虚拟机软件，而且都可以免费使用。因为Bochs的是模拟器，其原理决定了它的运行效率会低于虚拟机。但对于本书所设计的实验来说，效率上的差别很不明显。而且，Bochs有虚拟机无可比拟的调试操作系统的能力，所以我们更建议您选用Bochs。hit-oslab已经内置了bochs，本书后文假定的缺省环境也是Bochs。 关于Bochs的更详细的介绍请访问它的主页及Bochs使用手册。 GCC编译器GCC是和Linux一起成长起来的编译器。Linux最初的版本就是由GCC编译的。现在GCC也是在自由软件领域应用最广泛的编译器。所以，我们也选择GCC做为本书实验的指定编译器。 DB调试器GDB调试器是GCC编译器的兄弟。做为自由软件领域几乎是唯一的调试器，它秉承了*nix类操作系统的一贯风格，采用纯命令行操作，有点儿类似dos下的debug。关于它的使用方法请看GDB使用手册。 Ubuntu (GNU/Linux)Ubuntu也许不是目前最好用的Linux桌面发行版，但它一定是最流行的。主要特点是易用，非常的易用。 现在，已经有越来越多的人开始用Ubuntu完全代替Windows，享受更加自由、安全、守法的感觉。Ubuntu的主页是http://www.ubuntu.com/ ，这里不仅可以免费下载到iso文件，甚至能免费申领Ubuntu的安装光盘。 我们强烈建议您在Ubuntu下做实验。因为有些实验内容涉及到在自己改进的Linux 0.11下，运行自己编的应用程序。被改进的功能都是高版本Linux内核已经具有的，在其上确认自己编写的应用程序无误后，再用之测试自己改进的Linux 0.11，可以更有信心些。 安装指南安装指南链接，这篇文章比较好，它把十几条配置环境的命令行都整理好集成到了一条命令中，对于新人来说可以不用太在意那些命令行： https://github.com/DeathKing/hit-oslab setup.sh具体操作细节，有兴趣可以去看看： https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/0-prepEnv/%E5%87%86%E5%A4%87%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83.md [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18043001-300x192.png) 使用方法准备活动$ cd ~/oslab把当前目录切换到oslab下，用pwd命令确认，用“ls -l”列目录内容。本实验的所有内容都在本目录或其下级目录内完成。 编译内核“编译内核”比“编写内核”要简单得多。首先要进入linux-0.11目录，然后执行： $ make all因为“all”是最常用的参数，所以可以省略，只用“make”，效果一样。 在多处理器的系统上，可以用-j参数进行并行编译，加快速度。例如双CPU的系统可以： $ make -j 2make命令会显示很多很多很多的信息，你可以尽量去看懂，也可以装作没看见。只要最后几行中没有“error”就说明编译成功。最后生成的目标文件是一个软盘镜像文件——linux-0.11/Image。如果将此镜像文件写到一张1.44MB的软盘上，就可以启动一台真正的计算机。 linux-0.11目录下是全部的源代码，很多实验内容都是要靠修改这些代码来完成。修改后需要重新编译内核，还是执行命令： $ make allmake命令会自动跳过未被修改的文件，链接时直接使用上次编译生成的目标文件，从而节约编译时间。但如果重新编译后，你的修改貌似没有生效，可以试试先“make clean”，再“make all”。“make clean”是删除上一次编译生成的所有中间文件和目标文件，确保是在全新的状态下编译整个工程。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18043002-300x235.jpg) 运行和调试在Bochs中运行最新编译好的内核很简单，在oslab目录下执行： $ ./run如果出现Bochs的窗口，里面显示linux的引导过程，最后停止在“[/usr/root/]#”，表示运行成功。 内核调试分为两种模式：汇编级调试和C语言级调试。 汇编级调试需要执行命令： $ ./dbg-asm可以用命令help来查看调试系统用的基本命令。更详细的信息请查阅Bochs使用手册。 C语言级调试稍微复杂一些。首先执行如下命令： $ ./dbg-c然后再打开一个终端窗口，进入oslab目录后，执行： $ ./rungdb新终端窗口中运行的是GDB调试器。关于gdb调试器请查阅GDB使用手册。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18043003-300x215.jpg) 参考链接： 操作系统原理与实践 课程链接： 操作系统之基础 操作系统之进程与线程 操作系统之内存管理 操作系统之外设与文件系统 所需资源下载： GitHub","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"光照系统之灯光探头组","slug":"光照系统之灯光探头组","date":"2018-04-27T08:49:18.000Z","updated":"2020-07-05T11:22:19.620Z","comments":false,"path":"2018/04/27/光照系统之灯光探头组/","link":"","permalink":"http://yoursite.com/2018/04/27/%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%81%AF%E5%85%89%E6%8E%A2%E5%A4%B4%E7%BB%84/","excerpt":"","text":"在使用Unity 开发移动平台的应用时，为了保障应用的的运行帧率，我们一般将场景中最消耗资源的“实时光”烘焙成“光照贴图”。光照贴图保存了场景中所有的静态物体的光照效果，但是场景中的非静态物体， 比如：游戏角色，NPC，这些能动的角色，它们身上就不会出现光照效果。 那么如何解决这个问题那？？ Unity 为了应对这种情况，推出了一个专门解决该问题的组件： “Light Probe Group”：灯光探头组。 一.灯光探头组 1.使用灯光探头组组件，我们可以在烘焙后的场景中，模拟实时光照状态下的效果。 2.Light –&gt; Light Probe Group 添加组件；点击组件上的Edit 按钮，在正交视图下添加新的“探头”，并调整位置。 3.摆放“探头”要让探头成为一个“体积”，我们的角色在整个空间内移动的时候，无论移动到任何地方，都处于一个“体积”内，也就是说触发4 个探头。 4.在空间内摆放N 个灯光探头，成一个体积状态。然后烘焙光照贴图，在烘焙光照贴图的同时，也会烘焙这些灯光探头，这些探头会记录下当前自己所在位置的灯光信息。 然后当我们的非静态角色模型，进入到探头的范围内，角色模型会自动获取自己周围的探头上记录的光照信息，进行插值运算后，在角色模型身上模拟出真实光照的效果。 探头细节： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042703-300x286.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042703.png) 调整好探头组： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042701-300x158.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042701.jpg) 移动角色物体，注意影子和角色的位置细节： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042702-300x153.png) 二.注意事项 1.区域光组件 Area Light：区域光[组件]。 区域光在“实时光照”模式下是无效的，仅在“烘焙光照”模式下有用。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042705-300x196.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042705.jpg) 2.**模型自发光** 标准着色器上的自发光选项，也是可以让模型成为一个辅助烘焙光源。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042704-300x139.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042704.jpg) 3.注意事项： **①烘焙模式下的自发光物体也需要设置为静态。** ** ②Emission 后的值越大，自发光强度也就越大。** 4.手游场景中，为了美化场景，往往会点缀各种各样的灯光，灯光一旦多了，手游肯定会卡，所以99%的手游目前的场景还都是使用的“烘焙光照”模式。另外不单单是手游，在手机端运行的VR 项目，AR 项目，场景也是需要烘焙的。 很多项目为了体现场景的丰富性，往往会使用灯光探头组，来让这些烘焙过的灯光，对游戏角色产生环境光的影响。 5.在摆放灯光探头组的探头的时候，为了节约资源和性能优化，一般只会将角色能到达的位置，摆放探头，而不会将整个场景全部摆放。 在摆放灯光探头的时候，要注意密度，不要太高，也不要太低。在光源变大比较多，角色经常移动的地方，可以稍微密集一些，否则可以稍微松散一些。 区域光在反射探头作用下最后烘焙的效果： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042706-300x174.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042706.jpg) 变换位置后受其它区域光的效果：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042707-300x173.jpg)","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"计算机系统基础理解","slug":"计算机系统基础理解","date":"2018-04-26T03:06:35.000Z","updated":"2020-07-05T08:56:51.266Z","comments":false,"path":"2018/04/26/计算机系统基础理解/","link":"","permalink":"http://yoursite.com/2018/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3/","excerpt":"","text":"一.冯诺依曼结构的主要思想： 1. 计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。 2. 各基本部件的功能是： • 存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令； • 控制器应能自动取出指令来执行； • 运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算； • 操作人员可以通过输入设备、输出设备和主机进行通信。 3. 内部以二进制表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。 4. 采用“存储程序”工作方式。 二.计算机如何工作: 计算机基本部件： CPU：中央处理器；PC：程序计数器；MAR：存储器地址寄存器 ALU：算术逻辑部件；IR：指令寄存器；MDR：存储器数据寄存器 GPRs：通用寄存器组（由若干通用寄存器组成，早期就是累加器） [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042601-1024x522.png) 先想象一下妈妈是怎样做一桌你喜欢（指定）的菜的？ 厨房-CPU，你妈-控制器，盘-GPRs，锅灶等-ALU ，架子-存储器 做菜前： 原材料（数据）和菜谱（指令）都按序放在厨房外的架子（存储器）上， 每个架子有编号（存储单元地址）。 菜谱上信息：原料位置、做法、做好的菜放在哪里等 例如，把10、11号架上的原料一起炒，并装入3号盘 然后，我告诉妈妈从第5个架上（起始PC=5）指定菜谱开始做 开始做菜： 第一步：从5号架上取菜谱（根据PC取指令） 第二步：看菜谱（指令译码） 第三步：从架上或盘中取原材料（取操作数） 第四步：洗、切、炒等具体操作（指令执行） 第五步：装盘或直接送桌（回写结果） 第六步：算出下一菜谱所在架子号6=5+1（修改PC的值） 继续做下一道菜（执行下一条指令） 三.程序的转换处理过程: //经典的“ hello.c ”C-源程序#include &lt;stdio.h&gt;int main(){ printf(“hello, world\\n”);} hello.c的ASCII文本表示： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042602.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042602.png) 功能：输出“hello,world”，计算机不能直接执行hello.c！ 以下是GCC+Linux平台中的处理过程： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042603.png) 四.C程序实例： 问题一： //ISO C90标准下，在32位系统上,以下C表达式的结果是什么？-2147483648 &lt; 2147483647 //false（与事实不符）！Why? //以下关系表达式结果呢？int i = -2147483648;i &lt; 2147483647 //true！Why? -2147483647-1 &lt; 2147483647//结果怎样？ /*理解该问题需要知道：编译器如何处理字面量；高级语言中运算规则；高级语言与指令之间的对应；机器指令的执行过程；机器级数据的表示和运算；*/ 问题二： sum(int a[ ], unsigned len){ int i，sum = 0; for (i = 0; i &lt;= len–1; i++) sum += a[i]; return sum;}/*当参数len为0时，返回值应该是0，但是在机器上执行时，却发生访存异常。但当len为int型时则正常。Why?访问违例地址为何是0xC0000005?*/ /*理解该问题需要知道：高级语言中运算规则；机器指令的含义和执行；计算机内部的运算电路；异常的检测和处理；虚拟地址空间；*/ 问题三： /*若x和y为int型， 当x=65535时， y=x*x; y的值为多少？y=-131071。Why？现实世界中，x2≥0，但在计算机世界并不一定成立。对于任何int型变量x和y，(x&gt;y) == (-x&lt;-y) 总成立吗？当x=-2147483648，y任意（除-2147483648外）时不成立，Why？在现实世界中成立，但在计算机世界中并不一定成立。*/ 问题四： //main.c:int d=100;int x=200;int main(){ p1( ); printf (“d=%d, x=%d\\n”, d, x ); return 0;}//p1.c:double d;void p1( ){ d=1.0;}/*打印结果是什么？d=0，x=1 072 693 248Why？*/ /*解该问题需要知道：机器级数据的表示；变量的存储空间分配;数据的大端/小端存储方式；链接器的符号解析规则;*/ 问题五： /* 复制数组到堆中，count为数组元素个数*/int copy_array(int *array, int count) { int i; /* 在堆区申请一块内存*/ int *myarray = (int *) malloc(count*sizeof(int)); if (myarray == NULL) return -1; for (i = 0; i &lt; count; i++) myarray[i] = array[i]; return count;}//当count=230+1时，，程序会发生什么情况？ /*当参数count很大时，则count*sizeof(int)会溢出。如count=230+1时，count*sizeof(int)=4。堆（heap）中大量数据被破坏！*/ /*理解该问题需要知道：乘法运算及溢出；虚拟地址空间；存储空间映射;*/ 问题六： //代码段一：int a = 0x80000000;int b = a / -1;printf(“%d\\n”, b);//运行结果为-2147483648 //代码段二：int a = 0x80000000;int b = -1;int c = a / b;printf(“%d\\n”, c);//运行结果为“Floating point exception”，显然CPU检测到了溢出异常 //为什么两者结果不同？ /*objdump反汇编代码,得知除以-1被优化成取负指令neg,故未发生除法溢出；*/ /*a/b用除法指令IDIV实现，但它不生成OF标志，那么如何判断溢出异常的呢？实际上是“除法错”异常#DE（类型0）Linux中，对#DE类型发SIGFPE信号*/ /*理解该问题需要知道：编译器如何优化；机器级数据的表示；机器指令的含义和执行；计算机内部的运算电路；除法错异常的处理*/ 问题七： #include &lt;stdio.h&gt;main(){ double a = 10; printf(“a = %d\\n”, a);} /*在IA-32上运行时，打印结果为a=0在x86-64上运行时，打印出来的a是一个不确定值为什么？*/ /*IEEE 754 的表示；X87 FPU的体系结构；IA-32和x86-64中过程；调用的参数传递；计算机内部的运算电路*/ 问题八： double fun(int i){ volatile double d[1] = {3.14}; volatile long int a[2]; a[i] = 1073741824; /* Possibly out of bounds */ return d[0];}//对于上述C语言函数，i=0~4时，fun(i)分别返回什么值? fun(0)  3.14fun(1)  3.14fun(2)  3.1399998664856fun(3)  2.00000061035156fun(4)  3.14, 然后存储保护错/*理解该问题需要知道：机器级数据的表示；过程调用机制；栈帧中数据的布局*/ 问题九： void copyij (int src[2048][2048], int dst[2048][2048]){ int i,j; for (i = 0; i &lt; 2048; i++) for ( j = 0; j &lt; 2048; j++) dst[i][j] = src[i][j];}void copyji (int src[2048][2048], int dst[2048][2048]){ int i,j; for ( j = 0; j &lt; 2048; j++) for (i = 0; i &lt; 2048; i++) dst[i][j] = src[i][j];} //以上两个程序功能完全一样，算法完全一样，因此，时间和空间复杂度完全一样，执行时间一样吗？//事实是第一段代码比第二段代码快了21倍！ /*理解该问题需要知道：数组的存放方式Cache机制；访问局部性*/ 视频链接： 计算机系统基础(一)：程序的表示，转换与链接 计算机系统基础(二)：程序的执行和存储访问 计算机系统基础(三)：异常、中断和输入/输出","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"牛客网《BAT面试算法精品课》笔记十一：动态规划","slug":"牛客网《bat面试算法精品课》笔记十一：动态规划","date":"2018-04-21T16:34:48.000Z","updated":"2020-07-05T11:19:15.715Z","comments":false,"path":"2018/04/22/牛客网《bat面试算法精品课》笔记十一：动态规划/","link":"","permalink":"http://yoursite.com/2018/04/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。[ 过去的动态规划时间复杂度为O(N*aim*aim) 暴力递归优化为动态规划的过程： 实现暴力递归方法 在暴力搜索方法的函数中看看哪些参数可以代表递归过程。 找到代表递归过程的参数之后，记忆化搜索的方法非常容易实现。 通过分析优化搜索的依赖路径，进而实现动态规划。 根据记忆化搜索方法改出动态规划方法，进而看看是否能化简，如果能化简，还能实现时间复杂度更低的动态规划方法。 动态规划方法的关键点： 最优化原理，也就是最优子结构性质。这指的是一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优化策略的子策略总是最优的，如果一个问题满足最优化原理，就称其具有最优子结构性质。 无后效性。指的是某种状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。 子问题的重叠性。动态规划将原来具有指数级时间复杂度的暴力搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。 案例一： 有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法？ [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042258-300x257.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042258.png) **案例二：** 给定一个矩阵，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字加起来就是路径和，返回所有的路径中最小的路径和。如果给定的m如大家看到的样子，路径1，3，1，0，6，1，0是所有路径中路径和最小的，所以返回12. 1 3 5 9 8 1 3 4 5 0 6 1 8 8 4 0 从左到右计算每行的位置，然后再从上到下计算每一行，到最后最右下角的值就是整个问题的答案了：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042259-300x234.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042259.png) **案例三：** 给定数组arr，返回arr的最长递增子序列长度。比如arr=[2,1,5,3,6,4,8,9,7]，最长递增子序列为[1,3,4,8,9]，所以返回这个子序列的长度5. dp：子序列长度[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042260-300x152.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042260.png) 从arr[0]开始，依次算出dp：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042261-300x172.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042261.png) **案例四：** 给定两个字符串str1和str2，返回两个字符串的最长公共子序列。例如，str1=“1A2C3D4B56”，str2=“B1D23CA45B6A”，“123456”或者“12C4B6”都是最长公共子序列，返回哪一个都行。[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042262-300x256.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042262.png) **案例五：** 一个背包有一定的承重W，有N件物品，每件都有自己的价值，记录在数组V中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042263-300x192.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042263.png) **案例六：** 给定两个字符串str1和str2，再给定三个整数ic,dc,rc，分别代表插入，删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。 比如，str1=“abc”，str2=”adc”，ic=5，dc=3，rc=2。从“abc”编辑成“adc”把‘b’替换成‘d’是代价最小的，所以返回2。 再比如，str1=“abc”，str2=“adc”，ic=5，dc=3，rc=100。从“abc”编辑成“adc”，先删除‘b’，然后插入‘d’是代价最小的，所以返回8.[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042264-300x230.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042264.png) 最终结果返回dp最右下角的值：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042265-300x254.png)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记十：大数据","slug":"牛客网《bat面试算法精品课》笔记十：大数据","date":"2018-04-21T16:24:42.000Z","updated":"2020-07-05T11:19:15.750Z","comments":false,"path":"2018/04/22/牛客网《bat面试算法精品课》笔记十：大数据/","link":"","permalink":"http://yoursite.com/2018/04/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E5%8D%81%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 Map-Reduce和Hadoop逐渐成为面试热门 先介绍下哈希函数：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042232-300x226.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042232.png) 优秀的哈希函数：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042233-300x234.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042233.png) **Map-Reduce：** 1.Map阶段：把大任务分成子任务 2.Reduce阶段：子任务并发处理，然后合并结果 Map-Reduce的难点不在于原理，而在于工程上需要注意的一些问题，比如： 01.备份的考虑，分布式存储的设计细节，以及容灾策略 02.任务分配策略与任务进度跟踪的细节设计，节点状态的呈现 03.多用户权限的控制 用Map-Reduce统计文章中每个单词出现的个数：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042234-300x237.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042234.png) 获得单词文本后，进入map阶段：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042235-300x238.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042235.png) Reduce阶段：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042236-300x253.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042236.png) **常见的海量数据处理技巧：** 01.分而治之，通过哈希函数将大任务分流到机器，或分流成小文件。 02.常用的hashMap或bitmap 难点在于：通讯，时间和空间的估算 **案例一：** 请对十亿个IPV4的ip地址排序，每个ip只会出现一次[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042237-300x130.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042237.png) 更好的方法：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042238-300x199.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042238.png) **案例二：** 请对10亿人的年龄排序 年龄在0到200之间，然后用一个数组对这10亿人的年龄进行计数排序就可以了[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042239-300x223.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042239.png) **案例三：** 有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数，但是内存限制只有2G. 哈希表方法：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042240-300x185.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042240.png) 使用哈希函数进行分流：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042241-300x265.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042241.png) **案例四：** 32位无符号整数的范围是0~4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多10M的内存，只用找到一个没出现过的数即可，该如何找？ 哈希表： 如果用哈希表来记录所有的数，最差情况下，将出现40亿个不同的数。每一条记录占有4字节，大约需要16G内存。不符合内存限制 Bitmap方法： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042242-300x95.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042242.png) Bitmap也不符合内存限制。 正确方法：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042243-300x202.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042243.png) 区间a并未占满，所以a区间上肯定少了某个数，再遍历一次40亿个数，此时只关注a区间上的数，并用bitmap统计区间a上的数的出现情况。需要占用的空间为500M/64，也就是8M. 总结：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042244-300x112.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042244.png) **案例五：** 某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，请设计一种求出每天最热100词的可行办法。 哈希分流：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042245-300x259.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042245.png) **案例六：** [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042246-300x114.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042246.png) 分析：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042247-300x229.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042247.png) 一致性哈希算法：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042248-300x221.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042248.png) 顺时针：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042249-300x266.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042249.png) 添加一个机器m3：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042250-300x183.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042250.png) [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042251-300x183.png)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记九：概率","slug":"牛客网《bat面试算法精品课》笔记九：概率","date":"2018-04-21T16:08:00.000Z","updated":"2020-07-05T11:19:15.711Z","comments":false,"path":"2018/04/22/牛客网《bat面试算法精品课》笔记九：概率/","link":"","permalink":"http://yoursite.com/2018/04/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B9%9D%EF%BC%9A%E6%A6%82%E7%8E%87/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 01.在笔试面试中常作为客观问题出现（选择题） 02.在笔试中往往出现概率，期望的计算 03.往往利用古典概率进行计算（组合数学） 概率的应用： 01.利用随机来改进著名算法（快速排序） 02.随机数发生器（用给定的随机数发生器构造另一个） 案例一. 8支球队，有3个强队，随机把他们分成4组比赛，每组两个队，问两强相遇的概率是多大？ 案例二. 3只蚂蚁从正三角形的三个顶点沿着边移动，速度是相同的，问他们碰头的概率是多少？ 案例三. 某地区重男轻女，一个家庭如果生出一个女孩就一直生，直到生出男孩就停止生育。假设一胎只出生一个孩子，问时间足够长后，男女比例是会变为多少？ 案例四. 给定一个等概率随机产生15的随机函数，除此之外，不能使用任何额外的随机机制，请实现等概率随机产生17的随机函数。 案例五. 给定一个以p概率产生0，以1~p概率产生1的随机函数f()，p是固定的值，但你并不知道是多少。除此之外也不能使用任何额外的随机机制，请用f()实现等概率随机产生0和1的随机函数。 案例六. 解法： 案例七： 给定一个长度为N且没有重复元素的数组arr和一个整数M，实现函数等概率随机打印arr中的M个数。 每次找到一个数就打印，然后就跟数组最后一个没打印的元素交换。一直如此操作，直到打印够M个数. 案例八 举例 解法： 证明： i小于等于k时： i大于k时:","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记八：排列组合","slug":"牛客网《bat面试算法精品课》笔记八：排列组合","date":"2018-04-21T15:58:55.000Z","updated":"2020-07-05T11:19:15.732Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记八：排列组合/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 题目分类： 01.以高中数学为基础的古典概率计算方法 02.斐波那契数和卡特兰数 03.以选择题居多 案例一 在6乘9的方格中，以左上角为起点，右下角为终点，每次只能向下走或者向右走，请问一共有多少种不同的走法。[ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042201-300x71.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042201.png) **案例二** ABCDEFG七人站队，要求A必须站在B的左边，但不要求一定相邻，请问共有多少种排法？第二问如果要求A必须站在B的左边，并且一定要相邻，请问一共有多少种排法？ 问题一：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042202-300x213.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042202.png) 问题二：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042203-300x164.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042203.png) **案例三：** 六个人排成一排，要求甲与乙不相邻，并且甲与丙不相邻的排法数是多少？ 方法一： 甲乙相邻总数：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042204-300x158.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042204.png) 最终结果[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042205-300x197.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042205.png) 方法二：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042206-300x262.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042206.png) **案例四：** 10颗相同的糖果，分给3个人，每人至少一颗，问有多少种分法。[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042207-300x139.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042207.png) **案例五：** 10个不同的球放入3个不同的桶里有多少种方法？[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042208-300x233.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042208.png) **案例六：** 有10颗糖，如果每天至少吃一颗，吃完为止，问有多少种不同的吃法？[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042209-300x218.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042209.png) **案例七：** 假设有n对左右括号，请求出合法的排列有多少个？合法是指每一个括号都可以找到与之配对的括号，比如n=1时，()是合法的，但是)(为不合法[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042210-300x174.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042210.png) [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042211-300x126.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042211.png) [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042212-300x61.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042212.png) 卡特兰数公式：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042213-300x89.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042213.png) **案例八：** N个数进出栈的顺序有哪些？假设栈的容量无限大。再补充一个问题，2n个人排队买票，n个人拿10块钱，票价是5块钱一张，每个人买一张票，售票员手里没有零钱，问有多少种排队方法让售票员可以顺利卖票。 5块钱相当于左括号，10块钱相当于右括号，解法还是和案例七一样 **案例九：** 求n个无差别的节点构成的二叉树有多少种不同的结构？[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042214-300x135.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042214.png) [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042215-300x169.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042215.png) 卡特兰数重要公式2：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042216-300x145.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042216.png) **案例十：** 12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？ [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042217-300x248.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042217.png) **案例十一：** 有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法？[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042218-300x117.png)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记七：位运算","slug":"牛客网《bat面试算法精品课》笔记七：位运算","date":"2018-04-21T15:45:58.000Z","updated":"2020-07-05T11:19:15.750Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记七：位运算/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 算术运算常见操作符：+ - * / % 位运算常见操作符：&amp; | ^ ~ &lt;&lt; &gt;&gt; 位运算的面试题大部分靠平时积累。新题在面试场上较难想出解题思路。 **案例一.[ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042184-300x86.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042184.png)** 普通方法：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042185-300x111.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042185.png) **布隆过滤器方法：** 如果遇到以下这些题，那面试官很可能就是在考察你布隆过滤器的知识： 网页黑名单系统； 垃圾邮件过滤系统； 爬虫的网址判断重复系统； 容忍一定程度的失误率； 对空间要求比较严格； 布隆过滤器可以精确的代表一个集合，可以精确判断某一个元素是否在此集合中，精确程度由用户的具体设计决定，做到100%的精确即正确是不可能的。 布隆过滤器的优势在于，利用很少的空间可以做到精确率较高。 bitarray数组，每个位置占一个bit：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042186-300x243.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042186.png) 布隆过滤器bitarray大小如何确定：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042187-300x237.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042187.png) 真实失误率：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042188-300x155.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042188.png) 生成布隆过滤器的过程总结：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042189-300x252.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042189.png) **案例二.** 如何不用任何额外变量交换两个整数的值？ 给定整数a，整数b 使用额外变量： Int c=a; a=b; b=c; 使用位运算： a=a ^ b; b=a ^ b; a=a ^ b; 不使用位运算和额外变量： a=a+b; b=a-b; a=a-b; **案例三.** 给定两个32位整数a和b，返回a和b中较大的，但是不能用任何比较判断。 方法一.[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042190-300x257.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042190.png) 方法二:[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042191-300x258.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042191.png) **案例四.** 给定一个整形数组arr，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度O(N)，额外空间复杂度O(1) n与0异或结果为n，n与n异或结果为0. eo=0，arr={C,B,D,A,A,B,C} 异或运算满足交换率，异或运算满足结合率。 按照原始arr数出现的顺序异或结果，与该数组异或的结果相同：{A,A,B,B,C,C,D} eo与上述数组异或的结果为：eo=D **案例五. ** 给定一个整形数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，请打印这两个数。要求时间复杂度O(N)，额外空间复杂度O(1) [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042192-300x257.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042192.png) **案例六.** 请设置一种加密过程，完成对明文text的加密和解密工作 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042193-300x126.png)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记六：二叉树","slug":"牛客网《bat面试算法精品课》笔记六：二叉树","date":"2018-04-21T15:35:48.000Z","updated":"2020-07-05T11:19:15.744Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记六：二叉树/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 二叉树节点的结构： 二叉树类型的题目为常考题型： 1.能够结合队列，栈，链表，字符串等很多数据结构 2.需要掌握图的基本遍历方式，比如BFS和DFS 3.需要掌握递归函数的使用，并自己设计出递归过程 4.与实际工作结合紧密 二叉树先序，中序，后序： 常见题型： 案例1. 用递归方式和非递归方式分别实现二叉树的先序，中序和后序的遍历打印 递归先序遍历： 非递归先序遍历： 递归中序遍历： 非递归中序遍历： 递归后序遍历： 非递归后序遍历： 方法一： 方法二： 不管是递归方法还是非递归方法，遍历整棵树的时间复杂度都是O(N)，N为二叉树的节点数，额外空间复杂度为O(L)，L为二叉树的层数。 二叉树按层遍历： 案例2. 定义两个变量： Last：表示正在打印的当前行的最右节点 nlast：表示下一行的最右节点 每一层都做从左到右的宽度优先搜索遍历，当last节点跑到最右边，让last=nlast，nlast继续下一行越来越右。 二叉树的序列化和反序列化： 案例3. 二叉树被记录成文件的过程叫做二叉树的序列化，通过文件内容重建原来二叉树的过程叫做二叉树的反序列化。给定一颗二叉树的头结点head，并已知二叉树节点值的类型为32位整型。请设计一种二叉树序列化和反序列化的方案，并用代码实现。 先序遍历对二叉树进行序列化： 为什么要在一个节点值的后面非要加上一个叹号或者其它的特殊字符来表示一个字符的结束呢？因为如果不标记，最后产生的结果可能会有歧义，比如： 一棵二叉树先序遍历得到的结果，如何进行反序列化： 01.可以看到我们用什么样的方式序列化，就用什么样的方式反序列化。 02.一棵树序列化的结果是唯一的，唯一的结果生成的二叉树也是唯一的 按层遍历的方式对二叉树进行序列化： 01.用队列来进行二叉树的按层遍历，即宽度优先遍历 02.除了访问节点的顺序是按层遍历之外，对结果字符串的处理。与之前介绍的处理方式一样 03.反序列化过程同理 二叉树的子树： 平衡二叉树(AVL)： 第3棵树的2号节点的高度差超过了1，所以第三棵树不是平衡二叉树 案例4. 给定一颗二叉树的头结点head，判断这棵树是否是平衡二叉树。 首先，如果左子树不是平衡二叉树，返回false；如果左子树是的，继续往下执行，如果右子树不是平衡二叉树，返回false。如果左子树和右子树都是平衡二叉树，那么就看LH和RH的差值的绝对值是否大于1. 搜索二叉树（BST）： 搜索二叉树又叫二叉查找树，二叉排序树 案例5. 给定一棵二叉树的头结点head，请判断这颗树是否是搜索二叉树 满二叉树和完全二叉树： 满二叉树： 完全二叉树： 案例6. 给定一棵二叉树的头节点head，判断一棵树是否是完全二叉树 在面试中，二叉树结点类型仅包括：数据项，左孩子，右孩子 在工程中，往往多一条指向父节点的指针 一般默认面试中的二叉树节点结构不包含指向父节点的指针，除非特别说明。 后继节点与前驱结点： 案例7. 普通方法： 最优解法： 如果node节点和node后继节点之间的实际距离为L，最优解法只用走过L个节点，时间复杂度位O(L)，额外空间复杂度O(1) 案例8. 所有折痕的结构是一颗满二叉树： 案例9. 一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点。 案例10. 解题思路： 步骤： 案例11. 思路： 步骤：","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记五：二分搜索","slug":"牛客网《bat面试算法精品课》笔记五：二分搜索","date":"2018-04-21T15:11:04.000Z","updated":"2020-07-05T11:19:15.715Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记五：二分搜索/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 二分搜索常见应用场景： 1.在有序序列中查找一个数，时间复杂度O(logN) 2.并不一定在有序序列中才能得到应用 二分搜索常见考察点： 1.对于边界条件的考察以及代码实现的能力 2.二分搜索题目变化很多 01.给定处理或查找的对象不同 02.判断条件不同 03.要求返回的内容不同 二分搜索的重要提醒： Mid=(left+right)/2，获取中间值经常这样写，但是要注意当right很大的时候，(left+right)会溢出，所以更安全的写法是mid=left+(right-left)/2 常见题型： 案例1. [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042139-300x121.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042139.png) 本题依然可以用二分搜索来实现，时间复杂度为O(logN)，此题说明了二分搜索并不一定要在有序才能进行[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042140-300x207.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042140.png) **案例2.** 给定一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。 Num=3，全局变量res=-1，res记录最后找到3的位置 1 2 3 3 3 3 4 4 4 4 4 4 4 4 4 1 2 3 3 3 3 4 1 2 3 3 **案例3.** 给定一个有序循环数组arr，返回arr中的最小值。有序循环数组是指，有序数组左边任意长度的部分放到右边去，右边的部分拿到左边来。比如数组[1,2,3,3,4]，是有序循环数组，[4，1，2，3，3]也是。 如果arr[L]=arr[R]，arr[L]>arr[M]，说明最小值在L到M的范围上[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042142-300x146.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042142.png) 如果arr[L]>=arr[R]，arr[M]>arr[R]，说明最小值在M到R的范围上 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042143-300x140.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042143.png) 如果arr[L]>=arr[R]，arr[L]","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记四：链表","slug":"牛客网《bat面试算法精品课》笔记四：链表","date":"2018-04-21T15:01:40.000Z","updated":"2020-07-05T11:19:15.727Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记四：链表/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9A%E9%93%BE%E8%A1%A8/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 1.链表问题算法难度不高，但考察代码实现能力 2.链表和数组都是一种线性结构 01数组是一段连续的存储空间 02链表空间不一定保证连续，为临时分配的 链表分类： 1按连接方向分类：单链表，双链表 2.按照有环无环分类：普通链表，循环链表 链表问题代码实现关键点： 01.链表调整函数的返回值类型，根据要求往往是节点类型 02.处理链表过程中，先采用画图的方式理清逻辑 03.链表问题对于边界条件讨论要求严格 关于链表插入和删除的注意事项 01.特殊处理链表为空，或者链表长度为1的情况 02.注意插入操作的调整过程 03.注意删除操作的调整过程 04.注意点：头尾结点及空节点需要特殊考虑 05.双链表的插入与删除和单链表类似，但是需要额外考虑previous指针的指向 单链表的翻转操作： 01.当链表为空或者长度为1时，特殊处理 单链表的翻转 注意点： 1.大量链表问题可以使用额外数据结构来简化调整过程 2.但链表问题最优解往往是不使用额外数据结构的方法 常见题型： 案例1： 给定一个整数num，如何在节点值有序地环形链表中插入一个节点值为num的节点，并且保证这个环形单链表依然有序。 时间按复杂度O(N)，额外空间复杂度O(1) 如果没地方插入，说明这个节点的值要么最大，要么最小 案例2. 给定一个链表中的节点node，但不给定整个链表的头结点。如何在链表中删除node？实现这个函数，要求时间复杂度为O(1)。 将节点2的值变成节点3的值，删除节点3 当要删除节点3时，这种方法就不行了，可以直接将3节点的值变为null 该删除方式并不是删除了该删除的节点，而是进行了值的拷贝 01.结构复杂拷贝操作受限时，不可行 02.在工程上会影响外部依赖 案例3. 给定一个链表的头结点head，再给定一个数num，请把链表调整成节点值小于num的节点都放在链表的左边，值等于num的节点都放在链表的中间，值大于num的节点，都放在链表的右边。 简单做法： 将链表的所有节点放入数组中，然后将数组进行快排划分的调整过程，然后将数组中的节点依次重新串连。 最优解是不需要任何的额外空间，只需要在遍历链表的时候把小于num的，等于num的，大于num的节点分别做成3个链表，最后连接起来就行了，比较考验代码实现能力。 案例4. 给定两个有序链表的有节点head1和head2，打印两个有序链表的公共部分 如果两个链表有一个为空，直接返回即可 如果都不为空，则C1,C2开始比较，刚开始c1为1，c2为2，c1&lt;c2，c1往下移，c1为3，c1&gt;c2，c2往下移，c2为3，c1=c2，输出3，继续执行….. 案例5. 如果链表为空，或者长度为1，或k&lt;2，链表不用进行调整 方法一：时间复杂度O(N)，额外空间复杂度O(K) K个元素依次进栈，最后不够k个不进去 方法二：时间复杂度O(N)，额外空间复杂度O(1) 方法二与方法一类似，依然是每收集k个元素就做逆序，只是不用栈了 案例6. 给定一个单链表的头结点head，链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。 链表：7-&gt;1-&gt;3-&gt;1- &gt;null 案例7. 判断一个链表是否为回文结构 例如： 链表1-&gt;2-&gt;3-&gt;2-&gt;1，是回文结构，返回true 链表1-&gt;2-&gt;3-&gt;1不是回文结构，返回false 方法一：时间复杂度O(N)，使用了N个额外空间 申请一个栈结构，入栈，然后出栈的时候与原来的链表比较，如果每一个节点值都与链表对应的值相等，那么返回true，否则返回false 方法二：时间复杂度O(N)，使用了N/2个额外空间 一个快指针每次走两步，一个慢指针每次走一步，满指针遍历时将遍历过的指针压入栈中，快指针走完的时候，慢指针会来到中间的位置，同时从栈顶到栈底的顺序其实是左部分的逆序，此时如果链表长度为奇数，就不把中间的节点压入栈中。 接下来慢指针继续遍历，栈也开始同步弹出节点，而且此时对比慢节点值和栈弹出节点的值是否相等，如果每一步都相等，那么返回true。 整个的算法相当于把链表的左半部分折过来与链表比较。 方法三：时间复杂度O(N)，额外空间复杂度O(1) 将右半部分链表翻转，然后依次首尾比较 案例8. 一个链表结构中，每个节点不仅含有一条指向下一个节点的next指针，同时含有一个rand指针，rand指针可能指向任何一个链表中的节点，请复制这种含有rand指针节点的链表。 案例9. 如何判断一个单链表是否有环？有环的话返回进入环的第一个节点，无环的话返回空。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1). 普通解法利用哈利表来实现 最优解额外空间复杂度O(1)的方法： 快指针每次走两步，慢指针每次走一步，如果链表无环，快指针发现null后立即返回 如果链表有环，那么快指针和慢指针将在环中的某个位置相遇，在相遇的时刻，让快指针从头节点开始重新遍历，此时快指针每次走一步，满指针在环中也每次都走一步。当快指针和满指针再次相遇的时刻，相遇到的那个节点就是进入环的第一个节点。 案例10. 如何判断两个无环单链表是否相交？相交的话返回第一个相交的节点，不相交的话返回空，如果两个链表长度分别为N和M，请做到时间复杂度O(N+M)，额外空间复杂度O(1) 普通方法用哈希表来实现 最优解是遍历两个链表，统计他们的长度，比如一个链表长度100，一个50，我们让长度为100的链表先走50步，接下来两个链表再一起往下走，如果链表相交的话，那么他们在共同走的过程中一定会到达第一个相交的结点，如果一直到最后都没有相交，返回空 案例11. 如何判断两个有环单链表是否相交？相交的话返回第一个相交的节点，不相交的话返回空，如果两个链表长度分别为N和M，请做到时间复杂度O(N+M)，额外空间复杂度O(1) 入环节点是同一个节点情况1： 入环节点是同一个节点情况2： 入环节点不是同一个节点 案例12. 给定两个单链表的头结点head1和head2，如何判断两个链表是否相交？相交的话返回第一个相交的节点，不相交的话返回空。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记三：队列和栈","slug":"牛客网《bat面试算法精品课》笔记三：队列和栈","date":"2018-04-21T14:40:36.000Z","updated":"2020-07-05T11:19:15.703Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记三：队列和栈/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 队列和栈的基本性质 1.栈是先进后出的 2.队列是先进先出的 3.栈和队列在实现结构上可以有数组和链表两种形式 01.数组结构实现比较容易 02.用链表结构比较复杂，因为牵扯很多指针操作 栈结构基本操作 1.pop操作，栈顶弹出1个元素 2.top或peek操作，访问栈顶元素但不弹出 3.push操作，栈顶压入一个元素 4.size操作，返回栈中元素个数 队列的基本操作： 与栈操作不同的是，push操作为在队头加入元素，而pop操作是从队列尾部弹出一个元素。栈和队列的基本操作，都是时间复杂度为O(1)的操作。 双端队列结构在首尾都可以压入和弹出元素； 优先级队列会根据元素的优先级值，决定元素的弹出顺序。 优先级队列的结构为堆结构，并不是线性结构。 深度优先遍历(DFS)可以用栈来实现： 1进去，2进去，4进去,4是最深的节点要出去，4出去，5进去，5出去，(4，5都已经访问过)所以2出去，3进去，6进去，6出去，7进去，7出去，3出去，1出去。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042103-300x244.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042103.png) **宽度优先遍历可以用队列实现：** 1进去，1出去，把1的两个子节点2和3依次进去，2出去，把2的两个子节点4和5依次放进去，3出去，把3的两个子节点6和7依次放进去，然后4 5 6 7 依次出去。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042104-300x252.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042104.png) **注意点：** ** 平时使用的递归函数实际上用到了提供的函数系统栈，递归的过程可以看做递归函数依次进入函数栈的处理过程。所以用递归函数实现的功能一定可以用非递归的方式实现。** 常见题型： **案例1.** 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作getmin. 要求： 01.pop，push，getMin操作时间复杂度都是O(1) 02.设计的栈类型可以使用现成的栈结构 方法一： 序列：1 2 1 5 4 3 依次进栈StackData，StackMin进栈规则是小于等于栈顶元素才能进去 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042105-300x284.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042105.png) 方法二; 将方法一中不压入那一步变为压入栈顶元素而已 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042106-300x237.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042106.png) 01.方法一和方法二都是利用第二个栈StackMin来保存每一步的最小值。 02.方法一和方法二所实现的所有操作，时间按复杂度都为O(1) 03.区别在于方法一稍省空间，略费时间；方法二稍费空间，略省时间 **案例2.** 编写一个类，只能用两个栈结构实现队列，支持队列的基本操作(add,poll,peek) 方法：两个栈，一个压入栈StackPush，一个弹出栈StackPop，将StackPush中的数据导入到StackPop中，顺序就变过来了。 例如序列：5 4 3 2 1 入栈StackPush： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042107-300x264.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042107.png) 倒过来：入栈StackPop [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042108.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042108.png) 然后弹出，顺序就像队列一样了：5 4 3 2 1 两个重要的注意点： 01.如果StackPush要往StackPop中倒入数据，那么必须把StackPush中的所有数据一次性倒完 02.如果StackPop中有数据，则不能发生倒数据的行为。 **案例3.** 实现一个栈的逆序，但是只能用递归函数和这个栈本身的操作来实现，而不能自己申请另外的数据结构。 第一步：实现get方法 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042109-300x292.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042109.png) 第二步：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042110-293x300.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042110.png) 第三步： 第二步后会发现栈空了，直接返回3，而不把3放回栈中 第三层返回了3，3跑到第二层，2入栈，3跑到第一层，1入栈，最后结果为3 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042111-300x283.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042111.png) get方法为，把栈底元素删除并返回的功能。 以下下代码为，把栈中元素逆序的主方法 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042112-300x246.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042112.png) 结果： [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042113-300x289.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042113.png) **案例4.** 一个栈中元素类型为整数，现在想将该栈从顶到底从大到小排序，只许申请一个栈，除此之外可以申请新的变量，但不能申请额外的数据结构。如何完成排序。 例子：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042114-300x233.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042114.png) 将想要排序的栈记作stack，辅助栈记作help，在stack执行pop操作，弹出的元素记为cur。如果cur小于或等于help当前的栈顶元素，则将cur直接压入help中； 如果cur大于help的栈顶元素，则将help元素逐渐弹出，并且重新押回stack中，直到cur小于等于help的栈顶元素，然后将cur押入到help中。 一直执行上面的操作，直到stack全部元素都到了help，最后将help中的元素再押回stack中就完成排序了。 **案例5.** 有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，，第二个窗口[3,5,4]的最大值为5，第三个窗口的最大值[5,4,3]的最大值为5，第四个窗口[4,3,3]的最大值为4，我五个窗口[3,3,6]的最大值为6，第六个窗口[3,6,7]的最大值为7.所以最终返回[5,5,5,4,6,7]。 普通解法的时间复杂度O(N*W)，也就是每次对每一个窗口遍历其中的w个数。 本体最优解可以做到时间复杂度O(N) [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042115-300x199.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042115.png) 如果qmax队头的下标等于i-w，弹出qmax当前队头下标。Res[1]:[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042116-300x237.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042116.png) 最终结果：[![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042117-300x231.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042117.png) 上面过程中，每个下标值最多进qmax一次，出qmax一次 **案例6.** 给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数。要求数组长度为N，则时间复杂度为O(N)，额外空间复杂度为O(N)。MaxTree的概念如下： 01.MaxTree是一颗二叉树，数组的每一个值对应一个二叉树结点 02.包括MaxTree树在内且在其中的每一颗子树上，值最大的节点都是树的头。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042118-300x279.png)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042118.png) 每个树的父节点是他左边第一个比它大的数和他右边比他第一个大的数中较小的一个，如果这个数是最大的数，那就是整棵树的头结点 该方法的正确性： 01.该方法可以生成一棵树，而不是森林 02.生成的这一棵树是二叉树，而不是多叉树，任何一个数在单独一侧，孩子的数量都不超过一个 [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18042119-300x258.png) 3进去，1进去，得到1往左第一个比他大的数为3，然后1出去，2进去，得到2往左第一个比他大的数为3","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记二：字符串","slug":"牛客网《bat面试算法精品课》笔记二：字符串","date":"2018-04-21T14:19:26.000Z","updated":"2020-07-05T11:19:15.703Z","comments":false,"path":"2018/04/21/牛客网《bat面试算法精品课》笔记二：字符串/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 字符串面试题的特点： 1.广泛性 01.字符串可以看做字符类型的数组与数组排序，查找，调整有关 02.很多其他类型的面试题可以看做字符串类型的面试题 2.需掌握的概念 回文，子串(连续)，子序列(不连续)，前缀树(Trie树)，后缀树和后缀数组，匹配，字典序 3.需掌握的操作 01.与数组有关的操作：增删改查 02.字符的替换 03字符串的旋转 字符串题目的常见类型： 1.规则判断 01.判断字符串是否符合整数规则 02.判断字符串是否符合浮点数规则 03判断字符串是否符合回文字符串规则……等等许多规则 2.数字运算 Int和long类型表达整数范围有限，所以经常用字符串实现大整数，与大整数相关的加减乘除操作，需要模拟笔算的过程 3.与数组操作有关的类型 01.数组有关的调整，排序等操作需要掌握 02.快速排序的划分过程需要掌握和改写 4.字符计数 01.哈希表 02.固定长度的数组V/C++(256长度)，JAVA(65536长度) 03.滑动窗口问题，寻找无重复字符子串问题，计算变位词问题 5.动态规划类型 01.最长公共字串 02.最长公共子序列 03.最长回文子串 04.最长回文子序列……等 6.搜索类型 01宽度优先搜索 02深度优先搜索 7高级算法和数据结构解决的问题 01.Manacher算法解决最长回文子串问题 02.KMP算法解决字符串匹配问题 03.前缀树结构 04.后缀树和后缀数组 字符串相关题型： 案例1. 这道题表面上看起来是二叉树的题目，实际上是字符串的题目 [ 普通解法为二叉树遍历+匹配问题，考察t1中每个节点为头的子树是否与t2一致，时间复杂度为O(N*M)，N代表t1节点数，M代表t2节点数。 . 求出以str中每个字符结尾的情况下，最长无重复字符子串的长度，并在其中找出最大值返回。思路：由于这个题目只要给出最长不重复子串的长度，所以代码比较简单。第一思路就是利用哈希表来进行操作。用字符当做键值，字符在串中的位置当做实值。用pre变量记录字符第一次出现的位置，最大长度max就是利用当前位置减去pre就是当前最大长度了。 class Solution {public: int lengthOfLongestSubstring(string s) { map&lt;char, int&gt; mp; for (int i=0; i&lt;s.length(); i++) mp[s[i]] = -1;//初始化哈希表 int pre = -1, Max = 0; for (int i=0; i&lt;s.length(); i++){ pre = max(pre, mp[s[i]]); Max = max(Max, i-pre); mp[s[i]] = i; } return Max; }};","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"牛客网《BAT面试算法精品课》笔记一：排序","slug":"牛客《bat面试算法精品课》笔记一：排序","date":"2018-04-21T14:08:28.000Z","updated":"2020-07-05T11:19:15.703Z","comments":false,"path":"2018/04/21/牛客《bat面试算法精品课》笔记一：排序/","link":"","permalink":"http://yoursite.com/2018/04/21/%E7%89%9B%E5%AE%A2%E3%80%8Abat%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%B2%BE%E5%93%81%E8%AF%BE%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E6%8E%92%E5%BA%8F/","excerpt":"","text":"牛客网《BAT面试算法精品课》视频链接：《BAT面试算法精品课》 笔记链接： 牛客网《BAT面试算法精品课》笔记一：排序 牛客网《BAT面试算法精品课》笔记二：字符串 牛客网《BAT面试算法精品课》笔记三：队列和栈 牛客网《BAT面试算法精品课》笔记四：链表 牛客网《BAT面试算法精品课》笔记五：二分搜索 牛客网《BAT面试算法精品课》笔记六：二叉树 牛客网《BAT面试算法精品课》笔记七：位运算 牛客网《BAT面试算法精品课》笔记八：排列组合 牛客网《BAT面试算法精品课》笔记九：概率 牛客网《BAT面试算法精品课》笔记十：大数据 牛客网《BAT面试算法精品课》笔记十一：动态规划 经典排序算法对比： [ **稳定性：** ，思想来自桶排序 数组：7 9 3 4 2 1 8 首先遍历数组，找到最小值min=1，最大值max=9。一共7个数，所以把【1，9】分为7个等量区间，每一个区间分别对应一个桶，每个数根据区间选择进桶，我们把最大值单独放在n+1号桶中。数组有n个元素，桶有n+1个，所以一定有空桶。空桶两边的值的相差就是最大差值。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"CPU优化之降低DrawCall","slug":"cpu优化之降低drawcall","date":"2018-04-07T19:42:50.000Z","updated":"2020-07-05T08:56:51.234Z","comments":false,"path":"2018/04/08/cpu优化之降低drawcall/","link":"","permalink":"http://yoursite.com/2018/04/08/cpu%E4%BC%98%E5%8C%96%E4%B9%8B%E9%99%8D%E4%BD%8Edrawcall/","excerpt":"","text":"在优化DrawCall之前我们先来看一下GPU和Cpu之间的流水线是如何实现的 DrawCall简介 问题一：CPU和GPU是如何实现并进行工作的？ 如果没有流水线化，那CPU就必须要等到GPU完成上一个渲染任务才能继续发送渲染命令。但这种方法显然效率低下。因此我们就需要GPU和CPU可以同时工作，而解决方案就是使用一个缓冲区。缓冲区里包含了一个命令队列，由CPU添加命令GPU从中读取命令，添加和读取的过程是相互独立的。命令缓冲区的命令有很多种，而DrawCall只是其中一种，其他命令还有改变渲染状态等 问题二：为什么DrawCall多了会影响帧率 我们先举一个例子，创建10000个文件，每个文件的大小为1kb，然后把它们从一个路径复制到另一个路径，你会发现这些文件总的大小不超过10mb但却要花费很长的时间，现在我们再创建一个单独的文件大小为10mb，然后也把他从一个路径复制到另一个路径你会发现这次所用的时间却是很少。这个原因在于每一个复制动作需要很多额外的操作，比如分配内存，创建各种元数据等。从某种层面上讲渲染的以上实验很类似。在每次调用DrawCall之前，CPU都要向GPU发送很多内容，包括数据状态和命令等。在这一阶段CPU需要完成很多工作，当CPU完成这些工作后GPU就可以开始本次的渲染，GPU的渲染能力是很强的，渲染200或者2000个三角玩网格通常是没有区别的，因此渲染速度往往快于CPU的提交命令的速度。如果DrawCall的数量太多，CPU就会话费大量的时间在提交DrawCall上，造成CPU过载 问题三：如何减少DrawCall 减少DrawCall的方法有很多，我们这里仅讨论使用批处理的方法。批处理的思想就是把很多小的DrawCall合并为一个大的DrawCall。需要注意的是由于我们是需要在CPU的内存中合并网格，而合并的过程是需要消耗时间的，因此批处理技术更加适合于那些静态的物体，例如不会移动的物体。当然我没也可以对动态的物体进行处理，但是由于这些物体是不断运动的，因此每一帧都要进行合并再发送给GPU，这对空间和时间都会造成一定的影响 降低Draw Call的方法则主要是减少所渲染物体的材质种类，并通过Draw Call Batching来减少其数量。 但是，需要注意的是，游戏性能并非Draw Call越小越好。这是因为，决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。 Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。 批处理(Batching) 静态批处理Static batching： 静态批处理允许游戏引擎尽可能多的去降低绘制任意大小的物体所产生的DrawCall，它会占用更多的内存资源和更少的CPU资源，因为它需要额外的内存资源来存储合并后的几何结构，如果在静态批处理之前，如果有几个对象共享相同的几何结构，那么将为每个对象创建一个几何图形，无论是在编辑器还是在运行时。这看起来是个艰难的选择，你需要在内存性能和渲染性能间做出最为正确的选择。在内部，静态批处理是通过将静态对象转换为世界空间，并为它们构建一个大的顶点+索引缓冲区。然后，在同一批中，一系列的“便宜”画调用，一系列的“便宜”，几乎没有任何状态变化之间的。所以在技术上它并不保存“三维的调用”，但它可以节省它们之间的状态变化（这是昂贵的部分）。使用静态批处理非常简单啦，只要勾选物体的Static选项即可！ [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040802-300x259.jpg) 动态批处理Dynamic batching: 如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。 动态批处理操作是自动完成的，并不需要你进行额外的操作。 1.批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。 2.如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。 3.请注意：属性数量的限制可能会在将来进行改变。 4.不要使用缩放尺度（scale）。分别拥有缩放尺度(1,1,1)和(2,2,2)的两个物体将不会进行批处理。 5.统一缩放尺度的物体不会与非统一缩放尺度的物体进行批处理。 使用缩放尺度(1,1,1)和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1)和(1,3,1)的两个物体将可以进行批处理。 6.使用不同材质的实例化物体（instance）将会导致批处理失败。 7.拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。 8.多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。 9.预设体的实例会自动地使用相同的网格模型和材质。 UGUI批处理： 在 UGUI 中，Batch是以Canvas为单位的，即在同一个Canvas下的UI元素最终都会被Batch到同一个Mesh中。而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。而Batch的操作只会在UI元素发生变化时才进行，且合成的Mesh越大，操作的耗时也就越大。 因此，建议尽可能把频繁变化（位置，颜色，长宽等）的UI元素从复杂的Canvas中分离出来，从而避免复杂的Canvas频繁重建。 粒子系统批处理： 关于粒子系统拼合，是指引擎会将若干个材质相同且深度相同的粒子系统在渲染前进行合批（Batch），从而通过一个Draw Call来对其粒子系统进行渲染，进而降低粒子系统的渲染开销。 补充：粒子系统的Draw Call动态拼合与半透明物体的动态拼合机制相当（粒子基本都是半透明材质）。而对半透明物体，由于其渲染顺序的限制（必须从后向前渲染，以保证渲染结果的正确性），动态拼合只能对渲染顺序相邻且材质相同的物体有效。而在决定半透明物体的渲染顺序时，Unity首先会按Shader中的RenderQueue进行排序；其次（相同RenderQueue时），会根据每个半透明物件到屏幕的距离，距离大的优先渲染。 因此，需要尽可能地将相同材质的粒子系统放在比较接近的深度下，才能更多地使动态拼合生效。但通常由于相机的运动、粒子系统的分散分布等原因造成粒子系统之间的穿插，能够动态拼合的数量往往都是很少的，所以我们在粒子系统模块看到的开销分布通常类似该图，主要都是未拼合粒子系统造成。 经过验证，Unity 5.3.5 版本中恢复了对粒子系统的动态合批功能（可尝试添加多个默认的粒子系统，观察Batches的数量变化）。 Mesh批处理： 默认情况下，带蒙皮的Mesh（Skinned Mesh Renderer）是不支持动态合批的。如果场景中相同材质的蒙皮网格数量很多，可以考虑通过插件MeshBaker来进行合并，具体方法可以参考这个链接好插件让你事半功倍！","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"OpenGL渲染管线","slug":"opengl渲染管线","date":"2018-04-07T17:58:37.000Z","updated":"2020-07-05T08:56:51.230Z","comments":false,"path":"2018/04/08/opengl渲染管线/","link":"","permalink":"http://yoursite.com/2018/04/08/opengl%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","excerpt":"","text":"在OpenGL中任何事物都在3D空间中，但是屏幕和窗口是一个2D像素阵列，所以OpenGL的大部分工作都是关于如何把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线完成的。图像渲染管线可以被划分为两个主要部分：第一个部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。 渲染管线接收一组3D坐标，然后把它们转变为你屏幕上的有色2D像素。渲染管线可以被划分为几个阶段，每个阶段需要把前一阶段的输出作为输入。所有这些阶段都是高度专门化的，它们能简单地并行执行。由于它们的并行执行的特征，当今大多数显卡都有成千上万的小处理核心GPU，在GPU上为每一个阶段运行各自的小程序，从而在图形输送管道中快速处理你的数据。这些小程序叫做着色器。有些着色器允许开发者自己配置，用我们自己写的_着色器_替换默认存在的。这样我们就可以更细致地控制渲染管线的特定部分，因为它们运行在GPU上，所以它们也会节约宝贵的CPU时间。着色器是用_OpenGL着色器语言_（OpenGL Shading Language）_GLSL_写成的。 下图显示了渲染管线中各个阶段主要完成的工作，蓝色部分代表的是我们可以定义自己的着色器。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040801.gif) 在上图中，我们以数组的形式传递3个3D坐标作为渲染管线的输入，用它来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；这里顶点数据是几个顶点的集合。每个顶点是用顶点属性（vertex attributes）表示的，它可以包含任何我们希望用的数据，下面我们来看看渲染管线中各个阶段主要完成的工作： 1.渲染管线的第一个部分是顶点着色器（vertex shader），它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（投影坐标），同时顶点着色器允许我们对顶点属性进行一些基本处理。 2.图元组装（primitive assembly）阶段把顶点着色器的表示为基本图形的所有顶点作为输入，把所有点组装为特定的基本图形的形状；上图中是一个三角形。 3.图元组装阶段的输出会传递给几何着色器（geometry shader）。几何着色器把基本图形形成的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其他的）基本图形来生成其他形状。 4.细分着色器（tessellation shaders）拥有把给定基本图形细分为更多小基本图形的能力。这样我们就能在物体更接近玩家的时候通过创建更多的三角形的方式创建出更加平滑的视觉效果。 5.细分着色器的输出会进入光栅化（rasterization）阶段，这里它会把基本图形映射为屏幕上相应的像素，生成供像素着色器（fragment shader）使用的fragment（OpenGL中的一个fragment是OpenGL渲染一个独立像素所需的所有数据。）。在像素着色器运行之前，会执行裁切（clipping）。裁切会丢弃超出你的视图以外的那些像素，来提升执行效率。 6.像素着色器的主要目的是计算一个像素的最终颜色，这也是OpenGL高级效果产生的地方。通常，像素着色器包含用来计算像素最终颜色的3D场景的一些数据（比如光照、阴影、光的颜色等等）。 7.在所有相应颜色值确定以后，最终它会传到另一个阶段，我们叫做alpha测试和混合（blending）阶段。这个阶段检测像素的相应的深度（和stencil）值，使用这些来检查这个像素是否在另一个物体的前面或后面，如此做到相应取舍。这个阶段也会查看alpha值（alpha值是一个物体的透明度值）和物体之间的混合（blend）。所以即使在像素着色器中计算出来了一个像素所输出的颜色，最后的像素颜色在渲染多个三角形的时候也可能完全不同。 虽然渲染管线有多个阶段，每个阶段都需要对应的着色器，但其实对于大多数场合，我们必须做的只是顶点和像素着色器，几何着色器和细分着色器是可选的，通常使用默认的着色器就行了。现在的OpenGL中，我们必须定义至少一个顶点着色器和一个像素着色器（因为GPU中没有默认的顶点/像素着色器）。","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"Unity渲染统计窗口属性总结","slug":"unity渲染统计窗口属性总结","date":"2018-04-07T11:10:11.000Z","updated":"2020-07-05T08:56:51.228Z","comments":false,"path":"2018/04/07/unity渲染统计窗口属性总结/","link":"","permalink":"http://yoursite.com/2018/04/07/unity%E6%B8%B2%E6%9F%93%E7%BB%9F%E8%AE%A1%E7%AA%97%E5%8F%A3%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"Unity提供了一个Statistics窗口，全称叫做 _Rendering Statistics Window_，即渲染统计窗口（或渲染数据统计窗口）,窗口中罗列出关于声音、图像、网络状况等多种统计信息。 FPS(Time per frame andFPS): frames per seconds表示引擎处理和渲染一个游戏帧所花费的时间,该数字主要受到场景中渲染物体数量和 GPU性能的影响，FPS数值越高，游戏场景的动画显示会更加平滑和流畅。一般来说，超过30FPS的画面人眼不会感觉到卡，由于视觉残留的特性，光在视网膜上停止总用后人眼还会保持1/24秒左右的时间，因此游戏画面每秒帧数至少要保证在30以上。另外，Unity中的FPS数值仅包括此游戏Scene里更新和渲染的帧，编辑器中绘制的Scene和其它监视窗口的进程不包括在内。 CPU: 获取到当前占用CPU进行计算的时间绝对值，或时间点，如果Unity主进程处于挂断或休眠状态时，CPU time将会保持不变。 Render thread: GPU渲染线程处理图像所花费的时间，具体数值由GPU性能来决定 Batches: 即Batched Draw Calls,是Unity内置的Draw Call Batching技术。 对于含有多个不同Shader和Material的物体，渲染的过程比较耗时，因为会产生多个Batches。每次对物体的材质或者贴图进行修改，都会影响Batches里数据集的构成。因此，如果场景中有大量材质不同的物体，会很明显的影响到GPU的渲染效率。 Saved by batching: 渲染的批处理数量，这是引擎将多个对象的绘制进行合并从而减少GPU的开销; Verts：摄像机视野(field of view)内渲染的顶点总数。 Tris: ** 摄像机视野(field of view)内渲染的的三角面总数量。 、 关于Tris和Verts,突然想到一些问题，这里需要多嘴说几句： Camera的渲染性能受到Draw calls的影响。之前说过，对一个物体进行渲染，会生成相应的Draw call，处理一个Draw Call的时间是由它上边的Tris和Verts数目决定。尽可能得合并物体，会很大程度的提高性能。举个很简单例子，比如场景一种有1000个不同的物体，每个物体都有10个Tris；场景二中有10个不同的物体，每个物体有1000个Tris。在渲染处理中，场景一中会产生1000个Draw Calls，它的渲染时间明显比场景二慢。 **Unity stats 视图中的 Tris 和 Verts 并不仅仅是视锥中的梯形内的 Tris 和 Verts，而是Camera中 field of view所有取值下的tris和verts，换句话说，哪怕你在当前game视图中看不到这个 cube，如果当你把 field of view调大到 179 过程中都看不到这个cube，stats面板才不会统计，GPU才不会渲染，否则都会渲染，而且unity不会把模型拆分，这个模型哪怕只有1个顶点需要渲染，unity也会把整个模型都渲出来。（参考自Mess的《Unity Camera组件部分参数详解》） 新建一个空的场景，里边没有添加任何物体，为什么Status面板上显示有1.7k Tris以及5.0kVerts。这是因为空的场景自带默认的天空盒。点击Windows—Lighting打开Lighting下的Scene面板，把Skybox里的材质设为空，删掉它，你就会发现Tris 和 Verts 都变为0了。 SetPass calls： 在Unity 4.x和3.x原来的Stats面板的第一项是“Draw calls”，然而到了Unity5.X版本，Stats上没有了“Draw calls”，却多出来一项”SetPass calls“。 比如说场景中有100个gameobject,它们拥有完全一样的Material,那么这100个物体很可能会被Unity里的Batching机制结合成一个Batch。所以用“Batches”来描述Unity的渲染性能是不太合适的，它只能反映出场景中需要批处理物体的数量。那么可否用“Draw calls”来描述呢？答案同样是不适合。每一个“Draw calls”是CPU发送个GPU的一个渲染请求，请求中包括渲染对象所有的顶点参数、三角面、索引值、图元个数等，这个请求并不会占用过多的消耗，真正消耗渲染资源的是在GPU得到请求指令后，把指令发送给对应物体的Shader,让Shader读取指令并通知相应的渲染通道（Pass）进行渲染操作。 假设场景中有1个gameobject，希望能显示很酷炫的效果，它的Material上带有许多特定的Shader。为了实现相应的效果，Shader里或许会包含很多的Pass,每当GPU即将去运行一个Pass之前，就会产生一个“SetPass call”，因此在描述渲染性能开销上，“SetPass calls”更加有说服力。 Shadow casters： 表示场景中有多少个可以投射阴影的物体，一般这些物体都作为场景中的光源。 visible skinned meshed： 渲染皮肤网格的数量。 Animations：正在播放动画的数量","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"单链表反转的四种方法","slug":"单链表反转的四种方法","date":"2018-04-07T07:38:31.000Z","updated":"2020-07-05T11:17:23.960Z","comments":false,"path":"2018/04/07/单链表反转的四种方法/","link":"","permalink":"http://yoursite.com/2018/04/07/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"如何把一个单链表进行反转？ 方法1：将单链表储存为数组，然后按照数组的索引逆序进行反转。 方法2：使用3个指针遍历单链表，逐个链接点进行反转。 方法3：从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，最后将第一个节点挪到新表的表尾。 方法4: 递归(相信我们都熟悉的一点是，对于树的大部分问题，基本可以考虑用递归来解决。但是我们不太熟悉的一点是，对于单链表的一些问题，也可以使用递归。可以认为单链表是一颗永远只有左(右)子树的树，因此可以考虑用递归来解决。或者说，因为单链表本身的结构也有自相似的特点，所以可以考虑用递归来解决) 方法1： 浪费空间。 方法2: 使用p和q两个指针配合工作，使得两个节点间的指向反向，同时用r记录剩下的链表。 p = head; q = head-&gt;next; [ ](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040701.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040701.jpg)head->next = NULL; [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040702.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040702.jpg)现在进入循环体，这是第一次循环。 r = q->next; q->next = p; [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040703.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040703.jpg)p = q; q =r; [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040704.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040704.jpg)第二次循环。 r = q->next [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040705.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040705.jpg)q->next = p; [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040706.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040706.jpg)p = q; [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040707.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040707.jpg)q = r [![](http://www.wjgbaby.com/wp-content/uploads/2018/04/18040708.jpg) 第三次循环。。。。。 具体代码如下: ActList* ReverseList2(ActList* head){ //ActList* temp=new ActList; if(NULL==head|| NULL==head-&gt;next) return head; //少于两个节点没有反转的必要。 ActList* p; ActList* q; ActList* r; p = head; q = head-&gt;next; head-&gt;next = NULL; //旧的头指针是新的尾指针，next需要指向NULL while(q){ r = q-&gt;next; //先保留下一个step要处理的指针 q-&gt;next = p; //然后p q交替工作进行反向 p = q; q = r; } head=p; // 最后q必然指向NULL，所以返回了p作为新的头指针 return head;} 如果觉得上面的先成环再断环的过程不太好理解，那么可以考虑下面这个办法，增加一个中间变量，使用三个变量来实现。 struct ListNode{ int val; ListNode* next; ListNode(int a):val(a),next(NULL){}};ListNode* reverseLinkedList3(ListNode* head){ if(head==NULL||head-&gt;next==NULL) return head; ListNode* p=head; //指向head ListNode* r=head-&gt;next; //指向待搬运的节点，即依次指向从第2个节点到最后一个节点的所有节点 ListNode* m=NULL; //充当搬运工作用的节点 ListNode* tail=head-&gt;next; while(r!=NULL){ //bug2 循环语句写错了, while写成了if m=r; r=r-&gt;next; m-&gt;next=p-&gt;next; p-&gt;next=m; //if(r!=NULL) //std::cout&lt;&lt;”m=”&lt;val&lt;&lt;” ,p=”&lt;val&lt;&lt;” ,r=”&lt;val&lt;&lt;std::endl; //else //std::cout&lt;&lt;”m=”&lt;val&lt;&lt;” ,p=”&lt;val&lt;&lt;” ,r=NULL”&lt;&lt;std::endl; } head=p-&gt;next; tail-&gt;next=p; p-&gt;next=NULL; tail=p; return head; // bug1 忘记了return } 方法3 还是先看图，[ 从图上观察，方法是：对于一条链表，从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，(N-1 次这样的操作结束之后将第1个节点挪到新表的表尾即可。 代码如下: ActList* ReverseList3(ActList* head){ ActList* p; ActList* q; p=head-&gt;next; while(p-&gt;next!=NULL){ q=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=head-&gt;next; head-&gt;next=q; } p-&gt;next=head;//相当于成环 head=p-&gt;next-&gt;next;//新head变为原head的next p-&gt;next-&gt;next=NULL;//断掉环 return head; } 附: 完整的链表创建，显示，反转代码: //创建:用q指向当前链表的最后一个节点；用p指向即将插入的新节点。//反向:用p和q反转工作，r记录链表中剩下的还未反转的部分。 #include “stdafx.h”#include using namespace std; struct ActList{ char ActName[20]; char Director[20]; int Mtime; ActList *next;}; ActList* head; ActList* Create(){//start of CREATE() ActList* p=NULL; ActList* q=NULL; head=NULL; int Time; cout&lt;&lt;”Please input the length of the movie.”&lt;&lt;endl; cin&gt;&gt;Time; while(Time!=0){ p=new ActList; //类似表达: TreeNode* node = new TreeNode;//Noice that [new] should be written out. p-&gt;Mtime=Time; cout&lt;&lt;”Please input the name of the movie.”&lt;&lt;endl; cin&gt;&gt;p-&gt;ActName; cout&lt;&lt;”Please input the Director of the movie.”&lt;&lt;endl; cin&gt;&gt;p-&gt;Director; if(head==NULL) { head=p; } else { q-&gt;next=p; } q=p; cout&lt;&lt;&quot;Please input the length of the movie.&quot;&lt;&lt;endl; cin&gt;&gt;Time; } if(head!=NULL) q-&gt;next=NULL; return head; }//end of CREATE() void DisplayList(ActList* head){//start of display cout&lt;&lt;”show the list of programs.”&lt;&lt;endl; while(head!=NULL) { cout&lt;Mtime&lt;&lt;”\\t”&lt;ActName&lt;&lt;”\\t”&lt;Director&lt;&lt;”\\t”&lt;&lt;endl; head=head-&gt;next; }}//end of display ActList* ReverseList2(ActList* head){ //ActList* temp=new ActList; if(NULL==head|| NULL==head-&gt;next) return head; ActList* p; ActList* q; ActList* r; p = head; q = head-&gt;next; head-&gt;next = NULL; while(q){ r = q-&gt;next; // q-&gt;next = p; p = q; // q = r; // } head=p; return head;} ActList* ReverseList3(ActList* head){ ActList* p; ActList* q; p=head-&gt;next; while(p-&gt;next!=NULL){ q=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=head-&gt;next; head-&gt;next=q; } p-&gt;next=head;//相当于成环 head=p-&gt;next-&gt;next;//新head变为原head的next p-&gt;next-&gt;next=NULL;//断掉环 return head; }int main(int argc, char* argv[]){// DisplayList(Create());// DisplayList(ReverseList2(Create())); DisplayList(ReverseList3(Create())); return 0;} 方法4: 递归 因为发现大部分问题都可以从递归角度想想，所以这道题目也从递归角度想了想。 现在需要把A-&gt;B-&gt;C-&gt;D进行反转， 可以先假设B-&gt;C-&gt;D已经反转好，已经成为了D-&gt;C-&gt;B,那么接下来要做的事情就是将D-&gt;C-&gt;B看成一个整体，让这个整体的next指向A，所以问题转化了反转B-&gt;C-&gt;D。那么， 可以先假设C-&gt;D已经反转好，已经成为了D-&gt;C,那么接下来要做的事情就是将D-&gt;C看成一个整体，让这个整体的next指向B，所以问题转化了反转C-&gt;D。那么， 可以先假设D(其实是D-&gt;NULL)已经反转好，已经成为了D(其实是head-&gt;D),那么接下来要做的事情就是将D(其实是head-&gt;D)看成一个整体，让这个整体的next指向C，所以问题转化了反转D。 上面这个过程就是递归的过程，这其中最麻烦的问题是，如果保留新链表的head指针呢？想到了两个办法。 // 递归版的第一种实现，借助类的成员变量m_phead来表示新链表的头指针。struct ListNode{ int val; ListNode* next; ListNode(int a):val(a),next(NULL){}}; class Solution{ ListNode* reverseLinkedList4(ListNode* head){ //输入: 旧链表的头指针 if(head==NULL) return NULL; if(head-&gt;next==NULL){ m_phead=head; return head; } ListNode* new_tail=reverseLinkedList4(head-&gt;next); new_tail-&gt;next=head; head-&gt;next=NULL; return head; //输出: 新链表的尾指针 } ListNode* m_phead=NULL;//member variable defined for reverseLinkedList4(ListNode* head)}; 第二个办法是，增加一个引用型参数 new_head，它用来保存新链表的头指针。 struct ListNode{ int val; ListNode* next; ListNode(int a):val(a),next(NULL){}}; class Solution{ ListNode* reverseLinkedList5(ListNode* head, ListNode* &amp; new_head){ //输入参数head为旧链表的头指针。new_head为新链表的头指针。 if(head==NULL) return NULL; if(head-&gt;next==NULL){ new_head=head; //当处理到了旧链表的尾指针，也就是新链表的头指针时，对new_head进行赋值。因为是引用型参数，所以在接下来调用中new_head的值逐层传递下去。 return head; } ListNode* new_tail=reverseLinkedList5(head-&gt;next,new_head); new_tail-&gt;next=head; head-&gt;next=NULL; return head; //输出参数head为新链表的尾指针。 }};","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"大数据处理之Bitmap","slug":"大数据处理之bitmap","date":"2018-04-04T18:34:43.000Z","updated":"2020-07-05T11:17:11.503Z","comments":false,"path":"2018/04/05/大数据处理之bitmap/","link":"","permalink":"http://yoursite.com/2018/04/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8Bbitmap/","excerpt":"","text":"MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念”Map（映射）”和”Reduce（归约）” Bit-map空间压缩和快速排序去重 1. Bit-map的基本思想 32位机器上，对于一个整型数，比如int a=1 在内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的32bit位对应存储十进制的0-31个数，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。 Bitmap在用户群做交集和并集运算的时候也有极大的便利。 2. Bit-map应用之快速排序 假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0， 对应位设置为1: 遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。 优点： 运算效率高，不需要进行比较和移位； 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 缺点： 所有的数据不能重复。即不可对重复的数据进行排序和查找。 3. Bit-map应用之快速去重 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间几十兆左右。 接下来的任务就是遍历一次这2.5亿个数字，如果对应的状态位为00，则将其变为01；如果对应的状态位为01，则将其变为11；如果为11，,对应的转态位保持不变。 最后，我们将状态位为01的进行统计，就得到了不重复的数字个数，时间复杂度为O(n)。 4. Bit-map应用之快速查询 同样，我们利用Bit-map也可以进行快速查询，这种情况下对于一个数字只需要一个bit位就可以了，0表示不存在，1表示存在。假设上述的题目改为，如何快速判断一个数字是够存在于上述的2.5亿个数字集合中。 同之前一样，首先我们先对所有的数字进行一次遍历，然后将相应的转态位改为1。遍历完以后就是查询，由于我们的Bit-map采取的是连续存储（整型数组形式，一个数组元素对应32bits），我们实际上是采用了一种分桶的思想。一个数组元素可以存储32个状态位，那将待查询的数字除以32，定位到对应的数组元素（桶），然后再求余（%32），就可以定位到相应的状态位。如果为1，则代表改数字存在；否则，该数字不存在。 5. Bit-map扩展——Bloom Filter(布隆过滤器) 当一个元素被加入集合中时,通过k各散列函数将这个元素映射成一个位数组中的k个点,并将这k个点全部置为1. 有一定的误判率–在判断一个元素是否属于某个集合时,有可能会把不属于这个集合的元素误判为属于这个集合.因此,它不适合那些”零误判”的应用场合.在能容忍低误判的应用场景下,布隆过滤器通过极少的误判换区了存储空间的极大节省. Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素x，第i个哈希函数映射的位置hi(x)就会被置为1（1≤i≤k）。注：如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。 在判断y是否属于这个集合时，对y应用k次哈希函数，若所有hi(y)的位置都是1（1≤i≤k），就认为y是集合中的元素，否则就认为y不是集合中的元素。 6. 总结 使用Bit-map的思想，我们可以将存储空间进行压缩，而且可以对数字进行快速排序、去重和查询的操作。Bloom Fliter是Bit-map思想的一种扩展，它可以在允许低错误率的场景下，大大地进行空间压缩，是一种拿错误率换取空间的数据结构。 7. 应用 适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下 基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码 扩展：bloom filter可以看做是对bit-map的扩展 问题实例： 1、已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。 8位最多99 999 999，大概需要99m个bit，大概10几M字节的内存即可。 2、在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。 方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存232*2bit=1GB 然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 参考链接： https://blog.csdn.net/billcyj/article/details/78948977 https://blog.csdn.net/lyle2000w/article/details/7599144","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"字符串匹配的KMP算法","slug":"字符串匹配的kmp算法","date":"2018-04-04T18:12:30.000Z","updated":"2020-07-05T11:19:15.744Z","comments":false,"path":"2018/04/05/字符串匹配的kmp算法/","link":"","permalink":"http://yoursite.com/2018/04/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84kmp%E7%AE%97%E6%B3%95/","excerpt":"","text":"字符串匹配是计算机的基本任务之一。 举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？ 许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。 KMP算法解释： 1.首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。 2.因为B与A不匹配，搜索词再往后移。 3.就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。 4.接着比较字符串和搜索词的下一个字符，还是相同。 5.直到字符串有一个字符，与搜索词对应的字符不相同为止。 6.这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。 7.一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 8.怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。 9.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 因为 6 - 2 等于4，所以将搜索词向后移动4位。 10.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。 11.因为空格与A不匹配，继续后移一位。 12.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。 13.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。 14.下面介绍《部分匹配表》是如何产生的。 首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 15.”部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， － “A”的前缀和后缀都为空集，共有元素的长度为0； － “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； － “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； － “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； － “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； － “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； － “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 16.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 参考链接： http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"GAD《论道》Unity手游性能优化","slug":"gad《论道》unity手游性能优化","date":"2018-03-30T10:15:50.000Z","updated":"2020-07-05T08:56:51.218Z","comments":false,"path":"2018/03/30/gad《论道》unity手游性能优化/","link":"","permalink":"http://yoursite.com/2018/03/30/gad%E3%80%8A%E8%AE%BA%E9%81%93%E3%80%8Bunity%E6%89%8B%E6%B8%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"视频链接：http://gameinstitute.qq.com/lundao/detail/10000136 视频提供了大致的方向，但是细节需要自己再专门去研究，以下截图来源于视频 一.内存优化1. 内存分布：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032905-300x219.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032905.jpg) 2. 资源优化：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032906-300x194.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032906.jpg) 3. Native占用：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032907-300x194.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032907.jpg) 4. AssetBundle资源： 自动打包： [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032908-300x186.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032908.jpg) 手动打包：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032917-300x172.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032917.jpg) 5. Mono堆优化：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032909-300x182.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032909.jpg) 6. 其它优化：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032910-300x255.jpg) 二.CPU优化 削峰填谷[ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032911-300x184.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032911.jpg) 2. 开源[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032912-300x210.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032912.jpg) 3. 节流[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032913-300x233.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032913.jpg)4.模块合理占用CPU的比例 [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032914-300x180.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032914.jpg)5. UI动静分离[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032915-300x176.jpg) 三. 性能监控 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032916-300x295.jpg)","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"光照系统之烘焙光照","slug":"光照系统之烘焙光照","date":"2018-03-30T08:32:10.000Z","updated":"2020-07-05T11:22:19.628Z","comments":false,"path":"2018/03/30/光照系统之烘焙光照/","link":"","permalink":"http://yoursite.com/2018/03/30/%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%83%98%E7%84%99%E5%85%89%E7%85%A7/","excerpt":"","text":"一.烘焙光照 1.烘焙光照全称为Baked GI（烘焙全局光照）； 烘焙光照的特点是将场景中的光源信息事先烘焙为“光照贴图”，用这些贴图存储光照，然后引擎会自动的将这些“光照贴图”与场景模型相匹配，烘焙完光照贴图后，在游戏运行过程中场景内的灯光是不会真正的参与实时运算的。 烘焙光照相对于实时光照，对硬件的性能要求较低，这种光照方式比较适合手机等移动设备平台（灯光组件的实时运算，是特别消耗硬件性能的）。 2.烘焙相关步骤 ①Lighting 面板选择要使用的光照系统模式，并取消Auto Generate选择状态。 ②所有参与烘焙的光源，自身的灯光组件中的Baking 选项要设置为Baked。默认是Realtime，这个Baking 根据当前场景的要使用的光照系统的模式进行选择和设置。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033006-300x199.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033006.png) ③**所有参与烘焙的场景模型物体，自身要设置为Static**，设置完毕后，这些物体就变成了静态物体，场景运行后，是无法改变它们的位置的。因为只有静态的模型，才能参与烘焙渲染，烘焙渲染是要生成光照贴图的。生成的光照贴图和场景模型一一对应的。贴图是固定的，如果你的模型是非静态的，就表示模型可以移动，模型动了的话，光照贴图就偏了。为了避免这样的情况，Unity 引擎只允许静态的模型参与光照烘焙过程。 ④完成了前面的操作，**就可以点击Lighting 面板下方的“Generate Lighting”按钮**，进行光照贴图的烘焙生成。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033005-203x300.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033005.png) **光照贴图**：存储了场景中的灯光信息，“Build”完毕后，会以资源的形式出现在项目工程目录中，和当前场景处于同一目录，且生成一个该场景同名的文件夹，存储相关光照贴图。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033007-300x211.png) 二.烘焙光照参数优化 1.Lightmap Resolution [重点调整参数] 烘焙分辨率：其实就是生成的光照贴图的分辨率。值越大，效果越好，体积也就越大，烘焙时间也就越长，反之亦然。 这个参数是最最影响烘焙时间的。 一般在开发阶段，不要设置太高，否则需要很长的时间来渲染光照贴图。阶段测试，最终发布的时候，设置高一点，渲染一个最佳的效果即可。 2.Lightmap Padding [默认即可] 烘焙间距：控制烘焙出来的光照贴图，贴图元素信息之间的间距。 无实际意义，保持默认的2 即可。 3.Compress Lightmaps [默认即可] 压缩：对烘焙的贴图进行压缩，压缩比例大约是3~5 倍。意义重大，保持默认的勾选状态。 4.Ambient Occlusion [根据实际情况选择是否开启] AO 贴图效果：作用和标准着色器里面的AO 贴图类似，都是用于优化模型的阴影和转角部分。 5.Lightmap Size [默认即可] 图集尺寸：单张光照贴图的最大尺寸。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033008-256x300.png)","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"光照系统之实时光照","slug":"光照系统之实时光照gi","date":"2018-03-30T06:53:38.000Z","updated":"2020-07-05T11:22:19.617Z","comments":false,"path":"2018/03/30/光照系统之实时光照gi/","link":"","permalink":"http://yoursite.com/2018/03/30/%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%9E%E6%97%B6%E5%85%89%E7%85%A7gi/","excerpt":"","text":"一.光照系统两种类型 光照系统根据使用场合不同，设置不同，运行设备不同，又分为两种光照类型： 实时光照和烘焙光照。 实时光照：PC，主机端运行，照明效果好，但是消耗资源较大。 烘焙光照：移动端运行，照明效果也不错，消耗资源较少。 Unity 默认的颜色空间（Color Space）设置选项是选择为Gamma，但是如果我们使用PBR 渲染流程（标准着色器）就必须将颜色空间修改为Linear。 修改颜色空间: Edit –&gt; Project Settings –&gt; Player –&gt; Other Settings –&gt;Rendering –&gt; Color Space –&gt; Linear [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18033002-300x232.png) 二.实时光照 1.实时光照全称为Precomputed Realtime GI（预先计算的实时全局光照）； GI 全称是Global illumination（全局光照）； Unity5.x 光照系统默认使用的就是实时光照类型。 2.测试案例：四盏不同颜色的聚光灯照亮地面，手动控制一个Cube 在地面上移动。 目的：测试实时光照下的场景模型与灯光的关系。 测试结果： 3.测试结论 Unity 默认状态，就是实时光照模式，在这种模式下的特点如下： ①所有的灯光都真实的参与运算，可以动态的改变任何的灯光(位置,颜色,强度….)，且随着改变，灯光对场景环境的影响也是实时的。 ②所有的场景环境模型，也同样是真实的参与运算，这些场景模型也是真实的受到各种光源的影响。 ③综合结论：光源真实的影响环境，环境真实的受光源影响。 3.Lighting 面板相关设置 Ambient Mode：显示当前光照系统的模式（实时还是烘焙）。 Auto Gemerate复选框的作用：默认是勾选状态，也就意味着我们场景里面添加了新的模型，改变了原有模型的位置，场景灯光是会自动计算的。场景内资源模型较少时，可以勾选，但是如果场景很复杂了，就要取消这个Auto 的勾选状态，否则你每次调整了场景中模型，都要重头更新 一次，是很消耗时间的。 前面的Auto Gemerate选项就是控制这些相关数据，是自动还是手动生成。","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"PBR质感表现之玻璃材质","slug":"pbr质感表现之玻璃材质","date":"2018-03-29T02:41:12.000Z","updated":"2020-07-05T11:22:19.613Z","comments":false,"path":"2018/03/29/pbr质感表现之玻璃材质/","link":"","permalink":"http://yoursite.com/2018/03/29/pbr%E8%B4%A8%E6%84%9F%E8%A1%A8%E7%8E%B0%E4%B9%8B%E7%8E%BB%E7%92%83%E6%9D%90%E8%B4%A8/","excerpt":"","text":"玻璃质感测试案例：循环生成多排3D 球体，通过C#代码修改球体身上材质球相关参数。 渲染模式(Rendering Mode)：Transparent Albedo里的Alpha值透明度调为0； 四种情况： 第一排：金属度：00.5，平滑度0.5； 第二排：金属度：00.5，平滑度1； 第三排：金属度：0，平滑度0.51； 第四排：金属度0.5，平滑度0.51。 项目代码： using System.Collections;using System.Collections.Generic;using UnityEngine; public class GlassDemo : MonoBehaviour { private Material m\\_Material; public GameObject prefab; void Start () { //金属度：0~0.5，平滑度0.5； for (int i = 0; i &lt;= 5; i++) { Vector3 pos = new Vector3(i, 0, 0); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, i \\* 0.1f); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;,0.5f); } //金属度：0~0.5，平滑度1； for (int i = 0; i &lt;= 5; i++) { Vector3 pos = new Vector3(i, 0, -1); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, i \\* 0.1f); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, 1); } //金属度：0，平滑度0.5~1； for (int i = 0; i &lt;= 5; i++) { Vector3 pos = new Vector3(i, 0, -2); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, 0); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, i \\* 0.1f); } //金属度0.5，平滑度0.5~1。 for (int i = 0; i &lt;= 5; i++) { Vector3 pos = new Vector3(i, 0, -3); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, 0.5f); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, i \\* 0.1f); } }} 代码中Shader参数的值可以对照Unity官方的着色器压缩包里的代码来书写： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032903-300x178.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032903.png)项目运行效果，未开启光线渲染： [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032904-300x183.png) 玻璃质感总结 1.两个参数 Albedo 有两个参数，贴图和颜色面板，颜色面板里面的Alpha 通道是0~255。 Albedo 贴图是一张纯色纹理图，贴图是可以存Alpha 通道的。 颜色面板里面的Alpha 通道，调整的时候，整个模型都是统一的一种效果； 贴图则可以分区域控制透明度的高与低，使得模型透明效果更有层次。","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"PBR质感表现之金属材质","slug":"pbr质感表现之金属材质","date":"2018-03-29T02:21:16.000Z","updated":"2020-07-05T11:22:21.797Z","comments":false,"path":"2018/03/29/pbr质感表现之金属材质/","link":"","permalink":"http://yoursite.com/2018/03/29/pbr%E8%B4%A8%E6%84%9F%E8%A1%A8%E7%8E%B0%E4%B9%8B%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/","excerpt":"","text":"在Unity5.x 中，金属度是相对而言是最关键的一个可调整参数。 我们在Unity 中模拟现实生活中的东西，很多时候都需要控制它们的金属度。 金属度测试案例：循环生成多排3D 球体，通过C#代码修改球体身上Shader 的金属度相关参数。 四种情况： 第一排：金属度01，平滑度0； 第二排：金属度01，平滑度1; 第三排：金属度0，平滑度01; 第四排：金属度1，平滑度01。 代码： using System.Collections;using System.Collections.Generic;using UnityEngine; public class Metallic : MonoBehaviour { public GameObject prefab; void Start () { //金属度0~1，平滑度0； for(int i = 0; i &lt;= 10; i++) { Vector3 pos = new Vector3(i, 0, 0); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, i \\* 0.1f); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, 0); } //金属度0~1，平滑度1; for (int i = 0; i &lt;= 10; i++) { Vector3 pos = new Vector3(i, 0, -1); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, i \\* 0.1f); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, 1); } //金属度0，平滑度0~1; for (int i = 0; i &lt;= 10; i++) { Vector3 pos = new Vector3(i, 0, -2); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, 0); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, i \\* 0.1f); } //金属度1，平滑度0~1 for (int i = 0; i &lt;= 10; i++) { Vector3 pos = new Vector3(i, 0, -3); GameObject go = GameObject.Instantiate(prefab, pos, Quaternion.identity); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Metallic&quot;, 1); go.GetComponent&lt;MeshRenderer&gt;().material.SetFloat(&quot;\\_Glossiness&quot;, i \\* 0.1f); } }} 代码中Shader参数的值可以对照Unity官方的着色器压缩包里的代码来书写： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032903-300x178.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032903.png) 项目运行效果，未开启光线渲染： [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032902-300x125.png) 案例分析： 金属度不高的，但是平滑度高（如第三排）：瓷器，塑料，玻璃等 金属度高，但是平滑度低（如第一排）：磨砂金属，金属等 金属度总结： 1.两个参数 Metallic 有两个参数，贴图和滑块条，滑块条控制的参数是01。 金属度贴图是一张黑白图，就是用这些黑到白的颜色，存储01 相关的信息值。 滑块条是调整的整体，调整的时候，整个模型都是统一的一种效果； 贴图则可以分区域控制金属度的高与低，使得模型金属效果更有层次。","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"Unity音频资源优化","slug":"unity3d音频资源优化","date":"2018-03-28T08:13:57.000Z","updated":"2020-07-05T08:56:51.206Z","comments":false,"path":"2018/03/28/unity3d音频资源优化/","link":"","permalink":"http://yoursite.com/2018/03/28/unity3d%E9%9F%B3%E9%A2%91%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/","excerpt":"","text":"使用UWA分析项目发现音效资源后，又使用Unity profiler来分析项目中的audio资源发现，一个背景音乐和两个音效居然用了14MB的内存消耗，优化后降到了2MB. UWA分析结果： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032804-300x103.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032804.png) 优化前：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032801-300x165.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032801.png)优化后：[![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032802-300x170.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032802.png) 优化方案： 在安卓平台，如果一开始就把音频加载进去的话，那么内存开销就会比较大，所以我们可以使用缓存的方式来处理；我们可以将背景音乐和两个音效设置加载模式为streaming模式，使用缓存加载，播放完毕后会自动从缓存中卸载，从而提高内存占用率。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032803-300x236.png) Force To Mono：力量单声道 如果启用，音频剪辑将向下混音为单声道声音。在向下混频后，信号被峰值归一化，因为下混频过程通常会导致比原始信号更安静的信号，因此峰值归一化信号通过AudioSource的音量属性为后续调整提供了更好的余量空间 Normalize：规范化 启用此选项后，在“强制为单声道”混音过程中，音频将被标准化。 Load In Background：在后台加载 如果启用，音频剪辑将在后台加载，而不会在主线程上造成停顿。这在默认情况下是关闭的，以确保场景开始播放时所有音频剪辑已完成加载的标准Unity行为。请注意，音频剪辑上仍在后台加载的播放请求将被延迟，直到剪辑完成加载。加载状态可以通过AudioClip.loadState属性查询。 Ambisonic：环绕声 Ambisonic音频源以一种格式存储音频，该格式表示可根据听众的方向旋转的声场。对于360度视频和XR应用程序非常有用。如果您的音频文件包含Ambisonic编码的音频，请启用此选项。 Default选项：Override for android：减小安卓打包体积； Load Type: Streaming:流 动态解码声音。此方法使用最小量的内存来缓冲从磁盘逐渐读取并在运行中解码的压缩数据。请注意，解压缩发生在分析器窗口的音频面板的“Streaming CPU”部分中可监视其CPU使用率的单独流式线程上。注意：即使没有加载任何音频数据，流式片段也会有大约200KB的过载。 Decompress On Load:加载时解压缩 音频文件一经加载就会被解压缩。对较小的压缩声音使用此选项可避免即时解压缩的性能开销。请注意，在加载时解压缩Vorbis编码的声音比使用它压缩大约多十倍的内存（对于ADPCM编码大约是3.5倍），所以不要将此选项用于大文件。 Compressed In Memory:压缩在内存中 保持声音在存储器中压缩并在播放时解压缩。这个选项有一个小的性能开销（尤其是对于Ogg / Vorbis压缩文件），所以只能用于较大的文件，因为在加载时解压缩会使用大量的内存。解压缩在混音器线程上发生，并可在Profiler窗口的音频面板中的“DSP CPU”部分进行监视。 Preload Audio Data:预加载音频数据 如果启用，音频剪辑将在场景加载时预先加载。默认情况下，这反映了在场景开始播放时所有音频剪辑已完成加载的标准Unity行为。如果未设置该标志，音频数据将要么被上加载的第一个的AudioSource.Play（）/ 的AudioSource .PlayOneShot（），或者它可以通过加载的AudioSource.LoadAudioData（），并通过再次卸载的AudioSource .UnloadAudioData（）。 unity通常会对音频文件勾选〃Preload Audio Data”，勾选后音频文件会在 加载场景时全部加载，并保持在内存中，目的是节约实时加载的时间，避免音效延迟播放的现象， 但这意味着加载场景的时间变长，运行时内存占用也会变高。 降低音质后音频的体积变小，内存占用小，能够有效缓解以上两个问题。 在实际应用时，为了缩短Loading时间，降低内存占用，有的音频会直接选择取消勾选”Preload Audio Data”,等到要调用该音频文件时才实时读取。而降质后的音频小，读取率仍会有所提升。 小文件音频建议使用预加载，大文件音频建议使用将Load Type修改为 Streaming ,这样在播放完毕后会自动释放对应文件。 Compression Format:压缩格式 PCM ：提供高品质但牺牲文件大小最适合使用在很短的音效上。 ADPCM： 这种格式适用于大量音效上如脚步爆破和武器，它比PCM小3.5倍但CPU使用率远低于Vorbis/MP3 Vorbis/MP3： 比PCM小但是品质比PCM低，比ADPCM消耗更多CPU。但大多数情况下我们还是应该使用这种格式，这个选择还多了个Quality可以调节质量改变文件大小 Unity3D游戏引擎一共支持4个音乐格式的文件.AIFF 适用于较短的音乐文件可用作游戏打斗音效 .WAV 适用于较短的音乐文件可用作游戏打斗音效 .MP3 适用于较长的音乐文件可用作游戏背景音乐 .OGG 适用于较长的音乐文件可用作游戏背景音乐 增强音频性能：1.尽量减少音频数量 因为每个 Audio Source的播放都会消耗一定量的cpu，所以我们可以控制场景中 Audio Source的数量来节省cpu。 一种方式是控制我们的音频来源，这种方式我们硬盘上 的AudioClip可以同时播放的数量和总共播放的总数进行节流控制。我们通常会做一个AudioPool做这些节流操作，这很适合2d声音和单实例的3d声音（3d声音在播放的时候 仍然要放在场景中具体的位置 ）。 更甚至是移除一些音频，这种做法会影响到用户体验，我们应该在质量和性能上做权衡。 2.减少AudioClip引用 场景中每个Audio Source的Audio Clip引用和Preload Audio Data 启用都将消耗一定量的内存（压缩解压或者缓存），这些内存将贯彻整个场景,如果两个或两个以上的Audio Source引用相同的Audio Clip没有额外的内存消耗。Audio Clips在Unity中是非托管资源这意味着他们不会通过设置为null释放内存。 Unity希望我们能够加载和释放这些资源，经常使用的音效长久的在内存中保存文件是合理的，因为每次加载一个文件到 内存中都会消耗CPU。然而，如果我们发现因为音效而使用太多的内存的时候，我们必须做出艰难的选择是降低音频质量还是完全移除他们来节省内存。另一方面，保存不常用的音效在一个很长的场景中将会造成重大问题。 我们可能会有很多一次性音效，如对话片段，它们没有需 要长久保存在内存中。创建Audio Sources并分配一个AudioClip如果只是这样即使在游戏中只有一次使用也会导致内存消耗过剩，我们应该利用Resources.Load()和Resources.UnloadAsset()来保持需要播放的音频数据在内存中，一旦它不在需要就立即释放它。","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"常见HTTP状态码","slug":"常见http状态码","date":"2018-03-28T06:49:06.000Z","updated":"2020-07-05T11:16:42.283Z","comments":false,"path":"2018/03/28/常见http状态码/","link":"","permalink":"http://yoursite.com/2018/03/28/%E5%B8%B8%E8%A7%81http%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"状态代码： 状态代码由3位数字组成，表示请求是否被理解或被满足。 状态描述： 状态描述给出了关于状态代码的简短的文字描述。 状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。 第一个数字有五种可能的取值： - 1xx: 指示信息—表示请求已接收，继续处理。 - 2xx: 成功—表示请求已经被成功接收、理解、接受。 - 3xx: 重定向—要完成请求必须进行更进一步的操作。 - 4xx: 客户端错误—请求有语法错误或请求无法实现。 - 5xx: 服务器端错误—服务器未能实现合法的请求。 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议 200 OK ** 一切正常，对GET和POST请求的应答文档跟在后面** 201 Created 服务器已经创建了文档，Location头给出了它的URL。 202 Accepted 已经接受请求，但处理尚未完成。 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently ** 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。** 302 Found ** 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。** 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取 304 Not Modified ** 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。** 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取 307 Temporary Redirect ** 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。** 400 Bad Request ** 请求出现语法错误。** 401 Unauthorized ** 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。** 403 Forbidden ** 资源不可用。** 404 Not Found ** 无法找到指定位置的资源** 405 Method Not Allowed 请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。 410 Gone ** 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。** 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。 412 Precondition Failed 请求头中指定的一些前提条件失败 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头 414 Request URI Too Long URI太长 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头 500 Internal Server Error ** 服务器遇到了意料不到的情况，不能完成客户的请求** 501 Not Implemented ** 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求** 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Unity模块性能优化笔记一","slug":"unity模块性能优化笔记一","date":"2018-03-21T07:31:30.000Z","updated":"2020-07-05T08:56:51.202Z","comments":false,"path":"2018/03/21/unity模块性能优化笔记一/","link":"","permalink":"http://yoursite.com/2018/03/21/unity%E6%A8%A1%E5%9D%97%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0%E4%B8%80/","excerpt":"","text":"UI模块： NGUI:UIRect.Start()函数在耗时监测时绿色线条很多的话，说明UI界面在频繁Instantiate/Destory。 [ 背包等UI需要大量切换时，不推荐使用Instantiate/Destory或Active/Deactive来频繁切换； 改为将对象移回屏幕内。这样性能就好多了。 UGUI:如何定位Mesh重建是否合理？ 1.动态元素和静态元素分离； 2.合理配置UI Canvas/Panel，一个Canvas下的Widget不宜过多 UGUI和NGUI的性能区别： 如果都合理搭配，UGUI在性能上还是有一点优势的，在Unity5.2、5.3之后UGUI有一部分网格合并的操作是放在多线程中进行，相对来讲，性能有一定的提升； 但NGUI的优化相对更简单一些，主要是因为NGUI的Drawcall相对容易估计，可以知道Drawcall从哪里来的，也更容易定位网格的刷新是由什么元素引起的， 但UGUI的Drawcall难以估计，且网格重建的开销因为引入了多线程，也会被隐藏起来，所以优化起来，UGUI的难度相对更高一些； UI被多线程渲染影响的原因： 无论是UGUI，还是NGUI，都有一个特点，就是他的UI mesh可能会因为没有动静分离或别的原因产生一个网格的重建， 在网格重建之后，我们会发现它的半透明会非常的高，WaitingForJob会开销比较大，具体原因没有一个理论上的解释。 解决方案： 1.解决动静分离的问题 2.优化DrawCall 如何进行UI的动静分离： 首先要区分动态元素和静态元素的区别，静态元素就是比如主页面，都是静止的一些icon等，当你不去点击的时候都是精致的 动态的就是你改变了它的Active/Deactive或Instantiate/Destory 从UGUI或NGUI的底层来讲的话，就是要看哪些东西是引起了UI DrawCall的变化， 如果这个panel或canvas引起了DrwaCall的变化，那么可以认为是动态的 如果在一些帧中不变，那么可以认为是静态的； 对于NGUI中UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下： 1.尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内； 2.尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 3.控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。 物理模块： 物理模块的耗时跟Update其实是没有太大关系的，举个例子，比如物理模块的timestep默认为0.02，就是20毫秒更新一次， 如果游戏比较卡的话，比如一帧用了100ms，那么物理模块就要执行5次，耗时直接就上去了； 如果对物理模块完全没有使用的话，可以把0.02直接变成0.1，也就是100毫秒更新一次，对游戏运行不会有特别大的影响 如果对物理模块没有使用，并且FixedUpdate也没有使用的话，timestep值可以调的更高； Contacts数量：碰撞对数量 NGUI将UI控件都当做3D世界中的物体来做碰撞体，当碰撞对中出现UI碰撞对的时候，是因为NGUI将带有collider和rigidbody的同一深度的UI物体都当成了碰撞体。 解决方案：Edit/Project Setting/Physics,把ui和ui的碰撞去掉; Active Rigidbody数量小于50是比较好的，因为大家经常调用Rigidbody里面的API； 少量调用没有问题，如果某一帧里面大量Rigidbody大量在调用，会造成一些物理上的开销， 因为Rigidbody的physics是自己计算的，由于重力的原因，当我们移动时，跟mesh collider地表会有一个大的开销； [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032102-300x250.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032102.png) 碰撞体数量建议是100以下。但是三四百也没问题，这个要取决于Contacts数量，也就是碰撞对数量， 如果碰撞对数量为0，那么碰撞体数量高一点也没关系； [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032103-300x129.jpg) 影响物理系统耗时的因素主要为Contacts数量（碰撞对数量）、Rigidbody API的使用情况和每帧的调用次数。 1.第一种情况是最为常见的引发物理模块耗时较大的原因，因此，我们在UWA性能报告中对其进行了详细的分析，如果你的报告中Contacts数量较高，切记要验证其合理性。 2.第二情况造成较大CPU开销的情况不多，不过如果你的项目是多角色游戏（比如MMO、MOBA、ARPG割草游戏等），那么你需要注意了。在我们优化过的一些项目中，通过Rigidbody API来移动GameObject位置（设置velocity、改变center等）确实会存在较高的性能开销。如果你的项目也有类似的做法，那么要时刻关注物理模块的开销了。 3.第三种情况同样也是目前引发物理模块耗时较高的原因。因为Unity引擎默认情况下，物理的更新频率是0.02s，即每20ms更新一次，所以，当你的项目比较卡时（开发过程中的项目在中低端设备上恐怕没几个是不卡的），物理模块会让你的项目更卡。举个例子，如果上一帧CPU耗时为100ms的话，那么物理模块会执行5次，从而进一步加大物理系统的耗时。这种情况下，物理模块的耗时是很有欺骗性的，你花了好长时间去研究物理的耗时，最后发现原来这个“锅”不是它的…所以，如果你的项目也遇到了这种情况，切记不要再上当了。 动画模块： MeshSkinning.Update耗时越低越好，蒙皮网格的顶点的面片尽可能的降低，1500面片左右就非常合理； [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032104-300x127.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032104.png) Animation.Update and Animator.Update： Animator.Update会有一些峰值，一般是在从新开始或者切镜头的时候可能会产生，都是属于一些离散点； [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032105-300x131.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032105.png) 代码效率中会有Animators.Update: Animator.ApplyOnAnimatorMove比较高的原因是项目组重写了AvatarController.OnAnimatorMove()， 调用次数高说明每一帧都有大量的角色进行cpu的开销 所以优化cpu的话有两点，第一点看看逻辑代码是否OK，第二点看是不是调用的次数太高了； Animators.ProcessAnimationsJob里面是一些对AnimatonClip的采样和读取， unity5.3之后放到了子线程，WaitingForJob就是等待子线程处理， 根据角色的多少以及AnimationClip的复杂程度，会有一个比较高的耗时； Animators.FireAnimationEventsAndBehaviours占用比较高的一般都是动画事件， ActionEventListener.SoundActivity()，ActionEventListener.effectActivity()，ActionEventListener.bulletActivity()是动画脚本事件 Animators.DirtySceneObjects是经常会比较高的， [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032106-300x177.png) 粒子系统： unity5.3之后，粒子系统由主线程调到了子线程 ParticleSystem.ScheduleGeometryJobs 粒子系统的计算和准备 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032107-300x128.png) ParticleSystem.Update的优化建议： 1.严格控制粒子系统的active的数量，每一帧里面的数量越多，ParticleSystem.Update就越高，无论这个粒子系统是否在视域体里面 2.对于视域体外面的，可以根据一些具体情况看看ParticleSystem是否可以进行关闭，可以通过一些方式， 一.比如说直接就计算粒子系统它的一个距离，当距离比较远时，可以进行关闭； 二.其次就是算一个它的UV，就是往屏幕上做投影，发现它在屏幕外测的时候，也是可以尝试着进行关闭 三.在unity5.2之后，unity有一个很好的功能就是CullingGroup， CullingGroup可以告许你每一帧它是否在视域体外或者是它跟相机的一个距离 这样就会有效的降低ParticleSystem.Update的cpu性能开销。 根据移动设备对粒子系统进行管理，对于低端设备尽可能降低粒子系统的复杂程度和屏幕覆盖面积，从而降低其渲染方面的开销，提升低端设备的运行流畅性。具体做法如下： 1.在中低端机型上降低粒子数、同屏粒子数，比如仅显示“关键”粒子特效或自身角色释放的粒子特效等，从而降低Update的CPU开销； 2.尝试关闭离当前视域体或当前相机较远的粒子系统，离近后再进行开启，从而避免不必要的粒子系统Update的开销； 3.尽可能降低粒子特效在屏幕中的覆盖面积，覆盖面积越大，层叠数越多，其渲染开销越大； 4.对于Unity 5.x项目，可尝试升级到5.3以后版本，因为Unity在5.3版本后对粒子系统底层进行了深入的优化。 加载模块： 当GameObject数量和资源数量较高时，会造成RUUA CPU开销比较高，耗时会增高； [ ](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032108-300x257.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032108.png) RUUA CPU就是Resources.UnloadUnusedAssets CPU； [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032109-300x258.png)](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032109.png) Resources.UnloadUnusedAssets CPU耗时主要是判断asset是否是Unused，那么如何判断呢， Unity引擎并不是按照引用计数的，因为这样会出现很多问题，比如相互引用等，他已经游离了，但是引用计数不为0； unity主要是还是通过查看asset是否被索引，如果没有被索引的话，才会被认为时Unused, 所以当我们的GameObject数量和资源数量较高时，RUUA CPU的循环就比较多，开销会比较多； Loading.UpdatePreloading CPU耗时是unity引擎最为耗时的主要的一个加载模块开销，小于1500毫秒就可以了； Loading.UpdatePreloading 在代码效率里的堆栈信息： GarbageCollectAssetsProfile比较高，因为它就是RUUA CPU里的Unused的开销； Application.LoadLevelAsync Integrate是加载场景； GC.Collect是垃圾回收； UnloadScene就是收集上一个场景的gameobject和以及它身上的component进行卸载，就是Destory； Loading.AwakeFromLoad是加载场景后做的一些其它事情，比如Mesh.AwakeFromLoad将Mesh从cpu传到gpu； [![](http://www.wjgbaby.com/wp-content/uploads/2018/03/18032110-300x188.png) 加载资源是放在Update里面合适还是放在协程里面： 一般是用协程，不过放在Update里面也没什么问题 目前大部分手游可以使用2048*2048的贴图； GC调用： 调用频率是一个很重要的标准， 1.要尽可能的优化代码的堆内存,可以减少foreach，link的使用，减少stream关联等，这些问题并不是最主要的 最主要的是如果项目里的运行一万帧超过了20M，那么GC回来的很快，实际项目中会把代码都拆开， 然后定位到底哪个函数在这一万帧中分配了多少堆内存，所以其实并不是特别在意foreach，link使用，stream关联等 XML文件或者配置文件或者解密加密这一块经常会有几十M的堆内存分配，大部分的堆内存都是配置文件造成的 所以尽可能的要在1万帧以下小于20M，最高不要超过30M； 2.当堆内存降下来后，可以尝试放开手动的GC调用； GC释放策略： 在场景切换的时候进行一些GC的，会耗费100毫秒左右； 不建议在UI开启或关闭的时候进行 UWA视频链接：https://v.qq.com/x/page/x0378dxq4m3.html","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"标准Shader的十种贴图类型","slug":"标准shader的十种贴图类型","date":"2018-02-25T08:48:25.000Z","updated":"2020-07-05T11:22:19.613Z","comments":false,"path":"2018/02/25/标准shader的十种贴图类型/","link":"","permalink":"http://yoursite.com/2018/02/25/%E6%A0%87%E5%87%86shader%E7%9A%84%E5%8D%81%E7%A7%8D%E8%B4%B4%E5%9B%BE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一. 标准Shader 诞生 1.标准Shader背景 &lt;1&gt;Unity4.x 阶段，Unity 老被拿来和UrealEngine（虚幻）进行对比，得到的结论就是Unity 是“渣画质”，Ureal 是“高大上”。但是相对而言Unity易于学习，开发速度快，跨平台多，就业岗位多，却也是Ureal 比不了的。 &lt;2&gt;Unity4.x 阶段的画面渲染使用的是AutoDesk 的Beast 技术；Unity5.x阶段彻底放弃了Beast 技术，改为使用和UrealEngine 一样的一款第三方渲染引擎Enlighten 来进行画面渲染。 &lt;3&gt;Unity 为了配合这个新的渲染引擎，推出了“标准Shader”。 &lt;4&gt;理论上，我们可以使用Unity5 制作出和UrealEngine 差不多的画面效果。 2.标准Shader 的优点 使用一个Shader 完成大部分场景模型的渲染；无论是人物角色，金属，塑料，皮革，布料，玻璃，建筑……都可以使用一个标准Shader 来完成渲染。 3.标准Shader 贴图 标准Shader 使用的是PBR 渲染，基于现实物理效果的渲染表现形式。 一个模型能不能使用标准Shader 来进行渲染，是在做这个模型的贴图的时候决定的。有没有按照PBR 贴图的制作规范和模式来制作，决定了该模型是否可以使用标准Shader 渲染。 4.两种标准Shader Unity5.x 中的标准Shader 有两个： Standard：标准着色器 Standard（Specular setup）：标准着色器（镜面） Standard（Specular setup）比Standard多了一种贴图。 二. 十大贴图 1.Albedo 贴图** Albedo：反照率[贴图]；用于体现模型的纹理，颜色。 反照率贴图本身是一张颜色与纹理的贴图。 该选项有贴图属性，也有颜色属性。 两个属性可以单独使用，也可以组合使用； 当颜色属性为纯白色时，则不影响贴图的效果； 当颜色属性为其他颜色时，则叠加贴图效果。 2.Metallic 贴图** 金属度[贴图]；用于体现模型的金属高光反射； 金属度贴图本身是一张灰白图，越白的地方，金属度越强烈，越黑的地方金属度越低。 Smoothness：平滑度 介于0 和1 之间的一个值，越小，平滑度越低，越大，平滑度越高。 3.Normal Map 贴图** Normal Map：法线贴图；用于增加模型的细节； 法线贴图本身是一张蓝色的凹凸图。 4.Occlusion 贴图 Occlusion：AO 贴图； AO 贴图本身是一张灰白图。 主要用于改善阴影，给场景(模型)更多的深度，有助于更好的表现模型的细节。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022501-300x234.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022501.jpg) **5.Specular** Specular：镜面[贴图]，类似于“Metallic 金属度”贴图。 **PBR 贴图的制作方式不同，最终关于“金属部分”的表现，出现了两种类型的贴图，Metallic 和Specular。** **6.Detail Albedo x2** Detail Albedo x2：细节反照率[贴图]； 作用是**对主Albedo 贴图的一个细节深入表现；** **7.Normal Map x2** Normal Map x2：细节法线[贴图]； 作用是**对主Normal Map 贴图的一个细节深入表现；** **8.Detail Mask** Detail Mask：细节遮罩[贴图]； 这个贴图是配合“次贴图区域”中的**Detail Albedo，Normal Map 两张贴图配合使用的**，次贴图区域中的这两张很多是平铺的贴图，效果会作用于模型的全部，我们使用Detail Mask 将一些不需要被“次贴图”影响的部分独立出来。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022502-300x227.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022502.jpg) **9.Emission 贴图** Emission：自发光[贴图]，让模型自发光； Unity 里面能作为光源存在的除了灯光组件和天空盒，标准Shader 里面的Emission 贴图也是可以作为一种光源的。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022503-300x221.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022503.jpg) **10.Height Map 贴图** Height Map：视差[贴图]，比Normal Map 更有立体感的一种贴图方式； 主要用于地面，建筑等效果的体现。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022504-300x226.jpg)","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"OpenGL笔记七：旋转变换","slug":"opengl笔记七：旋转变换","date":"2018-02-23T09:24:36.000Z","updated":"2020-07-05T08:56:51.197Z","comments":false,"path":"2018/02/23/opengl笔记七：旋转变换/","link":"","permalink":"http://yoursite.com/2018/02/23/opengl%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9A%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2/","excerpt":"","text":"接下来的变换是旋转变换，就是说给定一个角度和点，我们将点绕着一个坐标轴旋转。在旋转过程中发生变化的总是ｘ，ｙ，ｚ三个坐标里面的其中两个，而不让第三个坐标值变化。这意味着，旋转路径总在三个坐标轴平面中的一个之中：绕 Z 轴的是 xy 面、绕 X 轴的是 yz 面、绕 Y 轴的是 xy 面。还有许多复杂的旋转变换可以让你绕任意一个向量旋转，但是眼下我们并不需要讨论这些。 让我们概括地定义这个问题这个问题。看看下面的这个图： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022306-300x278.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022306.jpg) 我们想沿着圆圈从（x1,y1）移动到（x2,y2）。也就是说我们让向量（x1,y1）转过a2角度。我们假设这个圆的半径是1。这意味着下列成立： x1=cos(a1) y1=sin(a1) x2=cos(a1+a2) y2=sin(a1+a2) 我们用下面的三角恒等式来产生 x2 和 y2 ： cos(a+b) = cosacosb - sinasinb sin(a+b) = sinacosb+cosasinb 通过面的式子我们可以推导出： x2=cos(a1+a2) = cosa1cosa2- sina1sina2 = x1cosa2- y1sina2 y2=sin(a1+a2) = sina1cosa2+ cosa1sina2 = y1cosa2+ x1sina2 在上面的图中我们看向 xy 平面，Z 轴指向屏幕内部！如果 X 分量和 Y 分量是四维向量的一部分，那样上面的等式可以写成下面的矩阵形式（不影响 Z 和 W ）为：[![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022302-300x86.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022302.jpg)如果我们想创建一个绕着 Y 轴或者绕着 Z 轴的旋转变换矩阵，那么方程基本相同但是矩阵的安排却略有不同！这是绕Y轴旋转的矩阵： [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022303-300x81.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022303.jpg) 绕X轴的旋转矩阵为： [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022304-300x81.jpg) 源代码详解: 在上个教程的基础上这里代码的变换非常少。我们只是改变代码中变换矩阵的内容，将平移变换矩阵换成了旋转变换矩阵而已： World.m[0][0]=cosf(Scale);World.m[0][1]=-sinf(Scale);World.m[0][2]=0.0f; World.m[0][3]=0.0f;World.m[1][0]=sinf(Scale);World.m[1][1]=cosf(Scale);World.m[1][2]=0.0f; World.m[1][3]=0.0f;World.m[2][0]=0.0f;World.m[2][1]=0.0f;World.m[2][2]=1.0f;World.m[2][3]=0.0f;World.m[3][0]=0.0f;World.m[3][1]=0.0f;World.m[3][2]=0.0f;World.m[3][3]=1.0f; 这样会看到图形绕着Z轴旋转了。我们也可以尝试绕其他轴的旋转，但是没有从3d到2d的投影另外两种旋转看上起去会很奇怪，我们会在后面教程中在一个完整的图形变换管线类中来完善它。 源代码： #include &lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;GL/glew.h&gt;#include &lt;GL/freeglut.h&gt;#include “ogldev_math_3d.h” //用于OpenGL的3d数学库#include “ogldev_util.h” //用于读取文本文件 GLuint VBO; //全局GLuint引用变量，来操作顶点缓冲器对象GLuint gWorldLocation; // 平移变换一致变量的句柄引用 // 定义要读取的顶点着色器脚本和片断着色器脚本的文件名，作为文件读取路径const char* pVSFileName = “shader.vs”;const char* pFSFileName = “shader.fs”; static void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空颜色缓存 static float Scale = 0.0f; //维护一个不断慢慢增大的静态浮点数 Scale += 0.0001f; //如果图像变化太快或者太慢，可调节此数值 // 4x4的旋转变换矩阵 Matrix4f World; World.m\\[0\\]\\[0\\] = cosf(Scale); World.m\\[0\\]\\[1\\] = -sinf(Scale); World.m\\[0\\]\\[2\\] = 0.0f; World.m\\[0\\]\\[3\\] = 0.0f; World.m\\[1\\]\\[0\\] = sinf(Scale); World.m\\[1\\]\\[1\\] = cosf(Scale); World.m\\[1\\]\\[2\\] = 0.0f; World.m\\[1\\]\\[3\\] = 0.0f; World.m\\[2\\]\\[0\\] = 0.0f; World.m\\[2\\]\\[1\\] = 0.0f; World.m\\[2\\]\\[2\\] = 1.0f; World.m\\[2\\]\\[3\\] = 0.0f; World.m\\[3\\]\\[0\\] = 0.0f; World.m\\[3\\]\\[1\\] = 0.0f; World.m\\[3\\]\\[2\\] = 0.0f; World.m\\[3\\]\\[3\\] = 1.0f; // 将矩阵数据加载到shader中 glUniformMatrix4fv(gWorldLocation, 1, GL\\_TRUE, &amp;World.m\\[0\\]\\[0\\]); glEnableVertexAttribArray(0); //开启顶点属性 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, 0); //管线解析bufer中的数据 glDrawArrays(GL\\_TRIANGLES, 0, 3); //画三角形，3个顶点 glDisableVertexAttribArray(0); //禁用顶点数据 glutSwapBuffers(); //交换前后缓存} static void InitializeGlutCallbacks(){ glutDisplayFunc(RenderCallBack); glutIdleFunc(RenderCallBack); //将渲染回调注册为全局闲置回调} static void CreateVertexBuffer(){ Vector3f Vertices[3]; //创建含有3个顶点的顶点数组 Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f); Vertices[1] = Vector3f(1.0f, -1.0f, 0.0f); Vertices[2] = Vector3f(0.0f, 1.0f, 0.0f); glGenBuffers(1, &amp;VBO); //创建缓冲器 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(Vertices), Vertices, GL\\_STATIC\\_DRAW); //绑定顶点数据} //使用shader文本编译shader对象，并绑定shader到着色器程序中static void AddShader(GLuint ShaderProgram, const char* pShaderText, GLenum ShaderType){ // 根据shader类型参数定义两个shader对象 GLuint ShaderObj = glCreateShader(ShaderType); // 检查是否定义成功 if (ShaderObj == 0) { fprintf(stderr, “Error creating shader type %d\\n”, ShaderType); exit(0); } // 定义shader的代码源 const GLchar\\* p\\[1\\]; p\\[0\\] = pShaderText; GLint Lengths\\[1\\]; Lengths\\[0\\] = strlen(pShaderText); glShaderSource(ShaderObj, 1, p, Lengths); glCompileShader(ShaderObj); // 编译shader对象 // 检查和shader相关的错误 GLint success; glGetShaderiv(ShaderObj, GL\\_COMPILE\\_STATUS, &amp;success); if (!success) { GLchar InfoLog\\[1024\\]; glGetShaderInfoLog(ShaderObj, 1024, NULL, InfoLog); fprintf(stderr, &quot;Error compiling shader type %d: &apos;%s&apos;\\\\n&quot;, ShaderType, InfoLog); exit(1); } // 将编译好的shader对象绑定到program object程序对象上 glAttachShader(ShaderProgram, ShaderObj);} // 编译着色器函数static void CompileShaders(){ // 创建着色器程序 GLuint ShaderProgram = glCreateProgram(); // 检查是否创建成功 if (ShaderProgram == 0) { fprintf(stderr, “Error creating shader program\\n”); exit(1); } // 存储着色器文本的字符串缓冲 string vs, fs; // 分别读取着色器文件中的文本到字符串缓冲区 if (!ReadFile(pVSFileName, vs)) { exit(1); }; if (!ReadFile(pFSFileName, fs)) { exit(1); }; // 添加顶点着色器和片段着色器 AddShader(ShaderProgram, vs.c\\_str(), GL\\_VERTEX\\_SHADER); AddShader(ShaderProgram, fs.c\\_str(), GL\\_FRAGMENT\\_SHADER); // 链接shader着色器程序，并检查程序相关错误 GLint Success = 0; GLchar ErrorLog\\[1024\\] = { 0 }; glLinkProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_LINK\\_STATUS, &amp;Success); if (Success == 0) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Error linking shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 检查验证在当前的管线状态程序是否可以被执行 glValidateProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_VALIDATE\\_STATUS, &amp;Success); if (!Success) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Invalid shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 设置到管线声明中来使用上面成功建立的shader程序 glUseProgram(ShaderProgram); // 查询获取一致变量的位置 gWorldLocation = glGetUniformLocation(ShaderProgram, &quot;gWorld&quot;); assert(gWorldLocation != 0xFFFFFFFF); // 检查错误} int main(int argc, char** argv){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); glutInitWindowSize(400, 400); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;旋转变换&quot;); glutDisplayFunc(RenderCallBack); //开始渲染 InitializeGlutCallbacks(); // 检查GLEW是否就绪，必须要在GLUT初始化之后！ GLenum res = glewInit(); if (res != GLEW\\_OK) { fprintf(stderr, &quot;Error: &apos;%s&apos;\\\\n&quot;, glewGetErrorString(res)); return 1; } glClearColor(0.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 CreateVertexBuffer(); //创建顶点缓冲器 CompileShaders(); // 编译着色器 glutMainLoop(); //通知开始GLUT的内部循环 return 0;} 片断着色器shader.fs脚本代码: #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 out vec4 FragColor; // 片段着色器的输出颜色变量 // 着色器的唯一入口函数void main(){ // 定义输出颜色值 FragColor = vec4(1.0, 0.0, 0.0, 1.0);} 顶点着色器shader.vs脚本代码： #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 // 绑定定点属性名和属性，方式二缓冲属性和shader属性对应映射layout (location = 0) in vec3 Position; // 平移变换聚矩阵一致变量uniform mat4 gWorld; void main(){ // 用平移变换矩阵乘以图形顶点位置对应的4X4矩阵相乘，完成平移变换 gl_Position = gWorld * vec4(Position, 1.0);} 最终效果（gif图）： 参考链接： http://ogldev.atspace.co.uk/www/tutorial07/tutorial07.html https://learnopengl.com/Getting-started/Transformations http://blog.csdn.net/cordova/article/details/52558133","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"UGUI制作Boss固定血条","slug":"ugui制作boss固定血条","date":"2018-02-21T12:12:19.000Z","updated":"2020-07-05T11:23:24.328Z","comments":false,"path":"2018/02/21/ugui制作boss固定血条/","link":"","permalink":"http://yoursite.com/2018/02/21/ugui%E5%88%B6%E4%BD%9Cboss%E5%9B%BA%E5%AE%9A%E8%A1%80%E6%9D%A1/","excerpt":"","text":"Boss 血条的特点： 1.血条的位置是静态的，不会跟随Boss 改变位置； 2.Boss 的血条一般是“分层”，且有数字标示剩余的血量层数； 3.Boss 的血条也有不分层的，关键在于游戏的策划设定。 最终效果（共3层血）： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022102-300x284.gif) Boss管理器脚本： using System.Collections;using System.Collections.Generic;using UnityEngine; public class BossManager : MonoBehaviour { private GameObject prefab\\_Boss; private GameObject prefab\\_BossHp; private Transform canvas\\_Transform; void Start () { prefab\\_Boss = Resources.Load&lt;GameObject&gt;(&quot;Boss&quot;); prefab\\_BossHp = Resources.Load&lt;GameObject&gt;(&quot;BossHpPanel&quot;); canvas\\_Transform = GameObject.Find(&quot;Canvas&quot;).GetComponent&lt;Transform&gt;(); } void Update () { if(Input.GetKeyDown(KeyCode.M)) { GameObject.Instantiate&lt;GameObject&gt;(prefab\\_Boss); GameObject.Instantiate&lt;GameObject&gt;(prefab\\_BossHp, canvas\\_Transform); } }} Boss血量脚本： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class BossHP : MonoBehaviour { private Transform m\\_Transform; private Image blood\\_0; private Image blood\\_1; private Image blood\\_2; private Text blood\\_Count; private List&lt;Image&gt; bloodLists = new List&lt;Image&gt;(); private int bossHp = 3000; //Boss总血量. private float bloodHp; //单层血条的血量. private int currentIndex; //当前血条的索引. void Start () { m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); blood\\_0 = m\\_Transform.Find(&quot;Blood\\_0&quot;).GetComponent&lt;Image&gt;(); blood\\_1 = m\\_Transform.Find(&quot;Blood\\_1&quot;).GetComponent&lt;Image&gt;(); blood\\_2 = m\\_Transform.Find(&quot;Blood\\_2&quot;).GetComponent&lt;Image&gt;(); blood\\_Count = m\\_Transform.Find(&quot;BossHP\\_BG/Text&quot;).GetComponent&lt;Text&gt;(); bloodLists.Add(blood\\_0); bloodLists.Add(blood\\_1); bloodLists.Add(blood\\_2); bloodHp = bossHp / 3; } void Update () { if(Input.GetKeyDown(KeyCode.K)) { UpdateUI(Random.Range(50, 200)); } } private void UpdateUI(int v) { //死亡判断. if(currentIndex == 2 &amp;&amp; bloodHp &lt;= v) { bloodLists\\[currentIndex\\].fillAmount = 0; Debug.Log(&quot;Boss已经死亡...&quot;); return; } //多层血条伤害表示. if (bloodHp &lt;= v) { bloodLists\\[currentIndex\\].fillAmount = 0; float hp = v - bloodHp; bloodHp = 1000; bloodHp -= hp; currentIndex++; blood\\_Count.text = &quot;x&quot; + (3 - currentIndex); bloodLists\\[currentIndex\\].fillAmount = bloodHp / 1000; } //单层血条伤害表示. bloodHp -= v; bloodLists\\[currentIndex\\].fillAmount = bloodHp / 1000; }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI怪物群的血条跟随","slug":"ugui怪物群的血条跟随","date":"2018-02-21T07:50:51.000Z","updated":"2020-07-05T11:23:24.331Z","comments":false,"path":"2018/02/21/ugui怪物群的血条跟随/","link":"","permalink":"http://yoursite.com/2018/02/21/ugui%E6%80%AA%E7%89%A9%E7%BE%A4%E7%9A%84%E8%A1%80%E6%9D%A1%E8%B7%9F%E9%9A%8F/","excerpt":"","text":"不同于把血条做好放到模型上方，然后制作Prefab文件，最后从Resources资源处调用。 我们先生成模型到Scene中，然后再生成血条，通过计算血条和模型的位置让血条放到模型身上。 最终的一个效果（Cube是五个模型，Blood是五个血条）：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18022101-300x213.png) 血条脚本： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class BloodBar : MonoBehaviour { private Transform m\\_Transform; private Transform cube\\_Transform; private int hp = 100; private bool isLife = true; private Image m\\_Bar; public bool IsLife { get { return isLife; } } void Start () { m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); m\\_Bar = m\\_Transform.Find(&quot;Bar&quot;).GetComponent&lt;Image&gt;(); } void Update () { Follow(); } private void Follow() { //3D坐标转换为2D坐标，WorldToScreenPoint:世界位置转换为屏幕位置 Vector2 cubeV2Pos = RectTransformUtility.WorldToScreenPoint(Camera.main, cube\\_Transform.position); m\\_Transform.position = cubeV2Pos + new Vector2(0, 100); } public void SetPlayer(Transform PlayerTransform) { cube\\_Transform = PlayerTransform; } public void Damage(int v) { hp -= v; if(hp &lt;= 0) { isLife = false; GameObject.Destroy(gameObject); GameObject.Destroy(cube\\_Transform.gameObject); } else { m\\_Bar.fillAmount = hp / 100.0f; } }} 模型移动脚本： using System.Collections;using System.Collections.Generic;using UnityEngine; public class CubeMove : MonoBehaviour { private Transform m\\_Transform; private Rigidbody m\\_Rigidbody; void Start () { m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); m\\_Rigidbody = gameObject.GetComponent&lt;Rigidbody&gt;(); } void Update () { Move(); } private void Move() { float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); Vector3 dir = new Vector3(h, 0, v); m\\_Rigidbody.MovePosition(m\\_Transform.position + dir \\* 0.2f); }} 管理器脚本： using System.Collections;using System.Collections.Generic;using UnityEngine; public class MonsterManager : MonoBehaviour { private GameObject prefab\\_Blood; private GameObject prefab\\_Cube; private Transform m\\_Transform; private Transform bloodParent\\_Transform; private List&lt;BloodBar&gt; bloodBarList; void Start () { prefab\\_Blood = Resources.Load&lt;GameObject&gt;(&quot;Blood&quot;); prefab\\_Cube = Resources.Load&lt;GameObject&gt;(&quot;Cube&quot;); m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); bloodParent\\_Transform = GameObject.Find(&quot;Canvas/BloodParent&quot;).GetComponent&lt;Transform&gt;(); bloodBarList = new List&lt;BloodBar&gt;(); CreateMonsters(); } void Update() { if(Input.GetKeyDown(KeyCode.Space)) { if(bloodBarList.Count &gt; 0) { bloodBarList\\[0\\].Damage(Random.Range(10, 30)); //移除List列表第一个元素，第二个元素会自动补上去 if(bloodBarList\\[0\\].IsLife == false) { bloodBarList.Remove(bloodBarList\\[0\\]); } } else { Debug.Log(&quot;小怪已经全部死亡...&quot;); } } } private void CreateMonsters() { for (int i = 0; i &lt; 5; i++) { float x = Random.Range(-9.0f, 9.0f); float z = Random.Range(-9.0f, 9.0f); Vector3 pos = new Vector3(x, 0.5f, z); Transform cube = GameObject.Instantiate&lt;GameObject&gt;(prefab\\_Cube, m\\_Transform).GetComponent&lt;Transform&gt;(); cube.position = pos; BloodBar blood = GameObject.Instantiate&lt;GameObject&gt;(prefab\\_Blood, bloodParent\\_Transform).GetComponent&lt;BloodBar&gt;(); blood.SetPlayer(cube); bloodBarList.Add(blood); } }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"JSON数据源制作UGUI签到界面","slug":"json数据源之ugui签到界面","date":"2018-02-14T05:24:28.000Z","updated":"2020-07-05T11:23:24.253Z","comments":false,"path":"2018/02/14/json数据源之ugui签到界面/","link":"","permalink":"http://yoursite.com/2018/02/14/json%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B9%8Bugui%E7%AD%BE%E5%88%B0%E7%95%8C%E9%9D%A2/","excerpt":"","text":"签到面板要用到的资源文件，注意名字和路径： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021401-300x243.png)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021401.png)签到界面图，item预制体： [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021402-300x205.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021402.jpg)最终实现的效果（gif图）： [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021403-300x297.gif) JSON压缩后的数据： [ {“ItemName”:”item_1”,”ItemRank”:”0_white”,”ItemNum”:5}, {“ItemName”:”item_2”,”ItemRank”:”0_white”,”ItemNum”:10}, {“ItemName”:”item_6”,”ItemRank”:”0_white”,”ItemNum”:100}, {“ItemName”:”item_3”,”ItemRank”:”1_green”,”ItemNum”:100}, {“ItemName”:”item_7”,”ItemRank”:”2_blue”,”ItemNum”:50}, {“ItemName”:”item_9”,”ItemRank”:”3_purple”,”ItemNum”:60}, {“ItemName”:”item_8”,”ItemRank”:”2_blue”,”ItemNum”:80}, {“ItemName”:”item_5”,”ItemRank”:”1_green”,”ItemNum”:10}, {“ItemName”:”item_3”,”ItemRank”:”2_blue”,”ItemNum”:50}, {“ItemName”:”item_10”,”ItemRank”:”3_purple”,”ItemNum”:1}, {“ItemName”:”item_3”,”ItemRank”:”2_blue”,”ItemNum”:50}, {“ItemName”:”item_2”,”ItemRank”:”0_white”,”ItemNum”:10}, {“ItemName”:”item_6”,”ItemRank”:”0_white”,”ItemNum”:100}, {“ItemName”:”item_3”,”ItemRank”:”1_green”,”ItemNum”:100}, {“ItemName”:”item_9”,”ItemRank”:”3_purple”,”ItemNum”:60}, {“ItemName”:”item_3”,”ItemRank”:”2_blue”,”ItemNum”:50}, {“ItemName”:”item_4”,”ItemRank”:”2_blue”,”ItemNum”:20}, {“ItemName”:”item_9”,”ItemRank”:”2_blue”,”ItemNum”:70}, {“ItemName”:”item_6”,”ItemRank”:”0_white”,”ItemNum”:100}, {“ItemName”:”item_3”,”ItemRank”:”1_green”,”ItemNum”:100}, {“ItemName”:”item_7”,”ItemRank”:”2_blue”,”ItemNum”:50}, {“ItemName”:”item_3”,”ItemRank”:”2_blue”,”ItemNum”:50}, {“ItemName”:”item_9”,”ItemRank”:”3_purple”,”ItemNum”:50}, {“ItemName”:”item_10”,”ItemRank”:”2_blue”,”ItemNum”:1}, {“ItemName”:”item_8”,”ItemRank”:”2_blue”,”ItemNum”:1}, {“ItemName”:”item_8”,”ItemRank”:”3_purple”,”ItemNum”:5}, {“ItemName”:”item_8”,”ItemRank”:”4_orange”,”ItemNum”:10}, {“ItemName”:”item_10”,”ItemRank”:”5_gold”,”ItemNum”:10}] Item元素数据实体类： using System.Collections;using System.Collections.Generic;using UnityEngine; /// /// 签到面板Item元素数据实体类./// public class SignInItem { private string itemName; //名称. private string itemRank; //等级. private int itemNum; //数量. public string ItemName { get{ return itemName;} set{ itemName= value; } } public string ItemRank { get{ return itemRank;} set{ itemRank = value;} } public int ItemNum { get{ return itemNum; } set{ itemNum = value; } } public override string ToString() { return string.Format(&quot;名称:{0},等级:{1},数量:{2}&quot;, this.itemName, this.itemRank, this.itemNum); }} 签到面板管理器脚本： using System.Collections;using System.Collections.Generic;using UnityEngine;using LitJson; /// /// 签到面板管理器脚本./// public class SignInPanelManager : MonoBehaviour { private Transform m\\_Transform; private List&lt;SignInItem&gt; itemList = new List&lt;SignInItem&gt;(); public GameObject prefab\\_Item; private Transform grid\\_Transform; //等级图片字典. private Dictionary&lt;string, Sprite&gt; rankDic = new Dictionary&lt;string, Sprite&gt;(); //月签到数. private int signInNum = 12; void Start () { m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); string jsonStr = Resources.Load&lt;TextAsset&gt;(&quot;signIn&quot;).text; prefab\\_Item = Resources.Load&lt;GameObject&gt;(&quot;Item&quot;); grid\\_Transform = m\\_Transform.Find(&quot;SignInBG/Grid&quot;).GetComponent&lt;Transform&gt;(); //Debug.Log(jsonStr); //等级图片加载. Sprite\\[\\] rankSprite = Resources.LoadAll&lt;Sprite&gt;(&quot;SignIn/rank&quot;); for (int i = 0; i &lt; rankSprite.Length; i++){ //Debug.Log(rankSprite\\[i\\].name); rankDic.Add(rankSprite\\[i\\].name, rankSprite\\[i\\]); } JsonData jsonData = JsonMapper.ToObject(jsonStr); //Debug.Log(jsonData.Count); for (int i = 0; i &lt; jsonData.Count; i++){ SignInItem temp = JsonMapper.ToObject&lt;SignInItem&gt;(jsonData\\[i\\].ToJson()); itemList.Add(temp); } jsonStr = null; rankSprite = null; //循环实例化Item. for (int i = 0; i &lt; itemList.Count; i++){ //Debug.Log(itemList\\[i\\].ToString()); GameObject go = GameObject.Instantiate&lt;GameObject&gt;(prefab\\_Item, grid\\_Transform); //给子物体传值. Sprite tempRank = null; rankDic.TryGetValue(itemList\\[i\\].ItemRank, out tempRank); SignInItemManager sm = go.GetComponent&lt;SignInItemManager&gt;(); if(i &lt; signInNum){ sm.SetItemValue(itemList\\[i\\].ItemName, tempRank, itemList\\[i\\].ItemNum, true); } else{ sm.SetItemValue(itemList\\[i\\].ItemName, tempRank, itemList\\[i\\].ItemNum, false); } if (i == signInNum){ sm.AddButton(); } } }} 签到管理器脚本： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class SignInItemManager : MonoBehaviour { private Transform m\\_Transform; private Image rank\\_Image; //物品等级图标. private Image item\\_Image; //物品图标. private Text num\\_Text; //物品数量. private GameObject mask; //签到后的遮罩. void Awake () { m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); rank\\_Image = gameObject.GetComponent&lt;Image&gt;(); item\\_Image = m\\_Transform.Find(&quot;Img&quot;).GetComponent&lt;Image&gt;(); num\\_Text = m\\_Transform.Find(&quot;Num&quot;).GetComponent&lt;Text&gt;(); mask = m\\_Transform.Find(&quot;Mask&quot;).gameObject; mask.SetActive(false); } /// &lt;summary&gt; /// 给Item赋值. /// &lt;/summary&gt; public void SetItemValue(string name, Sprite rank, int num, bool isSignIn){ //rank\\_Image.sprite = Resources.Load&lt;Sprite&gt;(&quot;SignIn/rank/&quot; + rank); rank\\_Image.sprite = rank; item\\_Image.sprite = Resources.Load&lt;Sprite&gt;(&quot;SignIn/item/&quot; + name); num\\_Text.text = num.ToString(); if(isSignIn){ mask.SetActive(true); } } /// &lt;summary&gt; /// 给自身添加Button. /// &lt;/summary&gt; public void AddButton(){ gameObject.AddComponent&lt;Button&gt;(); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI制作资源加载UI页面","slug":"ugui制作资源加载ui页面","date":"2018-02-11T06:21:16.000Z","updated":"2020-07-05T11:23:24.335Z","comments":false,"path":"2018/02/11/ugui制作资源加载ui页面/","link":"","permalink":"http://yoursite.com/2018/02/11/ugui%E5%88%B6%E4%BD%9C%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BDui%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"进度条加载界面有三种用途：资源解压进度，热更新下载进度还有副本场景加载进度； 不同的情况，是有不同的数据来源的。 资源解压进度：资源的数据列表； 热更新下载进度：根据files.txt 文件； 副本加载进度：场景的异步加载方法的返回值。 1.UGUI 环境设置 CanvasScaler 组件设置类型为：Scale With Screen Size； 比例设置为：1920*1080； 匹配模式：设置为匹配高度。 LoadingPanel是背景图，Loading是进度条边框图片，Center是红色填充图片，percentNum是百分数。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021101-300x208.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021101.jpg)2.Center填充图片设置 设置为Filled填充类型，我们通过控制FILL Amount从0到1的大小来操作进度条的前进。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021102-300x174.png)](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021102.png) 3.运行效果（gif图片）： [![](http://www.wjgbaby.com/wp-content/uploads/2018/02/18021103-281x300.gif) 代码： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using System; public class LoadingPanel : MonoBehaviour { private Transform m\\_Transform; private Image loading\\_Center\\_Image; private Text loading\\_num\\_Text; private float loadingValue = 0; void Start () { m\\_Transform = gameObject.GetComponent&lt;Transform&gt;(); loading\\_Center\\_Image = m\\_Transform.Find(&quot;Loading/Center&quot;).GetComponent&lt;Image&gt;(); loading\\_num\\_Text = m\\_Transform.Find(&quot;Loading/percentNum&quot;).GetComponent&lt;Text&gt;(); StartCoroutine(&quot;SetLoadingValue&quot;); } /// &lt;summary&gt; /// 设置进度条数值. /// &lt;/summary&gt; IEnumerator SetLoadingValue() { while (loadingValue &lt; 0.95f) { loadingValue += UnityEngine.Random.Range(0.01f, 0.1f); Debug.Log(loadingValue); loading\\_Center\\_Image.fillAmount = loadingValue; loading\\_num\\_Text.text = Math.Round(loadingValue, 2) \\* 100 + &quot;%&quot;; yield return new WaitForSeconds(0.2f); } loading\\_Center\\_Image.fillAmount = 1; loading\\_num\\_Text.text = &quot;100%&quot;; Debug.Log(&quot;进度条加载完毕.&quot;); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"六大设计原则-里氏转换原则","slug":"六大设计原则-里氏转换原则","date":"2018-02-11T05:49:33.000Z","updated":"2020-07-05T08:56:51.185Z","comments":false,"path":"2018/02/11/六大设计原则-里氏转换原则/","link":"","permalink":"http://yoursite.com/2018/02/11/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E8%BD%AC%E6%8D%A2%E5%8E%9F%E5%88%99/","excerpt":"","text":"一.里氏转换原则介绍 里氏转换原则： 英文全称是Liskov Substiution Principle。缩写是LSP ①一个软件实体如果使用的是一个父类的话，那么一定适用于其子类。而且它察觉不出父类对象和子类对象的区别。 ②在软件里面，把父类都替换成它的子类，软件的行为没有变化；简单点说，子类型必须能够替换掉它们的父类型。 二.里氏转换切入点 ①子类对象可以直接赋值给父类变量； ②子类对象可以调用父类中的成员，但是父类对象永远只能调用自己的成员； ③如果父类对象中装的是子类对象，可以将这个父类对象强转为子类对象； 三.Unity 里氏转换原则 Unity 引擎是一个父类； Unity4.x，Unity5.x，Unity2017.x 都是这个父类下的子类。本身具备父类的功能，同时又都有自己的新功能。 不管是哪个版本的Unity，我们都可以称它们是Unity 引擎。 不管是哪个版本的Unity，都是基于组件形式开发的，都是以C#语言为核心开发语言，都是支持多平台发布的。但是你不能说Unity 引擎具备timeline 功能，因为这个功能是Unity2017 版新增的功能，是子类的功能。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"六大设计原则-依赖倒置原则","slug":"六大设计原则-依赖倒置原则","date":"2018-02-04T12:56:20.000Z","updated":"2020-07-05T08:56:51.183Z","comments":false,"path":"2018/02/04/六大设计原则-依赖倒置原则/","link":"","permalink":"http://yoursite.com/2018/02/04/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/","excerpt":"","text":"一.依赖倒置原则介绍 1.依赖倒置原则：针对抽象编程，不要针对实现编程； 英文全称是Dependence Inversion Principle，缩写是DIP 依赖倒置原则则有以下关键点： ___高层模块不应该依赖底层模块，两者都应该依赖其抽象； ___抽象不应该依赖细节。 ___细节应该依赖抽象(抽象类/接口)。 2.生活中的依赖倒置 手机，电池，充电宝：我们生活中的三样物品，它们之间就存在依赖的两种关系。 高层依赖于底层： 手机厂商制作手机的外形，电池是第三方公司制作的，当手机外形设计完毕后，就会根据设计稿，生产对应的电池，相互配套。当手机上市以后，如果手机需要更换电池，这个电池必须是同型号的电池才可以更换。 这种情况就是“高层依赖于底层”=&gt;某型号的手机依赖于某型号的电池。 高层和底层都依赖于抽象： 充电宝本身是依赖于“抽象”，这里的抽象指的就是USB 接口规则。 手机是依赖于该规则生产的，另外充电宝也是按该规则生产，充电宝就可以和任何品牌的手机配套使用，完成充电的功能。 这种情况就是“高层底层都依赖于抽象”=&gt;手机，充电宝都依赖于USB。 3.依赖倒置原则的好处： 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。 二.Unity 引擎依赖倒置 之前早期开发游戏： Android 平台的游戏，需要使用Eclipse 开发，只能运行于Android 平台； IOS 平台的游戏，需要使用XCode 开发，只能运行于IOS 平台； 因为编写这些游戏时，使用的代码，都是各个平台提供的针对性的API。 高层依赖于底层：开发游戏需要依赖于该平台的底层API。 Unity 开发游戏： 使用C#开发一个版本，稍作调整就能发布到N 个平台。 在我们发布成不同平台的游戏的时候，Unity 本身就做了一个“对接”的任务，把我们的代码里面的API，对接到该平台上相应的API。 高层和底层都依赖于抽象：我们的游戏是依赖Unity 的，各个平台的API 也是Unity 完成对接任务的。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"DOTween之Path路径组件","slug":"dotween之path路径组件","date":"2018-02-03T09:21:38.000Z","updated":"2020-07-05T11:23:24.232Z","comments":false,"path":"2018/02/03/dotween之path路径组件/","link":"","permalink":"http://yoursite.com/2018/02/03/dotween%E4%B9%8Bpath%E8%B7%AF%E5%BE%84%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一.Path 组件简介 1.使用Path 路径组件，可以在场景内创建N 个点，由点自动连接成线，然后游戏物体就可以沿这根线，进行路径运动。 Path 路径效果同样也可以用代码实现，但是代码会比较繁琐且麻烦，因为你需要用代码设置每个路径点的位置，操作性很差，所以说路径用Path 组件。 2.组件用途 1.游戏模型路径运动（塔防小怪行走路线，马路上的汽车运动） 2.摄像机运动动画（建筑场景漫游，游戏过场动画，VR 过山车） 其实本质就是事先规划好一个路径，然后让游戏物体在该路径上运动。 二.Path 组件属性 1.Path 路径创建 首先选中需要设置路径的游戏物体，然后给它添加Path 路径组件。 Shift+Ctrl+鼠标左键单击：添加一个新的路径点； Shift+Alt+鼠标左键点击：移除一个路径点； 鼠标左键单击：调整路径点的位置。 2.Tween Options [动画选项] 这一部分属性和Animation 动画控制属性几乎一样。 3.Path Tween Options [路径动画选项] PathType：路径类型，设置路径点的两端是直线还是弧度； ClosePath：关闭路径，模型最终会回到起点位置； PathMode：路径模式，保持默认； Orientation：方向，最常用的是ToPath，模型沿路径正方向移动； LookAhead：0 正方向。这个方向在摄像机漫游动画中很关键，因为你需要沿路径一直看着前方。 4.Path Editor Options [路径编辑选项] Relative：路径相对于模型移动； Color：路径线的颜色； ShowIndexes：显示路径点的位置索引； 5.Extras [额外属性] ResetPath：路径重置； Waypoints：路径点集合，可以在这里对每个点的位置进行精准调节。 Path组件运行效果（gif图）：","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"DOTween之Animation动画组件","slug":"dotween之animation动画组件","date":"2018-02-03T08:11:53.000Z","updated":"2020-07-05T11:23:24.054Z","comments":false,"path":"2018/02/03/dotween之animation动画组件/","link":"","permalink":"http://yoursite.com/2018/02/03/dotween%E4%B9%8Banimation%E5%8A%A8%E7%94%BB%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一.Animation 组件 DoTween Pro 版本将动画控制封装成了两个组件：Animation，Path。 Animation 组件在代码中对应“便捷方式”和“通用方式”；而在项目开发中，一般动画效果，我们直接使用代码方式搞定，而不会选择使用Animation 组件。 Path 组件在代码中也有对应，但是一般Path 效果我们使用组件完成。 原则：一个功能可能有多种实现方式，但是我们选择使用简单且方便的方式。 二.Animation 组件添加 ①选中你需要添加DoTween Animaton 组件的游戏物体； ②Component–&gt;DOTween–&gt;DOTweenAnimation。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18020301-300x300.jpg) 三.组件动画相关属性 通过下拉菜单选择“动画效果”，然后会出现和该动画对应的可控制属性。 Move 动画： Duration：持续时间； Delay：延迟； Ignore TimeScale：忽略时间缩放； Ease：动画曲线； Loops：循环；配套设置循环的类型； TO：目的地；可以设置一个Vector3，也可以指定一个Transform。 四.组件常用事件 OnStart：动画开始事件，执行一次； OnPlay：动画播放事件，执行一次；[先开始，再播放] OnUpdate：动画更新事件，在动画播放的过程中，持续执行N 次； OnComplete：动画播放完成事件，执行一次。 using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening; public class DOTWeenCon : MonoBehaviour { // Use this for initialization void Start () { gameObject.GetComponent&lt;Transform&gt;().DOMove(new Vector3(2, 7, 9), 2) .OnStart&lt;Tween&gt;(() =&gt; Debug.Log(&quot;OnStart开始&quot;)) .OnPlay&lt;Tween&gt;(() =&gt; Debug.Log(&quot;OnPlay播放&quot;)) .OnUpdate&lt;Tween&gt;(() =&gt; Debug.Log(&quot;OnUpdate更新&quot;)) .OnComplete&lt;Tween&gt;(() =&gt; Debug.Log(&quot;OnComplete完成&quot;)); }} 运行结果： [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18020302-300x187.jpg)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"六大设计原则-开放封闭原则","slug":"六大设计原则-开放封闭原则","date":"2018-02-03T04:44:38.000Z","updated":"2020-07-05T08:56:51.176Z","comments":false,"path":"2018/02/03/六大设计原则-开放封闭原则/","link":"","permalink":"http://yoursite.com/2018/02/03/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99/","excerpt":"","text":"一.开放封闭原则介绍 开放封闭原则：软件实体（类，方法，模块）应该可以扩展，但是不可以修改。开放封闭原则简称为开闭原则。 英文全称是Open Close Principle，缩写是OCP 因此，开放封闭原则主要体现在两个方面： 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 二.生活中的开放封闭原则 笔记本电脑：我们购买到的任何品牌的笔记本，都是“开放封闭”的。 封闭：整个笔记本是封闭的，且笔记本背部标明了“非专业人士，请勿试图拆卸或者维修”以及“撕毁保修无效”的封条。 开放：指的是笔记本提供了若干个USB 的插口，可供我们扩展。 简单分析： 笔记本本身具备键盘，触摸板，音响等功能，但是这些往往没有独立的外设好。很多人会选择购买机械键盘，外置鼠标，外置音响，通过USB 插口对笔记本原有的功能进行扩展，这是一种正常的操作习惯，扩展而不是修改。很少有人会在笔记本身上直接进行改动的，比如：把所有的键盘帽翘开，DIY成机械键盘，拆开机器，更换一个更好的音响。如果你真这样做了，是有很大的风险的，风险是你有可能破坏笔记本原有的结构，甚至出现大量的潜在风险。 三.编程中的切入点 面对需求，对程序的改动应该是以增加新代码的方式解决，而不是更改旧的代码。这一点在游戏开发方向尤为重要。 因为游戏开发过程中，需求可能是随时随地都在发生改变，你可能刚写完一个功能模块，这个功能模块的需求就要发生改变。尤其是很多不靠谱的策划，等你改完了，他一看，发现还不如没有修改之前的好，一句话“你还原成之前的效果”。如果你在应对新的需求，新的改变的时候，是修改而不是扩展，那么你的工作量将是巨大的。 Git，SVN 版本控制不可靠，因为这些版本控制是你整个项目的进度，而不是针对性的某一个模块功能的进度。你Git 还原版本，可能其他模块也会一同还原。还有一点需要各位注意：开放封闭原则，其中的封闭不是绝对的封闭。 四.Unity 引擎开闭原则 其实Unity 引擎本身就是开闭原则很好的一个典范。 Unity 官方把这款引擎打包发布出来以后，这个引擎本身程序员是不可以修改的，因为你没有源码—&gt;对修改关闭。但是Unity 引擎提供了一个很强悍的功能，“编辑器扩展功能”，提供了一组完整的API，我们可以通过这组API 对Unity 引擎扩展出N 个插件，以满足我们的特定需求。如果没有这个编辑器扩展功能，Unity 资源商店可能会减少50%的资源，只会是一些素材资源—&gt;对扩展开发。 其实Unity 的成功，很大一部分原因来源于它的“开闭原则”。 对修改关闭，可以保证引擎的稳定性； 而对扩展开放，可以保证程序员开发者能弥补Unity 本身的不足。 比如：NGUI，Shader Forge，Playmaker ……","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"DOTween通用式动画控制","slug":"dotween通用式动画控制","date":"2018-02-01T10:52:57.000Z","updated":"2020-07-05T11:23:25.692Z","comments":false,"path":"2018/02/01/dotween通用式动画控制/","link":"","permalink":"http://yoursite.com/2018/02/01/dotween%E9%80%9A%E7%94%A8%E5%BC%8F%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一.通用式动画定义 DoTween 插件导入unity 项目中，并且在脚本内引入命名空间后。就会出现两种API： 一：“注入”到Unity 原有组件类中的api 方法。 语法格式：组件对象名.DOxxx().Setxxx().Onxxx() [对象.动画().属性().事件回调()]； 这种方式称之为“便捷方式”。 二：DoTween 的一组独立的功能类。 DoTween 工具类中的静态方法，然后使用Lambda 表达式传值的方式，来实现动画控制。 这种方式称之为“通用方式”。 二.通用式动画控制 1.语法格式 DOTween.To(() =&gt; myValue, x =&gt; myValue = x, 100, 1); ___DOTween.To（）： DoTween 插件中功能类的一个静态方法； ___()=&gt;myValue： 获取对象元素Lambda 表达式； ___x=&gt;myValue=x： 赋值对象元素Lambda 表达式； ___100： 最终的目标值； ___1： 动画持续的时间。 虽然说DoTween 提供了两种动画方式：快捷方式，通用方式； 但是从开发的角度而言，快捷方式更好用，更简单直观。由下面的代码对比就可以看出来。 using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.UI; public class DoTweenObject : MonoBehaviour { private Transform cube\\_Transform; private Image m\\_Image; void Start () { cube\\_Transform = GameObject.Find(&quot;Cube&quot;).GetComponent&lt;Transform&gt;(); m\\_Image = GameObject.Find(&quot;Image&quot;).GetComponent&lt;Image&gt;(); //DOTween.To(() =&gt; myValue, x =&gt; myValue = x, 100, 1); /\\* 以下代码每两句一部分，其中上句与下句作用相同，上句是通用式动画控制，下句则是便捷式动画控制。 部分代码功能重复但是并未注释，这里只做演示，理解即可，实际运行切勿复制代码。 实际使用时用一种即可，一般使用便捷式动画控制。 \\*/ //模型位移动画 DOTween.To(() =&gt; cube\\_Transform.position, x =&gt; cube\\_Transform.position = x, new Vector3(3, 5, 3), 2); cube\\_Transform.DOMove(new Vector3(4, 5, 6), 2); //模型缩放动画 DOTween.To(() =&gt; cube\\_Transform.localScale, x =&gt; cube\\_Transform.localScale = x, new Vector3(5, 5, 5), 2); cube\\_Transform.DOScale(5, 2); //图片颜色动画 DOTween.To(() =&gt; m\\_Image.color, x =&gt; m\\_Image.color = x, Color.red, 2); m\\_Image.DOColor(Color.red, 2); //图片透明度动画 DOTween.To(() =&gt; m\\_Image.color, x =&gt; m\\_Image.color = x, new Color(m\\_Image.color.r, m\\_Image.color.g, m\\_Image.color.b, 0.2f), 2); m\\_Image.DOFade(0.5f, 2); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"DOTween便捷式动画控制","slug":"dotween便捷式动画控制","date":"2018-02-01T10:38:32.000Z","updated":"2020-07-05T11:23:24.341Z","comments":false,"path":"2018/02/01/dotween便捷式动画控制/","link":"","permalink":"http://yoursite.com/2018/02/01/dotween%E4%BE%BF%E6%8D%B7%E5%BC%8F%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6/","excerpt":"","text":"DoTween 是一个“动画插件”。 一.DoTween 资源结构 1.资源目录结构 Demigiant [插件的根目录，也是该插件的公司名] ___DemiLib [插件核心类库] ___DOTween [插件基础版资源] ___DOTweenPro [插件专业版资源，在基础版之上扩展出高级功能] ___DOTweenPro Examples [插件专业版实例工程] 2.插件功能菜单 功能组件：Component–&gt; DoTween –&gt;DoTween Animation [基础动画] DoTween Path [路径动画] 备注：这两个动画组件，就是DoTween Pro 内提供的，使用组件控制动画。 设置面板：Tools–&gt;Demigiant–&gt;DoTween Utility Panel [ ](http://www.wjgbaby.com/wp-content/uploads/2018/02/18020101-300x216.jpg) 二.DoTween 基础了解 1.命名空间 当我们需要在代码中使用DoTween 的时候，就需要先导入对应的命名空间： using DG.Tweening; 2.DoTween API 特征 ①当我们引入DoTween 的命名空间后，在代码中就可以使用DoTween 相关的功能类以及方法； ②除了这些功能类以为，DoTween 还会在Unity 本来的功能组件类中“注入”DoTween 的控制方法，这些方法一般都是“DOxxx”。 三.DoTween 元素动画 1.模型动画 1. 模型移动动画：DOMove 方法； 2. 模型旋转动画：DORotate 方法； 3. 模型缩放动画：DOScale 方法。 2.UI 动画 1. 图片颜色动画：DOColor 方法； 2. 图片透明度动画：DOFade 方法； 3. 图片缩放动画：DOScale 方法。 四.DoTween 属性设置 这一组方法的方法名，统一以“Set”开头；可以在上方的动画方法的后面，进行属性的设置。 比如说：SetLoops [设置循环次数] 五.DoTween 事件回调 这一组方法的方法名，统一以“On”开头；可以在上方的动画方法的后面，也可以在属性设置方法的后面，进行事件回调方法的绑定。 比如说：OnComplete [当执行完毕后事件] 六.便捷式动画定义 DoTween 插件导入unity 项目中，并且在脚本内引入命名空间后。就会出现两种API： 一：“注入”到Unity 原有组件类中的api 方法。 语法格式：组件对象名.DOxxx().Setxxx().Onxxx() [对象.动画().属性().事件回调()]； 这种方式称之为“便捷方式”。 二：DoTween 的一组独立的功能类。 DoTween 工具类中的静态方法，然后使用Lambda 表达式传值的方式，来实现动画控制。 这种方式称之为“通用方式”。 演示代码： using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.UI; /* 以下部分代码功能重复但是并未注释， 这里只做演示，理解即可，实际运行切勿复制代码 */ public class DoTweenDemo : MonoBehaviour { private Transform cube\\_Transform; private Image m\\_Image; private RectTransform m\\_RectTransform; void Start () { cube\\_Transform = GameObject.Find(&quot;Cube&quot;).GetComponent&lt;Transform&gt;(); m\\_Image = GameObject.Find(&quot;Image&quot;).GetComponent&lt;Image&gt;(); m\\_RectTransform = GameObject.Find(&quot;Image&quot;).GetComponent&lt;RectTransform&gt;(); CubeAnimation(); UIAnimation(); } /// &lt;summary&gt; /// UI动画. /// &lt;/summary&gt; private void UIAnimation() { //图片颜色动画 m\\_Image.DOColor(Color.green, 5); //图片透明度动画 m\\_Image.DOFade(0.2f, 2); //图片缩放动画 //SetLoops循环次数为2 m\\_RectTransform.DOScale(200, 1).SetLoops(2); //SetLoops循环次数为2，OnComplete事件回调 m\\_RectTransform.DOScale(200, 1).SetLoops(2).OnComplete(()=&gt;Debug.Log(&quot;图片缩放完毕.&quot;)); } /// &lt;summary&gt; /// 模型动画. /// &lt;/summary&gt; private void CubeAnimation() { //DOMove. cube\\_Transform.DOMove(new Vector3(0, 5, 0), 1); cube\\_Transform.DOMoveX(3.5f, 2); //DORotate. cube\\_Transform.DORotate(new Vector3(0, 180, 0), 2); //DOScale. cube\\_Transform.DOScale(3, 1); cube\\_Transform.DOScaleX(20, 2); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"六大设计原则-单一职责原则","slug":"单一职责原则single-responsibility-principle","date":"2018-01-30T10:49:01.000Z","updated":"2020-07-05T11:17:37.205Z","comments":false,"path":"2018/01/30/单一职责原则single-responsibility-principle/","link":"","permalink":"http://yoursite.com/2018/01/30/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99single-responsibility-principle/","excerpt":"","text":"一.单一职责原则简介： 就一个类而言，应该仅有一个引起它变化的原因。简单的说，就是一个类只负责一项职责（功能）。 英文名：Single Responsibility Principle ___含义之一：避免相同的职责（也称为功能）分散到不同的类中实现。 ___含义之二：也应该要避免一个类承担过多的职责，将过多的职责耦合在一个类中导致了脆弱设计。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。 二.单一职责原则分析： 1.一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小。而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 2.类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 3。单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 三.Unity 项目单一职责 1.在Unity 项目开发过程中，有两个切入点： ___类功能的单一性； ___方法功能的单一性； 一个类只负责一件具体的事情，一个方法只完成一个特定的功能。当你发现一方法完成了两件事情的时候，就需要适当的重构成两个方法，类也是一样的。 在一个项目当中，总有一些脚本文件是相对而言比较庞大的，功能是比较复杂的，这些脚本如果你写完之后，不进行代码重构，往往就会比较臃肿，且不会符合单一职责原则。 2.在Unity 引擎内有一组灯光组件，是用于实现灯光照射渲染功能的，它根据不同的功能分割成了4 个组件： 方向光，点光源，聚光灯，区域光 虽然说4 个组件合并为一个，就叫做“灯光组件”，也是可以的，但是会比较臃肿，不方便使用。 3.资源管理 Unity 项目开发过程中，Assets 资源的管理，也是需要准守“单一职责原则”。 ①每一类资源的文件夹分类； ②脚本按功能类别分类。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"XLua框架之基本使用","slug":"xlua框架之基本使用","date":"2018-01-28T10:45:54.000Z","updated":"2020-07-05T11:24:00.956Z","comments":false,"path":"2018/01/28/xlua框架之基本使用/","link":"","permalink":"http://yoursite.com/2018/01/28/xlua%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"XLua 是腾讯开发分享出来的一个开源项目，主要用于Unity 项目的热更新。 Github地址：https://github.com/Tencent/xLua 一.XLua 资源结构 1.Assets 资源 Plugins：XLua 在各个平台运行需要使用到的dll 库文件； XLua：XLua 核心文件夹； ___Doc：教程文档； ___Examples：XLua 官方自带示例工程； ___Resources：资源文件夹； ___Scr：XLua 源码； ___Tutorial：教程示例场景 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18012803-300x113.png) 2.其他资源 build：支持库文件的源码； docs：文档； General：是Tools 工具的源码； Test：测试工程； Tools：工具； WebGLPlugins：webGL 支持库源码； 上面介绍的资源结构是XLua 完整版所有的资源结构； 黑色加粗标示出来的是开发版具备的资源； 项目中使用XLua 只需要将Plugins 和XLua 两个文件夹拷贝到U3D 中即可。 二.XLua 对比ULua 1.组成部分对比 ULua：SimpleFramework &gt; ULua &gt; Lua XLua：XLua &gt; Lua SF：Lua 框架，C#框架，资源的下载更新 2.XLua 的“不足” XLua 只是核心，用于实现Lua 和C#的交互，但是并没有提供便捷的“框架”，也就意味着我们在项目中使用XLua 的话，就需要自己实现框架部分，这样才能实现“从服务器端下载AB 和Lua 资源，完成客户端的热更新”。 三.C#调用Lua 1.C#代码内执行Lua 代码 LuaEnv luaEnv = new LuaEnv();luaEnv.DoString(“print(‘mkcode’)”); 注意事项： ①需要引入XLua 的命名空间：using XLua; ②在XLua 中，运行Lua 代码的虚拟机是LuaEnv； ③一个LuaEnv 实例就是一个Lua 虚拟机，出于开销的考虑，建议全局唯一。 2.C#调用外部的Lua 代码文件 ①在Resources 文件夹下创建一个lua 文件，文件的后缀是txt； XLua 中完整的Lua 文件名格式如下：fileName.lua.txt。 ②然后在C#代码中用Lua 虚拟机的DoString 方法加载执行该lua 文件； luaEnv.DoString(“require ‘fileName’”); 3.C#获取Lua 代码中的数据 luaEnv.Global.Get(“a”); //获取lua 中数值.luaEnv.Global.Get(“b”); //获取lua 中字符串.luaEnv.Global.Get(“c”); //获取lua 中布尔.luaEnv.Global.Get(“D”); //获取lua 中方法. 四.Lua 调用C# CS.UnityEngine.GameObject //获取C#中的类.CS.UnityEngine.Debug.Log() //获取C#中的方法.CS.UnityEngine.GameObject.Find() //获取C#中的方法. 注意事项： Lua 调用C#，需要在C#的命名空间之前要加前缀：“CS.”。","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"EasyTouch之Button,TouchPad","slug":"easytouch之buttontouchpad","date":"2018-01-28T10:45:13.000Z","updated":"2020-07-05T11:23:24.338Z","comments":false,"path":"2018/01/28/easytouch之buttontouchpad/","link":"","permalink":"http://yoursite.com/2018/01/28/easytouch%E4%B9%8Bbuttontouchpad/","excerpt":"","text":"Button按钮 一.Button 介绍 EasyTouch 中的Button 和ugui 中的Button 是非常类似的，因为都是按钮。主要的目的都是“被点击，然后触发相应的逻辑代码”。 创建Button按钮： Hierarchy 右键–&gt; EasyTouch Controls –&gt; Button [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18012801-300x252.png) 二.Button 组件基本属性 1.基本控制属性 这块区域和Joystick 是完全一样的。 2.Position &amp; Size 控制按钮的九宫定位，以及按钮的图片尺寸。 3.Behaviour 用于设置当前按钮的行为，这块区域稍作了解即可，一般情况是用不到这些 General Setting:基本设置。 Direction Action:方向动作；可以指定一个模型，用一些固定的动作操作它们。 Unity Axes:Unity 轴；用于设置当前的按钮对应Input 管理器中的某个轴。 三.Button 组件事件绑定 1.事件名称：OnDown，OnPressed，OnPressedValue，OnUp 事件介绍：当我们在按钮上进行操作的时候，会依次触发这四个事件。 using System.Collections;using System.Collections.Generic;using UnityEngine; public class PlayerButton : MonoBehaviour { private ETCButton m\\_Button; private Animator player\\_Animator; void Start () { player\\_Animator = GameObject.Find(&quot;Player&quot;).GetComponent&lt;Animator&gt;(); m\\_Button = gameObject.GetComponent&lt;ETCButton&gt;(); m\\_Button.onPressed.AddListener(() =&gt; Debug.Log(&quot;onPressed&quot;)); m\\_Button.onDown.AddListener(() =&gt; Debug.Log(&quot;onDown&quot;)); m\\_Button.onUp.AddListener(() =&gt; Debug.Log(&quot;onUp&quot;)); m\\_Button.onPressedValue.AddListener((f) =&gt; Debug.Log(&quot;onPressedValue:&quot; + f)); }} TouchPad触摸板 1.TouchPad 基本使用 TouchPad：触摸板，触摸区域。 创建ToucPad： Hierarchy 右键–&gt; EasyTouch Controls –&gt; TouchPad 2.TouchPad 组件属性与事件 TouchPad 组件和Joystick 组件的属性，90%以上是完全一样的。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18012802-300x282.jpg)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"《平凡的世界》读书笔记","slug":"《平凡的世界》读书笔记","date":"2018-01-24T21:05:57.000Z","updated":"2020-07-05T15:03:27.904Z","comments":false,"path":"2018/01/25/《平凡的世界》读书笔记/","link":"","permalink":"http://yoursite.com/2018/01/25/%E3%80%8A%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.在一个人的思想还没有强大到自己能完全把握自己的时候，就需要在精神上依托另一个比自己更强的人。也许有一天，学生会变成自己老师的老师，这是常常会有的，但人在壮大过程中的每一个阶段，都需要求得当时比自己的认识更高明的指教。 2.人和人之间的友爱，并不在于是否是亲戚。是的，小时候，我们常常把亲戚这两字看得多么美好和重要。一旦长大成人，开始独立生活，我们便很快知道，亲戚关系常常是庸俗的；互相设法沾光，沾不上光就翻白眼；甚至你生活中最大的困难也常常是亲戚们造成的；生活同样会告诉你，亲戚往往不如朋友对你真诚。 3. 社会在变化，生活在变化，人也在变化；没有什么是一成不变的，包括人的关系。 4. 人们！你怎么能因为贫穷，就以物遮目，而变得如此愚蠢呢？ 5. 无论是幸福还是苦难，无论是光荣还是屈辱，让他自己来遭遇和承受吧！ 6. 一个有文化有知识而爱思考的人，一旦失去了自己的精神生活，那痛苦是无法言语的。 7. 只要自己诚心待人，别人也才可能对自己以诚相待 8. 悲剧，其开头往往是喜剧。这喜剧在发展，剧中人喜形于色，沉湎于绚丽的梦幻中，可是突然…… 9. 这样的城市是一个各色人等混杂的天地；而每一个层次的人又有自己的天地。最大的好处是，大街上谁也不认识谁，谁也不关心谁。他衣衫行装虽然破烂不堪，但只要不露羞丑，照样可以在这个世界里自由行走，别人连笑话你的兴趣都没有。 10. 虽然咱们出身低层人家，但不能小看自己。 11. 最艰难的岁月也许过去了，而那贫困中一家人的相亲相爱是不是也要过去了呢？ 12. 连伟人的一生都充满了那么大的艰辛，一个平凡的人吃点苦又算得了什么呢？他一生不可能做出什么惊人业绩，但他要学习伟人们对待生活的态度 13. 通过一段血火般的洗礼，他相信，自己历尽千辛万苦而酿造出的生活之蜜，肯定比轻而易举拿来的更有滋味——他自嘲地把自己的这种认识叫做“关于苦难的学说” 14. 人的感情有时候真是不可思议，他也许对人是冷漠的，但可以对一个动物怀着永远的眷恋。 15. 在我们这个星球上，每天都要发生许多变化，有人倒霉了；有人走运了；有人在创造历史，历史也在成全或抛弃某些人。 16. 今天和昨天似乎没有什么不同；明天也可能和今天一样。也许人一生仅仅有那么一两个辉煌的瞬间，甚至一生都可能在平淡无奇中度过…… 17. 生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，但可以慰藉的是，你总不枉在这世界上活了一场，有了这样的认识，你就会珍重生活，而不会玩世不恭；同时也会给人自身注入一种强大的内在力量…… 18. 落魄的人只要和朋友呆在一块，心里就会踏实下来。 19. 痛苦啊，往往是人走向成熟的最好课程 20. 一个女人如果不喜欢一个男人，那这个男人就左也不是右也不是 21. 什么是男子汉？困难打不倒的人才是真正的男子汉！男子汉不是装出来的，整天绷着脸，皱着眉头，留个大鬓角，穿件黑皮夹克衫，就是男子汉吗？有些男同学就是这么一副样子，但看了就让人发笑。男子汉主要应该是一种内在的品质，而不是靠“化装”和表演就能显示的。 22. 他想：我确是忍受了巨大的痛苦，但痛苦的火焰同时也烧化了痛苦本身，使我在精神上和生活上都进入了一个全新的境界。是的，我曾痛苦过，但因此也得到了了幸福。 23. 我心上的人！无论你怎样反感我，但你应该知道，我一如既往地爱你。尽管你把我抛在一边，但我永远不会改变热爱你的心意！我对你的等待是无望的，但我还要等待下去，哪怕一直等到了我了此残生 24. 爱情啊，有可能是天堂之光，也有可能是地狱之火！但人又不能不去爱！是的，什么也别想阻止爱，不管这爱给人带来的是幸福还是不幸。爱往往是不清醒的。 25. 如果痛苦不能改变生存，那还不如平静地将自己毁灭。 26. 生活包含着更广阔的意义，而不在于我们实际得到了什么；关键是我们的心灵是否充实。对于生活理想，应该象宗教徒对待宗教一样充满虔诚与热情！ 27. 人处在幸福与不幸交织的矛盾之中，反而使内心有一种更为深刻的痛苦，看来近在眼前的幸福而实际上又远得相当渺茫，海市蜃楼。放不得抓不住。一腔难言的滋味。啊，人哪！有时候还不如生活在纯粹的清苦与孤独之中。 28. 贝多芬所说：我要扼住命运的咽喉，它决不会使我完全屈服！ 29. 只有劳动才可能使人在生活中强大。不论什么人，最终还是要崇尚那些能用双手创造生活的劳动者。 30. 在生活中，因为你而使周围的人充满希望和欢乐，这会给你带来多大的满足！ 31. 当一个人集中地凝视着自己的不幸时，他就很难想象别人的苦难。 32. 你可不能沉醉于一种现在还说不来的幻想之中；你必须凝视着你双脚踩踏的土地。 33. 生活中真正的勇士向来默默无闻，喧哗不止的永远是自视高贵的一群。 34. 幸福，或者说生存的价值，并不在于我们从事什么样的工作。在无数艰难困苦之中，又何尝不包含人生的幸福？ 35. 真正的爱情不应该是利己的，而应该是利他的，是心甘情愿地与爱人一起奋斗并不断地自我更新的过程；是溶合在一起——完全溶合在一起的共同斗争！你有没有决心为他（她）而付出自己的最大牺牲，这是衡量是不是真正爱情的标准，否则就是被自己的感情所欺骗 36.生活总是美好的，生命在其间又是如此短促；既然活着，就应该好好地活。思念早逝的亲人，应该更珍惜自己生命的每个时刻。精神上的消沉无异于自杀。象往日一样，正常地投入生活吧！即便是痛苦，也应该看作是人的正常情感；甚至它是组成我们人生幸福的一个不可欠缺的部分呢！ 37.事实上，农村贫富两级正在迅速的拉开距离，这是无法避免的，因为政策允许一部分人先富起来。这也是中国未来长远面临的最大问题，政治家们将要为此而受到严峻的考验。","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"OpenGL笔记六：平移变换","slug":"opengl笔记六：平移变换","date":"2018-01-17T05:27:48.000Z","updated":"2020-07-05T08:56:51.159Z","comments":false,"path":"2018/01/17/opengl笔记六：平移变换/","link":"","permalink":"http://yoursite.com/2018/01/17/opengl%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%9A%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2/","excerpt":"","text":"这篇教程我们来看一看如何在三维场景中对场景中的物体进行各式各样的变换，并且在保持场景的立体感的情况下将其渲染到屏幕上去！常见的方法是用矩阵表示每一个变换, 之后将它们挨个儿相乘,最后乘以顶点位置产生最后的结果！接下来的每一章都将着重介绍一种转变。 我们先来看一个平移变换，平移变换的任务的将一个对象沿着一个任意长度和方向的向量移动，我们假设你想将下图中左边的三角形移到右边的位置：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011701-300x127.png)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011701.png) 要实现这个效果的一个方法就是提供一个偏移向量（上图中是(1,1)）作为一个一致变量传递给着色器，仅仅为每个需要处理的顶点加上这个偏移向量即可。然而,这与我们所想要的将一组矩阵通过相乘得到一个综合矩阵的思想背道而驰。除此之外，在后面的教程中你将看到平移通常并不是第一个变换，所以你得在平移变换前让位置向量乘上代表平移之前的变化矩阵，然后乘上这个平移变换，最后乘上代表平移之后的变换的矩阵。所以说上面的方法太笨拙了。最好的方法是找到一个代表平移的矩阵，让它参与到所有矩阵的乘法运算中。但是你能找到一个矩阵，使得这个矩阵和左图三角形中底部的点（0,0）相乘后得到结果（1,1）吗？事实是你使用 2D 矩阵无法做到这一点，对于（0,0,0）用 3D 矩阵也不能做到这一点！总的来说，我们需要的是一个矩阵 Ｍ，给定一个点 Ｐ 坐标（x,y,z）和一个向量 Ｖ（v1,v2,v3）后，能提供 M*P=P1(x+v1,y+v2,z+v3)。简单的来说就是矩阵 M 将 P 平移到 P+V 的位置。在 P1 中我们可以看到它的每个分量都是来自 P 的一个分量和 V 中与之相对应的分量之和。如果我们将变换矩阵设置为单位矩阵 I，我们会得到如下结果： [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011702-300x155.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011702.jpg)我们想修改这个自身变换矩阵使结果变成这样子： [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011703.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011703.jpg)如果我们坚持用3x3矩阵好像不可能得到想要的结果，但如果改成4x4矩阵我可以这样得到想要的结果：[![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011704-300x133.jpg) 这样使用一个4维向量表示一个3维向量叫做齐次坐标，这在3d图形学中很常用也很有用，第四个分量称作“w”。事实上，我们之前教程中看到的内部shader符号变量gl_Position就是一个4维向量，第四个分量“w”在从3d到2d的投影变换中起着关键作用。通常对于表示点的矩阵会让w=1，而对于表示向量的矩阵会让w=0，因为点可以被做变换而向量不可以，你可以改变一个向量的长度和方向，但是长度和方向一样的所有向量都是相等的，不管他们的起点在哪里，所以我们可以把所有的向量起点放到原点来看。对于向量设置w=0然后乘以变换矩阵会得到和自身一样的向量。 1. structMatrix4f { float m[4][4]; };我们将一个 4*4 的矩阵定义添加到 math_3d.h 中。从现在起，它将被运用到大多数转变矩阵中。 2. GLuintgWorldLocation;我们使用这个句柄来获取着色器中的世界矩阵一致变量地址！我们称之为“世界”是因为我们所做的是，在我们的虚拟世界坐标系统中将一个物体移动（变换）到我们想要的位置。 3. Matrix4fWorld; World.m[0][0] = 1.0f; World.m[0][1] =0.0f; World.m[0][2] = 0.0f; World.m[0][3] = sinf(Scale); World.m[1][0] = 0.0f; World.m[1][1] =1.0f; World.m[1][2] = 0.0f; World.m[1][3] = 0.0f; World.m[2][0] = 0.0f; World.m[2][1] =0.0f; World.m[2][2] = 1.0f; World.m[2][3] = 0.0f; World.m[3][0] = 0.0f; World.m[3][1] =0.0f; World.m[3][2] = 0.0f; World.m[3][3] = 1.0f;在渲染函数中，我们创建了一个 4*4 矩阵并根据上面的推导对其进行初始化！我们设置 v2 和 v3 为 0，因为我们希望物体在 y、z 坐标上没有变化，我们将 v1 的值设置为 sin 函数的结果，Scale的值在每一帧中都是不断变化的，这使得 X 坐标的值会在 -1 到 1 的范围内波动。现在我们需要把矩阵加载到着色器中。 4. glUniformMatrix4fv(gWorldLocation,1, GL_TRUE, &amp;World.m[0][0]);这是另外一个 glUniform _函数的例子，用来加载数据到着色器的一致变量中。这个特定的函数可以加载 4*4 的矩阵，也有用于加载 2*2, 3*3, 3*2, 2*4, 4*2, 3*4 和 4\\_3的版本。第一个参数是一致变量的位置（在着色器程序编译之后由 glGetUniformLocation() 函数返回的结果）。第二个参数代表我们更新的矩阵的数量。一个矩阵我们用 1，但是我们也可以调用这个函数一次更新多个矩阵。第三个参数很容易迷惑新手。它表明提供矩阵是按行优先还是列优先的! 关键在于 C/C++ 语言默认就是行优先的！这意味着当你给二维数组填充数据时，它们在内存中一行一行的排列，并且最上面的一行在低地址处！例如，看下面的数组： int a[2][3]; a[0][0]= 1; a[0][1]= 2; a[0][2]= 3; a[1][0]= 4; a[1][1]= 5; a[1][2]= 6;直观看来上这个数组看起来像下面的矩阵： 1 2 3 4 5 6而在内存中的排列是这样的：1 2 3 4 5 6（1在最低地址） 所以我们设定函数 glUniformMatrix4fv() 第三个参数是 GL_TRUE 是因为我们以行优先的方式提供矩阵的。我们也可以将第三个参数为 GL_FALSE，但是这样的话我们需要转置矩阵的值，因为 C/C++ 中内存的排列仍然是行优先，但是 OpenGL 将认为我们提供的前四个值实际上是一个矩阵的列，并做相应处理。第四个参数是矩阵在内存的开始地址！ 5. 在着色器中的其余代码 Uniform mat4 gWorld;这是一个 4*4 的矩阵类型的一致变量。也有 mat2 和 mat3。 6. gl_Position= gWorld * vec4(Position, 1.0);我们添加到顶点缓冲区中的三角形顶点的位置属性是一个三维向量，但是之前我们知道对于一个点，其 W 分量应该为 1。所以这里有两种选择： 将填充到缓冲区中的顶点属性都改为四维向量； 或者在顶点着色器中增加第四部分。 第一个选择没有优势，因为每个顶点位置属性需要消耗额外的四字节内存，但是我们知道那部分的内容一直是 1。较之而言，在VBO中维持三个分量的点，之后在着色器中为其添加第四个分量的方法就高效很多。在GLSL中通过使用 ‘vec4(Position, 1.0)’ 完成这个扩充。我们将矩阵与这个顶点向量相乘，最后将其结果传入 gl_Position 中。总之本例中，每一帧我们都生成一个变换矩阵使得对象沿着 X 轴平移，并且这个平移的距离在[-1,1]之间波动。着色器将每个顶点的位置与此矩阵相乘，结果使物体左右移动。在大多数情况下，在顶点着色器完成处理后，三角形的一边会超出规范化空间，这时候裁剪器将把超出的那部分裁剪掉。这样我们就只能看到位于规范化空间内部的部分。 项目代码： #include &lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;GL/glew.h&gt;#include &lt;GL/freeglut.h&gt;#include “ogldev_math_3d.h” //用于OpenGL的3d数学库#include “ogldev_util.h” //用于读取文本文件 GLuint VBO; //全局GLuint引用变量，来操作顶点缓冲器对象GLuint gWorldLocation; // 平移变换一致变量的句柄引用 // 定义要读取的顶点着色器脚本和片断着色器脚本的文件名，作为文件读取路径const char* pVSFileName = “shader.vs”;const char* pFSFileName = “shader.fs”; static void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空颜色缓存 static float Scale = 0.0f; //维护一个不断慢慢增大的静态浮点数 Scale += 0.001f; //如果图像变化太快或者太慢，可调节此数值 // 4x4的平移变换矩阵 Matrix4f World; World.m\\[0\\]\\[0\\] = 1.0f; World.m\\[0\\]\\[1\\] = 0.0f; World.m\\[0\\]\\[2\\] = 0.0f; World.m\\[0\\]\\[3\\] = sinf(Scale); World.m\\[1\\]\\[0\\] = 0.0f; World.m\\[1\\]\\[1\\] = 1.0f; World.m\\[1\\]\\[2\\] = 0.0f; World.m\\[1\\]\\[3\\] = 0.0f; World.m\\[2\\]\\[0\\] = 0.0f; World.m\\[2\\]\\[1\\] = 0.0f; World.m\\[2\\]\\[2\\] = 1.0f; World.m\\[2\\]\\[3\\] = 0.0f; World.m\\[3\\]\\[0\\] = 0.0f; World.m\\[3\\]\\[1\\] = 0.0f; World.m\\[3\\]\\[2\\] = 0.0f; World.m\\[3\\]\\[3\\] = 1.0f; // 将矩阵数据加载到shader中 glUniformMatrix4fv(gWorldLocation, 1, GL\\_TRUE, &amp;World.m\\[0\\]\\[0\\]); glEnableVertexAttribArray(0); //开启顶点属性 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, 0); //管线解析bufer中的数据 glDrawArrays(GL\\_TRIANGLES, 0, 3); //画三角形，3个顶点 glDisableVertexAttribArray(0); //禁用顶点数据 glutSwapBuffers(); //交换前后缓存} static void InitializeGlutCallbacks(){ glutDisplayFunc(RenderCallBack); glutIdleFunc(RenderCallBack); //将渲染回调注册为全局闲置回调} static void CreateVertexBuffer(){ Vector3f Vertices[3]; //创建含有3个顶点的顶点数组 Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f); Vertices[1] = Vector3f(1.0f, -1.0f, 0.0f); Vertices[2] = Vector3f(0.0f, 1.0f, 0.0f); glGenBuffers(1, &amp;VBO); //创建缓冲器 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(Vertices), Vertices, GL\\_STATIC\\_DRAW); //绑定顶点数据} //使用shader文本编译shader对象，并绑定shader到着色器程序中static void AddShader(GLuint ShaderProgram, const char* pShaderText, GLenum ShaderType){ // 根据shader类型参数定义两个shader对象 GLuint ShaderObj = glCreateShader(ShaderType); // 检查是否定义成功 if (ShaderObj == 0) { fprintf(stderr, “Error creating shader type %d\\n”, ShaderType); exit(0); } // 定义shader的代码源 const GLchar\\* p\\[1\\]; p\\[0\\] = pShaderText; GLint Lengths\\[1\\]; Lengths\\[0\\] = strlen(pShaderText); glShaderSource(ShaderObj, 1, p, Lengths); glCompileShader(ShaderObj); // 编译shader对象 // 检查和shader相关的错误 GLint success; glGetShaderiv(ShaderObj, GL\\_COMPILE\\_STATUS, &amp;success); if (!success) { GLchar InfoLog\\[1024\\]; glGetShaderInfoLog(ShaderObj, 1024, NULL, InfoLog); fprintf(stderr, &quot;Error compiling shader type %d: &apos;%s&apos;\\\\n&quot;, ShaderType, InfoLog); exit(1); } // 将编译好的shader对象绑定到program object程序对象上 glAttachShader(ShaderProgram, ShaderObj);} // 编译着色器函数static void CompileShaders(){ // 创建着色器程序 GLuint ShaderProgram = glCreateProgram(); // 检查是否创建成功 if (ShaderProgram == 0) { fprintf(stderr, “Error creating shader program\\n”); exit(1); } // 存储着色器文本的字符串缓冲 string vs, fs; // 分别读取着色器文件中的文本到字符串缓冲区 if (!ReadFile(pVSFileName, vs)) { exit(1); }; if (!ReadFile(pFSFileName, fs)) { exit(1); }; // 添加顶点着色器和片段着色器 AddShader(ShaderProgram, vs.c\\_str(), GL\\_VERTEX\\_SHADER); AddShader(ShaderProgram, fs.c\\_str(), GL\\_FRAGMENT\\_SHADER); // 链接shader着色器程序，并检查程序相关错误 GLint Success = 0; GLchar ErrorLog\\[1024\\] = { 0 }; glLinkProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_LINK\\_STATUS, &amp;Success); if (Success == 0) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Error linking shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 检查验证在当前的管线状态程序是否可以被执行 glValidateProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_VALIDATE\\_STATUS, &amp;Success); if (!Success) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Invalid shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 设置到管线声明中来使用上面成功建立的shader程序 glUseProgram(ShaderProgram); // 查询获取一致变量的位置 gWorldLocation = glGetUniformLocation(ShaderProgram, &quot;gWorld&quot;); assert(gWorldLocation != 0xFFFFFFFF); // 检查错误} int main(int argc, char** argv){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); glutInitWindowSize(400, 400); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;平移变换&quot;); glutDisplayFunc(RenderCallBack); //开始渲染 InitializeGlutCallbacks(); // 检查GLEW是否就绪，必须要在GLUT初始化之后！ GLenum res = glewInit(); if (res != GLEW\\_OK) { fprintf(stderr, &quot;Error: &apos;%s&apos;\\\\n&quot;, glewGetErrorString(res)); return 1; } glClearColor(0.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 CreateVertexBuffer(); //创建顶点缓冲器 CompileShaders(); // 编译着色器 glutMainLoop(); //通知开始GLUT的内部循环 return 0;} 片断着色器shader.fs脚本代码: #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 out vec4 FragColor; // 片段着色器的输出颜色变量 // 着色器的唯一入口函数void main(){ // 定义输出颜色值 FragColor = vec4(1.0, 0.0, 0.0, 1.0);} 顶点着色器shader.vs脚本代码： #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 // 绑定定点属性名和属性，方式二缓冲属性和shader属性对应映射layout (location = 0) in vec3 Position; // 平移变换聚矩阵一致变量uniform mat4 gWorld; void main(){ // 用平移变换矩阵乘以图形顶点位置对应的4X4矩阵相乘，完成平移变换 gl_Position = gWorld * vec4(Position, 1.0);} 运行效果（gif图）： 参考链接： http://ogldev.atspace.co.uk/www/tutorial06/tutorial06.html https://jiangxh1992.github.io/articles/2016-09/openglstepbystep6","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"EasyTouch之Joystick虚拟摇杆","slug":"easytouch之joystick虚拟摇杆","date":"2018-01-10T17:56:34.000Z","updated":"2020-07-05T11:23:24.054Z","comments":false,"path":"2018/01/11/easytouch之joystick虚拟摇杆/","link":"","permalink":"http://yoursite.com/2018/01/11/easytouch%E4%B9%8Bjoystick%E8%99%9A%E6%8B%9F%E6%91%87%E6%9D%86/","excerpt":"","text":"一.EasyTouch 资源结构 EasyTouchBundle [插件的根目录] |—EasyTouch [插件核心，核心功能的实现，偏向底层] |—EasyTouchControls [插件控制器，高级功能效果，偏向具体应用] |—Install [PlayMaker 可视化开发环境的支持库] |—Readme.txt [插件的版本更新信息] 二.Joystick虚拟摇杆 1.Joystick 介绍 Joystick：操纵杆，虚拟摇杆；EasyTouch 插件中最关键最核心的一个功能。 2.创建Joystick 游戏物体 Hierarchy 右键–&gt; EasyTouch Controls –&gt; Joystick 点击创建Joystick 游戏物体后，EasyTouch 会自动创建一个UGUI 的渲染环境，另外场景中还会出现一个InputManager 游戏物体。 3.Joystick 组成分析 ECTJoystick Image [ 虚拟摇杆功能组件，虚拟摇杆的背景图] |—- Image [ 虚拟摇杆的操纵钮] ECTJoystick 位置：EasyTouchControls/Plugins/ETCJoystick.cs 三.Joystick组件属性 1.基本属性 JoystickName：虚拟摇杆游戏物体的名字； Activated：虚拟摇杆是否激活可用； Visible：虚拟摇杆是否可见； UseFixedUpdate：使用FixedUpdate 函数更新摇杆信息； Unregister at disabling time：注销时禁用虚拟摇杆； 2.Position&amp;Size [位置和大小] 这一组属性用于控制Joystick 的位置和大小，Joystick 的锚点定位不需要操作RectTransform 组件，而是控制该区域的属性。 3.Axes Properties [轴向属性] 虚拟摇杆本质还是键盘上的WASD 方向键的原理，两个轴向的数据获取。 该属性区域就是控制横轴，纵轴相关细节属性的；一般情况下保持默认即可。 4.Sprites [摇杆图片] 用于选择Joystick 所需要使用到的图片资源，该区域的修改，会直接影响Image组件上的图片属性。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18011101-235x300.jpg) 四.Joystick 组件事件绑定 1.Move Events [移动事件] OnMoveStart，OnMove，OnMoveSpeed，OnMoveEnd 在移动虚拟摇杆操纵钮的时候，在移动过程中逐步触发对应的事件。 2.Touch Events [触摸事件] OnTouchStart，OnTouchUp 操纵钮的开始操作和操作结束，各执行一次事件。 3.Down Events [方向事件] OnDownUp，OnDownRight，OnDownDown，OnDownLeft 当我们按下虚拟摇杆操纵钮移动到上下左右最终位置时，触发一次。 4.Press Events [按下事件] OnPressUp，OnPressRight，OnPressDown，OnPressLeft 当我们按下虚拟摇杆操纵钮移动到上下左右最终位置时，则会一直触发。 五.Joystick 控制移动 1.Joystick 控制普通模型移动 使用Joystick 组件身上“onMoveSpeed(Vecot2)”事件来获取轴向的值： 测试：Joystick 默认两个轴向的取值范围。 ①：Transform 组件位移 使用Transform 组件的Translate(向量)方法来实现位移。 ②：Rigidbody 组件位移 使用Rigidbody 组件的MovePosition（当前位置+ 向量）方法来实现位移。 2.Joystick 控制人形动画 ①使用onMoveStart 和onMoveEnd 控制动画的播放与停止； ②使用onMoveSpeed 控制角色控制器的位移。 Cube方块和三维角色使用Joystick 移动代码： using System.Collections;using System.Collections.Generic;using UnityEngine; public class PlayerJoystick : MonoBehaviour { private ETCJoystick m\\_Joystick; //CUBE方块. private Transform cube\\_Transform; private Rigidbody cube\\_Rigidbody; //MODEL带动画的角色模型. private Animator m\\_Animator; private CharacterController m\\_CC; private Transform m\\_Transform; void Start () { m\\_Joystick = gameObject.GetComponent&lt;ETCJoystick&gt;(); cube\\_Transform = GameObject.Find(&quot;Player&quot;).GetComponent&lt;Transform&gt;(); cube\\_Rigidbody = GameObject.Find(&quot;Player&quot;).GetComponent&lt;Rigidbody&gt;(); m\\_Animator = GameObject.Find(&quot;RoyalKnight&quot;).GetComponent&lt;Animator&gt;(); m\\_CC = GameObject.Find(&quot;RoyalKnight&quot;).GetComponent&lt;CharacterController&gt;(); m\\_Transform = GameObject.Find(&quot;RoyalKnight&quot;).GetComponent&lt;Transform&gt;(); m\\_Joystick.onMoveSpeed.AddListener(OnMoveSpeed); m\\_Joystick.onMoveStart.AddListener(OnMoveStart); m\\_Joystick.onMoveEnd.AddListener(OnMoveEnd); } private void OnMoveStart() { m\\_Animator.SetBool(&quot;walk&quot;, true); } private void OnMoveEnd() { m\\_Animator.SetBool(&quot;walk&quot;, false); } private void OnMoveSpeed(Vector2 v2) { Debug.Log(v2); Vector3 dir = new Vector3(v2.x, 0, v2.y) \\* 0.5f; cube\\_Transform.Translate(dir); //Transform组件位移Cube. cube\\_Rigidbody.MovePosition(cube\\_Transform.position + dir); //刚体组件位移Cube. m\\_CC.SimpleMove(dir \\* 10); m\\_Transform.LookAt(m\\_Transform.position + dir); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"Unity操作JSON","slug":"unity操作json","date":"2018-01-08T17:57:21.000Z","updated":"2020-07-05T11:21:43.027Z","comments":false,"path":"2018/01/09/unity操作json/","link":"","permalink":"http://yoursite.com/2018/01/09/unity%E6%93%8D%E4%BD%9Cjson/","excerpt":"","text":"一. Unity 使用JSON 在Unity 项目开发过程中经常会用到一些第三方的DLL 文件。比如我们现在想在Unity 项目内操作JSON，就需要导入一个叫做“LitJson.dll”的库文件。 操作步骤如下： ①Unity 项目内创建一个Plugins 文件夹； ②dll 文件拖拽到该文件夹下； ③在需要使用该dll 的脚本文件内，使用using 命令引入dll 对应的命名空间。 Bug：LitJson.dll 不支持float 类型的数据，在实际项目中要注意这一点。可以用double代替float，但是double的精确度太高，我们并不需要太高的精度。所以可以用string存储数据，然后把数据保留为两位小数。 二. 对象转换为Json 字符串 JsonMapper.ToJson(object) 可以将任何的对象转换为Json 数据字符串。 三. Json 字符串转换为对象 JsonMapper.ToObject(jsonStr) 可以将Json 格式的字符串转换为指定的泛型对象。 四. JSON 转多个对象 这种方式其实是我们使用频率最高的一种方式。 比如说： ①服务器端发送数据给客户端，肯定是一个很长的JSON 字符串，里面有N 个对象数据，我们需要把它转换成多个对象，放到List内进行管理和使用； ②读取本地的JSON 文本，得到一个很长的JSON 字符串，同样也需要转换为多个对象后才能使用。 语法格式： JsonData jsonData = JsonMapper.ToObject(jsonStr); ToObject 方法的非泛型格式，返回JsonData 格式对象。 JsonData 其实就是一个数组格式。 jsonData.Count：可以得到这个数组的元素个数； jsonData[i].ToJson()：可以把JsonData 数据对象转换为Json； 五. JsonData 创建JSON 在我们日常开发中，大部分情况是直接使用“数据对象”直接转换为JSON 字符串格式；但是有些时候，我们也可以直接构造JsonData 对象，来创建JSON字符串数据。 语法格式： JsonData jd = new JsonData(); //创建JsonData 数据对象. jd[“key”] = “value”; //添加数据. jd.ToJson(); //对象转换为Json 字符串. 六.IO 持久化JSON 数据 1.文本路径 定义一个文本文件的路径，路径指向Resources 文件夹下。 2.IO 操作数据 使用StreamWriter 类将Json 字符串写入到文本文件中。 StreamWriter sw = new StreamWriter(path); sw.Write(jsonStr); sw.Close(); 3.加载JSON 数据文件 使用Resources.Load 方法加载txt 文本文件，在Unity 环境内，txt 文本文件对应的数据类型是TextAsset。","categories":[],"tags":[{"name":"XML/JSON","slug":"XML-JSON","permalink":"http://yoursite.com/tags/XML-JSON/"}]},{"title":"JSON简介","slug":"json简介","date":"2018-01-08T17:41:43.000Z","updated":"2020-07-05T11:21:44.281Z","comments":false,"path":"2018/01/09/json简介/","link":"","permalink":"http://yoursite.com/2018/01/09/json%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一. JSON 简介 Json：JavaScript Object Notation [JS 对象表示法] ①Json 和XML 是比较类似的技术，都是可以用来存储文本信息数据的；但是相对而言，Json 比XML 的体积更小巧，但是易读性不如XML。 ②Json 是轻量级的文本数据交换格式，可以用于服务器和客户端之间的数据传输的载体；XML 也是可以完成这个任务的。 ③Json 和XML 一样，并不是哪一门语言的专属技术，而是通用的，几乎所有的编程语言都可以操作和使用Json，XML 相关的数据文件。 ④Json 作为一种语法格式，最早出现在Web 开发领域，由于Json 优点众多，于是才被大部分语言所支持，其实软件开发领域很多技术都是这样来的。 二. JSON 用途 数据存储： 文本文件形式存在于客户端，作为静态数据源使用 数据传输： 服务器与客户端沟通，传输数据使用；比如你登录了手游，客户端就会向服务器发起各种请求，例如获取自己账号的背包中的物品数据信息，这些信息服务器端会以Json 数据的格式传输给客户端，然后客户端解析后进行使用。 三. JSON 语法格式 [ { “Name”:”WWW”, “Age”:100, “Address”:”BeiJing” }, { “Name”:”AAA”, “Age”:2, “Address”:”ShanDong” }] 语法注意事项： ①当有多个数据对象时,最外层用[]包裹，表示是一个数组； ②每一对{}都表示一个独立的数据对象； ③Json 对象内的数据，是以键值对的形式存在的； ④Json 中字符串需要用“”包裹； ⑤Json 中需要用逗号进行数据分割，且“最后的位置”不需要写逗号。","categories":[],"tags":[{"name":"XML/JSON","slug":"XML-JSON","permalink":"http://yoursite.com/tags/XML-JSON/"}]},{"title":"UGUI之Anchors锚点弹性定位","slug":"ugui之anchors锚点弹性定位","date":"2018-01-07T10:33:27.000Z","updated":"2020-07-05T11:23:24.121Z","comments":false,"path":"2018/01/07/ugui之anchors锚点弹性定位/","link":"","permalink":"http://yoursite.com/2018/01/07/ugui%E4%B9%8Banchors%E9%94%9A%E7%82%B9%E5%BC%B9%E6%80%A7%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"Anchor Presets 面板如下： 弹性定位是相对于九宫定位而言的，九宫定位是相对于一个锚点进行定位；而弹性定位是相对于两个锚点进行定位。 而且当我们使用弹性定位的时候，RectTransform 上的控制属性会发生相应的改变（x 位置，y 位置，宽，高）。 调节锚点弹性定位方式，调节Pivot，调节Left,Right,Height,Pos X,Pos Y,Top,Bottom这些属性，如下图所示： 上面横着的图片： 最右面竖着的图片： 锚点定位方式调节成四个角： 改变分辨率后，布局仍然不会乱。 RectTransform 面板上有一组Anchors 属性，该属性位置有四个控制项，分别对应x 轴和y 轴的最大值最小值。 通过这个位置的属性配合Anchors 锚点设置面板，可以让锚点定位效果变的更丰富和细致。当我们点击了不同的定位功能按钮后，该区域的值都会自动改变。 其实该区域的四个值对应的就是锚点上四个空心三角形的位置。 实例： 做一个Image，命名为01： 复制01，并改名为02，改变Min中的两个x的值，调节间距，注意锚点的位置变化：","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之Anchors锚点九宫定位","slug":"ugui之anchors锚点九宫定位","date":"2018-01-07T10:18:24.000Z","updated":"2020-07-05T11:23:24.054Z","comments":false,"path":"2018/01/07/ugui之anchors锚点九宫定位/","link":"","permalink":"http://yoursite.com/2018/01/07/ugui%E4%B9%8Banchors%E9%94%9A%E7%82%B9%E4%B9%9D%E5%AE%AB%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"Anchor Presets 面板如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010710-300x152.png)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010710.png) UGUI三个常用的图标： **UI 尺寸调节图标**：UI 游戏物体的四个角上的蓝色圆圈。 **UI 中心点图标**：蓝色空心圆环，默认在UI 游戏物体的中心，由Pivot控制Pivot 属性用于表示UI 游戏物体的中心点，当改变了UI 游戏物体的Pivot 属性后，UI 游戏物体的Pos 属性也会跟随发生改变。 **锚点定位图标：**四个白色空心三角形，默认四个三角形顶点相对。 **九宫定位：** 九宫定位就是把UI 游戏物体按九宫布局的方式进行定位，设置完毕九宫定位后，无论屏幕尺寸比例如何改变，UI 游戏物体的位置永远在九宫位置。 像下图中一样摆好九张Image，依次调节锚点定位方式，Pivot属性，Pos X，Pos Y [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010701-300x173.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010701.jpg) 改变分辨率，九张图的布局并没有乱[![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010703-300x188.png)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010703.png)改成竖版的,还是没有乱： [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010702-300x196.png)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010702.png) 下面这张图展示了父子层级关系，儿子的位置永远都在父亲的相对位置上，从不会改变 [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010704-300x162.png) 细节注意事项： ①每一个UI 游戏物体都有自己独立的一个锚点； ②子物体的锚点位置是相对于父物体而言的； ③游戏物体的中心点和锚点之间的位置偏移，其实就是一个笛卡尔二维坐标系。","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"长夜漫漫，无心睡眠","slug":"长夜漫漫，无心睡眠","date":"2018-01-05T18:12:01.000Z","updated":"2020-07-05T15:03:27.921Z","comments":false,"path":"2018/01/06/长夜漫漫，无心睡眠/","link":"","permalink":"http://yoursite.com/2018/01/06/%E9%95%BF%E5%A4%9C%E6%BC%AB%E6%BC%AB%EF%BC%8C%E6%97%A0%E5%BF%83%E7%9D%A1%E7%9C%A0/","excerpt":"","text":"大三已经过半 我却总有一种与时间赛跑的感觉 心智愈加的成熟 会经常思考一些事情背后的意义 犯了一些错，但是没关系 或许该去找朋友们谈谈 但他们此刻真的不懂我的感受。 老朋友不懂你的新境况 新朋友不懂你的老毛病 只有你自己最了解你自己。 我认识一些令高山仰止的先生，我向他们虚心学习 也见过痞子的模样，我对他们见而远之。 保持一个良好的心态很重要，我一直对自己说”平常心，平常心” 或许我应该去学些哲学 但是怕难以理解其中奥秘 走火入魔更是得不偿失 我前段时间写过一篇控制时间和空间平衡的文章 很遗憾，我还是做不好 难不难，太难了。 整个社会高速发展，世界也正在变得越来越复杂 数据越来越多，你的那点隐私早就全没了 事情的复杂程度超出人们的想象 每个人扮演的角色看上去都很重要 但是看上去又貌似没那么重要。 我们每天要处理的信息太多 以至于你一天不看你的社交软件都会感觉错失了什么。 这是一个很看重个人价值的时代 如果你真的是金子，就一定会发光。 这也是一个需要你不断学习的时代 许多工作很快就会被人工智能和机器学习去替代 快去学习新知识吧 活到老，学到老。人类的悲欢并不相通 大多数人太过吵闹。 人生如逆旅， 我亦是行人。 ——2018.01.06.02.12","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"Matlab实时人脸识别与追踪","slug":"matlab实时人脸识别与追踪","date":"2018-01-04T13:38:19.000Z","updated":"2020-07-05T08:56:51.143Z","comments":false,"path":"2018/01/04/matlab实时人脸识别与追踪/","link":"","permalink":"http://yoursite.com/2018/01/04/matlab%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E4%B8%8E%E8%BF%BD%E8%B8%AA/","excerpt":"","text":"这是我的Matlab大作业，实时人脸识别与追踪，主要运用了Matlab计算机视觉工具箱，维奥拉-琼斯算法，KTL算法。 直接运行代码会出现”错误使用webcam，尚未安装MATLAB Support Package for USB Webcams。打开Support Package Installer即可安装Webcam Support Package”这个错误。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010403-300x21.png) 这是因为我们实时的调取笔记本上的摄像头来进行每一帧图像的检测，所以需要用到webcam摄像头。 首先点击Support Package Installer安装Webcam Support Package，然后会有几个选项都选Next，最后有个Log In，登陆你的Matlab账号，然后直接运行就行了。 完整代码以及注释： %使用KLT算法的3个前提假设： %亮度恒定 %时间连续或者是运动是“小运动” %空间一致，临近点有相似运动，保持相邻 clc,clear,close all;%创建人脸检测对象，后面捕捉我英俊的脸庞，调用CascadeObjectDetector.m，使用了维奥拉-琼斯算法faceDetector = vision.CascadeObjectDetector(); %使用点跟踪器进行视频稳定、摄像机运动估计和目标跟踪，它特别适合跟踪不改变形状的对象和显示视觉纹理的对象%2表示对可能出现的错误进行双向限制，即使存在噪声也能正确显示pointTracker = vision.PointTracker(‘MaxBidirectionalError’, 2); %创建摄像头对象cam = webcam(); %获取当前图像帧和其大小，如果一直执行，则每次返回最新的一帧videoFrame = snapshot(cam);frameSize = size(videoFrame); %创建播放视频对象videoPlayer = vision.VideoPlayer(‘Position’, [100 100 [frameSize(2), frameSize(1)]+30]); runLoop = true; %默认开启循环numPts = 0; %特征点初始为0frameCount = 0; %帧数初始为0 %当runLoop为真并且帧数小于1000时，开启循环while runLoop &amp;&amp; frameCount &lt; 1000 %获取当前图像帧，如果一直执行，则每次返回最新的一帧 videoFrame = snapshot(cam); %处理成灰度图像 videoFrameGray = rgb2gray(videoFrame); %每循环一次帧数就加1 frameCount = frameCount + 1; if numPts &lt; 10 %检测方式，bbox是1\\*4向量，分布表示\\[x y width height\\]，即边界框的左上角像素点坐标和边界框的size bbox = faceDetector.step(videoFrameGray); if ~isempty(bbox) %在脸部区域识别特征点，指定被保留特征值的最小值,一般为1 points = detectMinEigenFeatures(videoFrameGray, &apos;ROI&apos;, bbox(1, :)); %用初始化框架的点的位置初始化踪迹 xyPoints = points.Location; numPts = size(xyPoints,1); release(pointTracker); initialize(pointTracker, xyPoints, videoFrameGray); %复制点用于之前的点和现在的框架之间进行几何转换 oldPoints = xyPoints; %将框架转化为一系列的4个点\\[x1 y1 x2 y2 x3 y3 x4 y4\\] ，即使被识别的脸发生旋转也能够被看到 bboxPoints = bbox2points(bbox(1, :)); %reshape表示重新调整矩阵的行数、列数、维数 bboxPolygon = reshape(bboxPoints&apos;, 1, \\[\\]); % 在被检测的脸的周围插入边界框 videoFrame = insertShape(videoFrame, &apos;Polygon&apos;, bboxPolygon, &apos;LineWidth&apos;, 3); % 显示被追随的点，在图像或视频中插入标记符号 videoFrame = insertMarker(videoFrame, xyPoints, &apos;+&apos;, &apos;Color&apos;, &apos;white&apos;); end else %检测点的踪迹，注意有一些点可能丢失 %xyPoints是xx \\* 2数组，xx表示特征点数目，xyPoints是所有特征的的坐标 %isFound是xx \\* 1数组，表示特征点是否有track ok。ok是1，否则为0 \\[xyPoints, isFound\\] = step(pointTracker, videoFrameGray); visiblePoints = xyPoints(isFound, :); oldInliers = oldPoints(isFound, :); numPts = size(visiblePoints, 1); if numPts &gt;= 10 %在之前的点和新的点之间进行几何转换并建立边界线 \\[xform, oldInliers, visiblePoints\\] = estimateGeometricTransform(... oldInliers, visiblePoints, &apos;similarity&apos;, &apos;MaxDistance&apos;, 4); %运行边界点的转换 bboxPoints = transformPointsForward(xform, bboxPoints); %reshape表示重新调整矩阵的行数、列数、维数 bboxPolygon = reshape(bboxPoints&apos;, 1, \\[\\]); % 在被追随的物体周围插入边界框 videoFrame = insertShape(videoFrame, &apos;Polygon&apos;, bboxPolygon, &apos;LineWidth&apos;, 3); % 显示被追随的点，在图像或视频中插入标记 videoFrame = insertMarker(videoFrame, visiblePoints, &apos;+&apos;, &apos;Color&apos;, &apos;green&apos;); %重置点 oldPoints = visiblePoints; %设置跟随点，很多点在跟踪过程中丢失后，用于点的重新检测 setPoints(pointTracker, oldPoints); end end %使用视频播放器对象显示被注释的视频帧 step(videoPlayer, videoFrame); %检测视频播放窗口是否已经关闭 runLoop = isOpen(videoPlayer);end %清空clear cam;release(videoPlayer);release(pointTracker);release(faceDetector); 运行效果如下，这只是一张截图，没有录屏，建议自己动手实现一下啊。 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010402-300x229.jpg) 在项目运行中，你可以对着笔记本的摄像头扭动你的头部和大幅度移动，以及改变你身边的灯光环境，观察其它效果。","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"2017年我都听了些什么","slug":"2017年我都听了些什么","date":"2018-01-03T10:00:39.000Z","updated":"2020-07-05T15:03:27.904Z","comments":false,"path":"2018/01/03/2017年我都听了些什么/","link":"","permalink":"http://yoursite.com/2018/01/03/2017%E5%B9%B4%E6%88%91%E9%83%BD%E5%90%AC%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/","excerpt":"","text":"2017都用的是网易云音乐听歌，基本没用别的播放器，所以网易的这个结果还是很准确的。 1.我的网易云音乐名字叫：缘分道桥 [ ](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010405-169x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010405.jpg) 2.一共听了3858首歌曲，平均下来就是一天听十首新歌。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010406-169x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010406.jpg) 3.用了867个小时听歌，这也意味着我2017年至少在电脑前坐了1000个小时。 [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010407-169x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010407.jpg) 4.这都能统计出来，不错不错 [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010408-169x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010408.jpg) 5.我也忘了这天是怎么了...... [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010409-169x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010409.jpg) 6.这是夜里听歌时间最晚的一次？ [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010410-169x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010410.jpg) 7.才59天，真的没算错吗...... [![](http://www.wjgbaby.com/wp-content/uploads/2018/01/18010411-169x300.jpg) 8.漫漫前路有几多风光 ，一一细心赏 为甚留步回头望一望 ，心中一片迷茫 默默看看天际白云荡 ，就像你我志在四方 但愿与你欢笑地流浪 ，挽手他乡闯一闯 漫漫前路有几多风霜 ，一一去担当 踏着前路两家互守望 ，不必要怕路长 路上有你不会绝望 ，路上有你信念更刚 路上有你欢笑在浮荡 ，满山小草都芬芳 [ forgiven","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"UGUI之UI事件EventTrigger触发器","slug":"ugui之ui-事件eventtrigger事件触发器","date":"2017-12-31T13:13:10.000Z","updated":"2020-07-05T11:23:24.139Z","comments":false,"path":"2017/12/31/ugui之ui-事件eventtrigger事件触发器/","link":"","permalink":"http://yoursite.com/2017/12/31/ugui%E4%B9%8Bui-%E4%BA%8B%E4%BB%B6eventtrigger%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"我们可以使用代码方式，在代码内实现一些UI事件的操作，重写UI事件接口内的方法体逻辑； 也可以在面板上直接进行操作，这样的话就需要用到EventTrigger 组件。 建议用代码方式控制，在面板上操作容易出错，而且不方便。 EventTrigger 组件： 1.使用步骤 ①首先给需要添加事件的UI 物体添加EventTrigger 组件； ②点击“Add New Event Type”，添加一个新的事件； ③脚本内添加对应的事件处理方法，拖拽到指定的事件面板位置。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17123103-207x300.png) 2.注意事项 ①在代码中接口实现的方式，重写的方法参数都是：PointerEventData 类型； 但是往EventTrigger 上拖拽的方法必须是BaseEventData 类型，或者空。 ②当用PointerEventData 中的属性的时候，需要进行类型的强转。 案例： 新建一个Image，加入EventTrigger 组件，添加一些事件，Pointer脚本如下： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;using System; public class Pointer : MonoBehaviour{ public void OnPointerEnter(BaseEventData eventData) { Debug.Log(&quot;指针进入&quot;); } public void OnPointerExit(BaseEventData eventData) { Debug.Log(&quot;指针离开&quot;); } public void OnPointerDown(BaseEventData eventData) { Debug.Log(&quot;指针按下&quot;); } public void OnPointerUp(BaseEventData eventData) { Debug.Log(&quot;指针抬起&quot;); } public void OnPointerClick(BaseEventData eventData) { Debug.Log(&quot;指针单击&quot;); }} 运行结果：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17123104-300x142.jpg)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI事件Pointer指针","slug":"ugui之ui事件pointer-指针","date":"2017-12-31T11:22:52.000Z","updated":"2020-07-05T11:23:24.308Z","comments":false,"path":"2017/12/31/ugui之ui事件pointer-指针/","link":"","permalink":"http://yoursite.com/2017/12/31/ugui%E4%B9%8Bui%E4%BA%8B%E4%BB%B6pointer-%E6%8C%87%E9%92%88/","excerpt":"","text":"当我们把鼠标放到游戏中某个物品或者技能上面，就会出现一个介绍信息，这就是指针的触发事件。 五个指针相关事件接口： IPointerEnterHandler：指针进入事件处理器；一瞬间触发。 IPointerExitHandler：指针离开事件处理器；一瞬间触发。 IPointerDownHandler：指针按下事件处理器；一瞬间触发。 IPointerUpHandler：指针抬起事件处理器；一瞬间触发。 IPointerClickHandler：指针单击事件处理器；指针按下+抬起=单击。 IPointerClickHandler 这个接口很特殊，UGUI中的Button和Togglr组件都是引用了这个接口才实现的点击功能，我们也可以用这些接口来编写自己的组件。 案例：新建一个Image，加入以下脚本 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;using System; //添加五个指针的引用public class Pointer : MonoBehaviour,IPointerEnterHandler,IPointerExitHandler,IPointerDownHandler,IPointerUpHandler,IPointerClickHandler{ void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData) { Debug.Log(&quot;指针进入&quot;); } void IPointerExitHandler.OnPointerExit(PointerEventData eventData) { Debug.Log(&quot;指针离开&quot;); } void IPointerDownHandler.OnPointerDown(PointerEventData eventData) { Debug.Log(&quot;指针按下&quot;); } void IPointerUpHandler.OnPointerUp(PointerEventData eventData) { Debug.Log(&quot;指针抬起&quot;); } void IPointerClickHandler.OnPointerClick(PointerEventData eventData) { Debug.Log(&quot;指针单击&quot;); }} 运行结果：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17123102-300x173.jpg)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI事件Drag拖拽","slug":"ugui之ui-事件drag-拖拽","date":"2017-12-31T11:21:11.000Z","updated":"2020-07-05T11:23:24.122Z","comments":false,"path":"2017/12/31/ugui之ui-事件drag-拖拽/","link":"","permalink":"http://yoursite.com/2017/12/31/ugui%E4%B9%8Bui-%E4%BA%8B%E4%BB%B6drag-%E6%8B%96%E6%8B%BD/","excerpt":"","text":"在很多游戏中，游戏背包界面内的物品是可以拖动位置的，这就涉及到了UGUI的拖拽事件。 1.三个拖拽事件相关接口： IBeginDragHandler：开始拖拽事件处理器；开始拖拽的一瞬间触发。 IDragHandler：拖拽中事件处理器；拖拽过程中持续触发。 IEndDragHandler：结束拖拽事件处理器；拖拽结束的一瞬间触发。 2.接口使用步骤 ①当前脚本首先需要引入事件命名空间EventSystems； ②在当前类继承的父类的后方，用逗号分隔，写需要使用到接口名； ③鼠标放到接口名上，右键–&gt;实现接口–&gt;实现接口/ 显示实现接口； ④编写相应事件的方法体，先简单输出调试。 3.通过拖拽事件改变图片位置 RectTransformUtility.ScreenPointToWorldPointInRectangle(m_RectTransform, eventData.position, eventData.enterEventCamera,out vec); RectTransformUtility：RectTransform 工具类； ScreenPointToWorldPointInRectangle：屏幕坐标点转化为世界坐标点； m_RectTransform：游戏物体的RectTransform ; eventData.position：当前坐标位置点； eventData.enterEventCamera：事件摄像机； out vec)：最终计算得到的世界坐标位置； 案例：创建一个Image，加入以下脚本： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems; //引入事件命名空间EventSystemsusing System; //添加三个接口public class Drag : MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler{ private RectTransform m\\_RectTransform; void Start() { m\\_RectTransform = gameObject.GetComponent&lt;RectTransform&gt;(); } void IBeginDragHandler.OnBeginDrag(PointerEventData eventData) { Debug.Log(&quot;开始拖拽&quot;); } void IDragHandler.OnDrag(PointerEventData eventData) { Debug.Log(&quot;拖拽中&quot;); Vector3 vec; RectTransformUtility.ScreenPointToWorldPointInRectangle(m\\_RectTransform, eventData.position, eventData.enterEventCamera,out vec); m\\_RectTransform.position = vec; //将最终的pos 位置值持续赋值给当前游戏物体的position } void IEndDragHandler.OnEndDrag(PointerEventData eventData) { Debug.Log(&quot;结束拖拽&quot;); }} 运行结果，图中的Image在运行后可以拖动位置：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17123101-300x197.png)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"OpenGL笔记五：一致变量","slug":"opengl笔记五：一致变量","date":"2017-12-28T17:07:58.000Z","updated":"2020-07-05T08:56:51.134Z","comments":false,"path":"2017/12/29/opengl笔记五：一致变量/","link":"","permalink":"http://yoursite.com/2017/12/29/opengl%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%9A%E4%B8%80%E8%87%B4%E5%8F%98%E9%87%8F/","excerpt":"","text":"我们将接触到一个新的着色器变量类型——一致变量 属性变量与一致变量之间的区别：属性变量包含顶点特性数据所以每次调用shader都会从顶点缓冲区中重新导入新的数据，而一致变量中的值在整个绘制过程中都保持不变。这意味着我们在绘制过程之前就为一致变量赋值并且在着色器的每次调用中都可以访问这个相同的值。一致变量对于保存光照参数（光源位置和光照方向等），变换矩阵、纹理对象句柄等都是非常有用的。 在此教程中我们最终实现的功能是使某些东西在屏幕上不停的运动。要实现这个功能，我们需要使用一个一致变量和 GLUT 库提供的 idle() 回调函数，一致变量的值在每一帧中都会被改变。问题在于 GLUT 并不会反复调用我们的渲染回调函数——除非它不得不调用。GLUT 只有在如下列事件发生时才会强制调用渲染回调函数：最大化或者最小化窗口、被另一个窗口遮挡，遮挡窗口移除等。如果我们在程序运行之后对窗口的布局不做任何变化则渲染回调函数只会调用一次。你可以通过在渲染函数中添加一个打印函数来验证，你会看到打印函数只执行一次，如果你将窗口最大化或者最小化你可以发现打印函数会再次被执行。在 GLUT 中只注册一个渲染回调函数对于前面的教程来说是合适的，但是现在我们想要不断的改变变量的值，要实现这个功能我们需要注册一个 idle() 回调。Idle函数会在窗口系统未接收到事件的时候被GLUT调用，你可以为 idle() 回调函数设计一个专用功能函数用于做一些与时间更新类似的记录工作，或者简单的将渲染回调函数注册为idle回调函数即可。在本教程中我们直接将渲染函数注册为idle回调函数并且在渲染函数中对一直变量进行更新。 1. glutIdleFunc(RenderCallBack);将渲染回调注册为全局闲置回调。 2. gScaleLocation = glGetUniformLocation(ShaderProgram, &quot;gScale&quot;); assert(gScaleLocation != 0xFFFFFFFF);在对 Shader 程序对象进行链接之后我们需要从 Shader 程序对象中获取指向一致变量的地址。这是 C/C++ 应用程序执行环境需要映射 Shader 执行环境的另一个例子。当你编译 Shader 程序时 GLSL 会自动为每个一致变量分配一个索引，在 Shader 内部编译器就是通过索引来解决变量的访问问题的。通过使用程序对象句柄和变量的名字来调用 glGetUniformLocation 函数，应用程序同样可以获取这个索引，如果出现错误的话，这个函数会返回-1。所以错误检查是非常重要的（正如我们上面通过调用 assert() 函数一样）,否则如果出现错误，则更新之后的变量就不会被传递到 Shader 中去。调用这个函数失败的原因有两个：其一是你弄错了变量名，其二是变量被编译器优化掉了。如果 GLSL 编译器发现变量在 Shader 中并没有被使用，则编译器会将其剔除。在这种情况下调用 glGetUniformLocation 函数就会失败。 3. static float Scale = 0.0f; Scale += 0.001f; glUniform1f(gScaleLocation, sinf(Scale));我们定义一个静态 float 变量并且在每次调用渲染函数的时候使其值增加一点（如果它在你的机器上运动的太快或者太慢，你可以将0.001改得小一点或者大一点），实际上传递到 Shader 中的值是 Scale 变量的 sin 值，这是为了创建一个在 -1.0 和 1.0 之间的循环。 需要注意的是 sinf（）使用弧度值而不是角度值作为参数，我们需要 sin（）函数产生的这个波动值。Sinf（）所产生的结果通过 glUniform1f 函数传递到 Shader 中。OpenGL 提供了多个形如 glUniform{1234}{if} 的函数，你可以使用这些函数将值传递到 1D，2D，3D 或者 4D（由位于glUniform后面的数字确定）向量中，这些值可以是浮点数也可以是整数（由后缀‘i’和‘f’确定）。类似的我们也可以使用向量地址或者矩阵地址作为参数来传递一个向量或者矩阵。这个函数的第一个参数是我们通过 glGetUniformLocation() 获得的变量的索引地址。 4. uniform float gScale;在 Shader 中声明一个一致变量。 5. gl_Position = vec4(gScale * Position.x, gScale * Position.y, Position.z,1.0);在每一帧中，我们都让位置向量的 X 分量和 Y 分量乘上从应用程序中传入的值。 项目代码： #include &lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;GL/glew.h&gt;#include &lt;GL/freeglut.h&gt;#include “ogldev_math_3d.h” //用于OpenGL的3d数学库,这里主要用到了顶点这个数据结构，里面报错的代码可以先注释掉#include “ogldev_util.h” //用于读取文本文件 GLuint VBO; //全局GLuint引用变量，来操作顶点缓冲器对象GLuint gScaleLocation; //位置中间变量 // 定义要读取的顶点着色器脚本和片断着色器脚本的文件名，作为文件读取路径const char* pVSFileName = “shader.vs”;const char* pFSFileName = “shader.fs”; static void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空颜色缓存 static float Scale = 0.0f; //维护一个不断慢慢增大的静态浮点数 Scale += 0.001f; //如果图像变化太快或者太慢，可调节此数值 glUniform1f(gScaleLocation, sinf(Scale)); // 将值传递给shader glEnableVertexAttribArray(0); //开启顶点属性 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, 0); //管线解析bufer中的数据 glDrawArrays(GL\\_TRIANGLES, 0, 3); //画三角形，3个顶点 glDisableVertexAttribArray(0); //禁用顶点数据 glutSwapBuffers(); //交换前后缓存} static void InitializeGlutCallbacks(){ glutDisplayFunc(RenderCallBack); glutIdleFunc(RenderCallBack); //将渲染回调注册为全局闲置回调} static void CreateVertexBuffer(){ Vector3f Vertices[3]; //创建含有3个顶点的顶点数组 Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f); Vertices[1] = Vector3f(1.0f, -1.0f, 0.0f); Vertices[2] = Vector3f(0.0f, 1.0f, 0.0f); glGenBuffers(1, &amp;VBO); //创建缓冲器 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(Vertices), Vertices, GL\\_STATIC\\_DRAW); //绑定顶点数据} //使用shader文本编译shader对象，并绑定shader到着色器程序中static void AddShader(GLuint ShaderProgram, const char* pShaderText, GLenum ShaderType){ // 根据shader类型参数定义两个shader对象 GLuint ShaderObj = glCreateShader(ShaderType); // 检查是否定义成功 if (ShaderObj == 0) { fprintf(stderr, “Error creating shader type %d\\n”, ShaderType); exit(0); } // 定义shader的代码源 const GLchar\\* p\\[1\\]; p\\[0\\] = pShaderText; GLint Lengths\\[1\\]; Lengths\\[0\\] = strlen(pShaderText); glShaderSource(ShaderObj, 1, p, Lengths); glCompileShader(ShaderObj); // 编译shader对象 // 检查和shader相关的错误 GLint success; glGetShaderiv(ShaderObj, GL\\_COMPILE\\_STATUS, &amp;success); if (!success) { GLchar InfoLog\\[1024\\]; glGetShaderInfoLog(ShaderObj, 1024, NULL, InfoLog); fprintf(stderr, &quot;Error compiling shader type %d: &apos;%s&apos;\\\\n&quot;, ShaderType, InfoLog); exit(1); } // 将编译好的shader对象绑定到program object程序对象上 glAttachShader(ShaderProgram, ShaderObj);} // 编译着色器函数static void CompileShaders(){ // 创建着色器程序 GLuint ShaderProgram = glCreateProgram(); // 检查是否创建成功 if (ShaderProgram == 0) { fprintf(stderr, “Error creating shader program\\n”); exit(1); } // 存储着色器文本的字符串缓冲 string vs, fs; // 分别读取着色器文件中的文本到字符串缓冲区 if (!ReadFile(pVSFileName, vs)) { exit(1); }; if (!ReadFile(pFSFileName, fs)) { exit(1); }; // 添加顶点着色器和片段着色器 AddShader(ShaderProgram, vs.c\\_str(), GL\\_VERTEX\\_SHADER); AddShader(ShaderProgram, fs.c\\_str(), GL\\_FRAGMENT\\_SHADER); // 链接shader着色器程序，并检查程序相关错误 GLint Success = 0; GLchar ErrorLog\\[1024\\] = { 0 }; glLinkProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_LINK\\_STATUS, &amp;Success); if (Success == 0) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Error linking shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 检查验证在当前的管线状态程序是否可以被执行 glValidateProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_VALIDATE\\_STATUS, &amp;Success); if (!Success) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Invalid shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 设置到管线声明中来使用上面成功建立的shader程序 glUseProgram(ShaderProgram); // 查询获取一致变量的位置 gScaleLocation = glGetUniformLocation(ShaderProgram, &quot;gScale&quot;); assert(gScaleLocation != 0xFFFFFFFF); // 检查错误} int main(int argc, char** argv){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); glutInitWindowSize(400, 400); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;Shader一致向量三角形&quot;); glutDisplayFunc(RenderCallBack); //开始渲染 InitializeGlutCallbacks(); // 检查GLEW是否就绪，必须要在GLUT初始化之后！ GLenum res = glewInit(); if (res != GLEW\\_OK) { fprintf(stderr, &quot;Error: &apos;%s&apos;\\\\n&quot;, glewGetErrorString(res)); return 1; } glClearColor(0.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 CreateVertexBuffer(); //创建顶点缓冲器 CompileShaders(); // 编译着色器 glutMainLoop(); //通知开始GLUT的内部循环 return 0;} shader.vs脚本代码： #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 layout (location = 0) in vec3 Position; // 绑定定点属性名和属性，方式二缓冲属性和shader属性对应映射 uniform float gScale; //在 Shader 中声明一个一致变量void main(){ gl_Position = vec4(gScale * Position.x, gScale * Position.y, Position.z, 1.0); // 为glVertexAttributePointer提供返回值} shader.fs脚本代码： #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 out vec4 FragColor; // 片段着色器的输出颜色变量 // 着色器的唯一入口函数void main(){ // 定义输出颜色值 FragColor = vec4(1.0, 0.0, 0.0, 1.0);} 运行效果如下（gif图片）： 参考链接： http://ogldev.atspace.co.uk/www/tutorial05/tutorial05.html http://blog.csdn.net/cordova/article/details/52504118","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"UGUI之UI组件横向和纵向布局","slug":"ugui之ui-组件横向和纵向布局","date":"2017-12-27T09:21:30.000Z","updated":"2020-07-05T11:23:24.325Z","comments":false,"path":"2017/12/27/ugui之ui-组件横向和纵向布局/","link":"","permalink":"http://yoursite.com/2017/12/27/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6%E6%A8%AA%E5%90%91%E5%92%8C%E7%BA%B5%E5%90%91%E5%B8%83%E5%B1%80/","excerpt":"","text":"一.横向布局组件 Horizontal Layout Group：横向布局组件。 表格布局组件是功能最全的一个布局组件，可以实现表格，横向，纵向布局； 而横向布局组件可以理解成是表格布局组件功能的一部分。 组件属性： Child Controls Size：子物体的大小。 —勾选Width：自动缩放所有子物体的宽度，让子物体横向占满空间. —勾选Height：自动缩放所有子物体的高度，让子物体竖向占满空间. Child Force Expand：子物体的扩展。 如果要使用上方的“子物体的大小”属性，这里的属性必须勾选，上方的属性依赖该属性。 案例：使用Horizontal Layout Group组件做一个横向滑动框 1.新建一个Image，命名BG，调节大小和透明度[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122701-300x208.png)](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122701.png) 2.创建一个空物体Empty，调节大小，添加Image组件并调节透明度，添加Mask组件起到遮罩作用。添加ScrollRect组件，取消勾选Vertical，注意Grid最后要拖入到ScrollRect组件的Content。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122702-300x206.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122702.jpg)3.创建空物体Grid，添加Horizontal Layout Group组件，调节边距，勾选Height。添加Content Size Fitter组件，进行内容尺寸的过滤，并设置Horizontal Fit为Preferred Size。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122703-300x205.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122703.jpg) 4.在Grid下面添加各种颜色的Image，注意调节大小。 效果如下(gif图片)： [![](http://www.wjgbaby.com/wp-content/uploads/2017/12/test08-300x206.gif) 二.纵向布局组件 Vertical Layout Group：纵向布局组件。 纵向布局组件和横向布局组件使用是完全一样的，包括组件属性也是完全一样；区别就是一个是横向，一个是纵向，所以不写了。","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"试着去平衡时间和空间","slug":"试着去平衡时间和空间","date":"2017-12-23T18:27:00.000Z","updated":"2020-07-05T15:03:27.926Z","comments":false,"path":"2017/12/24/试着去平衡时间和空间/","link":"","permalink":"http://yoursite.com/2017/12/24/%E8%AF%95%E7%9D%80%E5%8E%BB%E5%B9%B3%E8%A1%A1%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4/","excerpt":"","text":"仔细想来，已经很久都没有过一个轻松愉悦的周末了 总有一些事情要去做 以前会把自己搞得精疲力竭 但现在我学着去平衡我的时间和空间 前段时间跟一个朋友一块，两个山炮进了趟城 参加了一个开发者活动，我们在48小时内做了款游戏 主办方提供了五星级酒店，还不错 为了在规定时间做好游戏 我一共也就在酒店睡了六小时左右，想想都太亏 主办方无限供应魔爪，星巴克，红牛… 我喝了不少，喝到想睡但睡不着，想想都傻X 自打从城里回来后 我的睡觉时间又比原来晚了一个小时… 长夜漫漫，室友们都出去唱歌去了 我对他们的这种消遣时光的法子毫无兴趣 他们走后，我计划早点睡觉 结果计划还是失败了，现在是凌晨两点十分 我的身体告诉我该睡了 保持一颗平常心，做不平常之事，睡觉睡觉~","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"ULua官方案例之核心脚本分析","slug":"ulua官方案例之核心脚本分析","date":"2017-12-23T17:22:59.000Z","updated":"2020-07-05T11:24:00.956Z","comments":false,"path":"2017/12/24/ulua官方案例之核心脚本分析/","link":"","permalink":"http://yoursite.com/2017/12/24/ulua%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B%E4%B9%8B%E6%A0%B8%E5%BF%83%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/","excerpt":"","text":"C#核心脚本 1.框架入口 GlobalGenerator.cs 在场景中有一个空物体，该物体上挂载了一个“GlobalGenerator.cs”脚本。 该脚本字面意思理解是“全局生成器”,它是ULua 热更新框架的入口启动脚本。作用类似于VS 控制台项目中的入口脚本Program.cs。 using UnityEngine;using System.Collections; namespace SimpleFramework { /// /// 全局构造器，每个场景里都有，所以每个场景都会初始化一遍，也会初始化游戏管理器一次 /// 如果游戏管理器已经存在了，就跳过了，否则创建游戏管理器，来保证游戏里只有一个GameManager /// public class GlobalGenerator : MonoBehaviour { void Awake() { InitGameMangager(); } /// &lt;summary&gt; /// 实例化游戏管理器 /// &lt;/summary&gt; public void InitGameMangager() { //定义一个字符串变量. string name = &quot;GameManager&quot;; //在当前场景中查找该名称的变量,如果没有则实例化该游戏物体,并且给它设置物体名称. GameObject manager = GameObject.Find(name); if (manager == null) { manager = new GameObject(name); manager.name = name; //调用框架中的功能方法,启动热更新框架. AppFacade.Instance.StartUp(); //启动游戏 } } }} 2.启动命令 StartUpCommand.cs 在ULua 框架启动后，会执行到“StartUpCommand.cs”脚本。 这个脚本的作用是给场景内的游戏物体添加必备的管理器脚本。 using UnityEngine;using System.Collections;using SimpleFramework;using SimpleFramework.Manager; /// /// 框架启动命令./// public class StartUpCommand : ControllerCommand { public override void Execute(IMessage message) { if (!Util.CheckEnvironment()) return; //查找当前场景中的GlobalGenerator游戏物体. GameObject gameMgr = GameObject.Find(&quot;GlobalGenerator&quot;); //如果存在就给该游戏物体添加一个AppView.cs脚本. if (gameMgr != null) { AppView appView = gameMgr.AddComponent&lt;AppView&gt;(); } //-----------------关联命令----------------------- AppFacade.Instance.RegisterCommand(NotiConst.DISPATCH\\_MESSAGE, typeof(SocketCommand)); //-----------------初始化管理器----------------------- AppFacade.Instance.AddManager(ManagerName.Lua, new LuaScriptMgr()); //给“GameManager游戏物体”动态的添加7个管理器脚本. AppFacade.Instance.AddManager&lt;PanelManager&gt;(ManagerName.Panel); AppFacade.Instance.AddManager&lt;MusicManager&gt;(ManagerName.Music); AppFacade.Instance.AddManager&lt;TimerManager&gt;(ManagerName.Timer); AppFacade.Instance.AddManager&lt;NetworkManager&gt;(ManagerName.Network); AppFacade.Instance.AddManager&lt;ResourceManager&gt;(ManagerName.Resource); AppFacade.Instance.AddManager&lt;ThreadManager&gt;(ManagerName.Thread); AppFacade.Instance.AddManager&lt;GameManager&gt;(ManagerName.Game); Debug.Log(&quot;SimpleFramework StartUp--------&gt;&gt;&gt;&gt;&gt;&quot;); }} 3.七个管理器脚本 ULua 框架运行后，会自动给“GameManager 游戏物体”添加7 个管理器脚本，这7 个管理器脚本内，存放了大量的“可复用代码”。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122401-300x276.jpg) 4.游戏管理器 GameManager.cs 这7 个管理器脚本中，代码量最大的是GameManager.cs 脚本，在开发发中操作也是最多的。 热更新框架中核心的“资源热更新下载功能”就是在该脚本内实现的。 OnResourceInited（）方法：C#与Lua 交互的入口。 部分代码： /// /// 资源初始化结束/// public void OnResourceInited() { //启动Lua管理器,其实还是Lua解析器(Lua运行虚拟机). LuaManager.Start(); //DoFile方法加载外部的文件并且执行. LuaManager.DoFile(“Logic/Network”); //加载网络 LuaManager.DoFile(“Logic/GameManager”); //加载游戏 initialize = true; //初始化完 NetManager.OnInit(); //初始化网络 //调用GameManager.lua脚本中的&quot;LuaScriptPanel&quot;方法. object\\[\\] panels = CallMethod(&quot;LuaScriptPanel&quot;); //---------------------Lua面板--------------------------- foreach (object o in panels) { string name = o.ToString().Trim(); if (string.IsNullOrEmpty(name)) continue; //将名称和&quot;Panel&quot;相加组拼成新的名称,如:MessagePanel. name += &quot;Panel&quot;; //添加 //加载View/目录下的对应的界面脚本. LuaManager.DoFile(&quot;View/&quot; + name); Debug.LogWarning(&quot;LoadLua----&gt;&gt;&gt;&gt;&quot; + name + &quot;.lua&quot;); } //------------------------------------------------------------ //全部加载完毕后,回调执行GameManager.lua脚本中的&quot;OnInitOK&quot;方法. CallMethod(&quot;OnInitOK&quot;); //初始化完成} Lua 核心脚本 1.游戏管理器 GameManager.lua C#版本的GameManger.cs 中会加载Lua 版的GameManger.lua 脚本。 LuaScriptPanel()：返回一个名称数组. OnInitOK()：加载完View 资源后的回调方法. require “3rd/pblua/login_pb”require “3rd/pbc/protobuf” local lpeg = require “lpeg” local json = require “cjson”local util = require “3rd/cjson.util” local sproto = require “3rd/sproto/sproto”local core = require “sproto.core”local print_r = require “3rd/sproto/print_r” require “Logic/LuaClass”require “Logic/CtrlManager”require “Common/functions”require “Controller/PromptCtrl” –管理器–GameManager = {};local this = GameManager; local game;local transform;local gameObject;local WWW = UnityEngine.WWW; –返回Lua中面板的名称.function GameManager.LuaScriptPanel() return ‘Prompt’, ‘Message’;end function GameManager.Awake() –warn(‘Awake—&gt;&gt;&gt;’);end –启动事件–function GameManager.Start() –warn(‘Start—&gt;&gt;&gt;’);end –初始化完成，发送链接服务器信息–function GameManager.OnInitOK() –设置Socket相关属性,然后发起请求. AppConst.SocketPort = 2012; AppConst.SocketAddress = “127.0.0.1”; NetManager:SendConnect(); --执行相应的测试方法. this.test\\_class\\_func(); this.test\\_pblua\\_func(); this.test\\_cjson\\_func(); this.test\\_pbc\\_func(); this.test\\_lpeg\\_func(); this.test\\_sproto\\_func(); coroutine.start(this.test\\_coroutine); --启动&quot;控制器管理器脚本&quot;. CtrlManager.Init(); --获取Prompt界面的Ctrl,如果当前是“案例模式”,即执行当前的Ctrl中的Awake方法. local ctrl = CtrlManager.GetCtrl(CtrlName.Prompt); if ctrl ~= nil and AppConst.ExampleMode then ctrl:Awake(); end warn(&apos;SimpleFramework InitOK---&gt;&gt;&gt;&apos;);end 2.控制器管理器 CtrlManager.lua 该脚本用于管理Lua 环境中所有的Ctrl 类型的脚本. 只需要根据开发需求引入对应的Ctrl 文件，并且往Init()方法中添加数据即可。 require “Common/define” –引入Define文件.require “Controller/PromptCtrl” –引入Lua中的Ctrl脚本.require “Controller/MessageCtrl” CtrlManager = {};local this = CtrlManager;local ctrlList = {}; –控制器列表– –控制器的初始化方法.function CtrlManager.Init() warn(“CtrlManager.Init—–&gt;&gt;&gt;”); –ctrlList是一个表,表里面添加元素. –ctrlList[‘名’] = 值.最终该ctrlList中存放的是所有的Ctrl脚本的对象. ctrlList[CtrlName.Prompt] = PromptCtrl.New(); ctrlList[CtrlName.Message] = MessageCtrl.New(); –返回当前对象. return this;end –添加控制器–function CtrlManager.AddCtrl(ctrlName, ctrlObj) ctrlList[ctrlName] = ctrlObj;end –获取控制器–function CtrlManager.GetCtrl(ctrlName) return ctrlList[ctrlName];end –移除控制器–function CtrlManager.RemoveCtrl(ctrlName) ctrlList[ctrlName] = nil;end –关闭控制器–function CtrlManager.Close() warn(‘CtrlManager.Close—-&gt;&gt;&gt;’);end 3.定义 define.lua 存放Lua 环境中的一些定义，我们只需要根据开发需求往CtrlName 表中添加数据即可。 CtrlName = { Prompt = “PromptCtrl”, Message = “MessageCtrl”} –协议类型–ProtocalType = { BINARY = 0, PB_LUA = 1, PBC = 2, SPROTO = 3,}–当前使用的协议类型–TestProtoType = ProtocalType.BINARY; Util = SimpleFramework.Util;AppConst = SimpleFramework.AppConst;LuaHelper = SimpleFramework.LuaHelper;ByteBuffer = SimpleFramework.ByteBuffer; ResManager = LuaHelper.GetResManager();NetManager = LuaHelper.GetNetManager();PanelManager = LuaHelper.GetPanelManager();MusicManager = LuaHelper.GetMusicManager();","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"ULua官方案例之Lua逻辑脚本分析","slug":"ulua官方案例之lua逻辑脚本分析","date":"2017-12-23T10:50:52.000Z","updated":"2020-07-05T11:24:00.943Z","comments":false,"path":"2017/12/23/ulua官方案例之lua逻辑脚本分析/","link":"","permalink":"http://yoursite.com/2017/12/23/ulua%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B%E4%B9%8Blua%E9%80%BB%E8%BE%91%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/","excerpt":"","text":"Panel脚本 Panel的PromptPanel.lua和MessagePanel.lua 这两个脚本都是和UI 界面相关的，本身没有实际的代码逻辑，都是查找当前UI 面板的一些游戏物体或者组件，并且存储它们的引用。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17122301-300x143.jpg) 1.PromptPanel.lua 脚本：“主面板”的界面脚本. local transform; –局部变量.local gameObject; –局部变量. PromptPanel = {}; –定义一个和当前脚本同名的表.local this = PromptPanel; –把当前表存储到this局部变量中. –启动事件–function PromptPanel.Awake(obj) –在当前表中定义一个Awake方法,并且接受一个”游戏物体对象参数”. –这里的obj对应的就是PromptPanel.prefab. gameObject = obj; –将传递来的对象进行保存. transform = obj.transform; –从对象中获取transform组件. this.InitPanel(); --调用初始化面板方法. warn(&quot;Awake lua---&gt;&gt;&quot;..gameObject.name); --warn()类似于Debug.Log().end –初始化面板–function PromptPanel.InitPanel() this.btnOpen = transform:Find(“Open”).gameObject; –查找并持有”Open”游戏物体的对象引用. this.gridParent = transform:Find(‘ScrollView/Grid’); –查找并持有”Grid”游戏物体的对象引用.end –单击事件–function PromptPanel.OnDestroy() warn(“OnDestroy—-&gt;&gt;&gt;”); –无意义,只是一个输出测试.end 2.MessagePanel.lua 脚本：“弹出信息面板”的界面脚本 local transform;local gameObject; MessagePanel = {};local this = MessagePanel; –启动事件–function MessagePanel.Awake(obj) gameObject = obj; transform = obj.transform; this.InitPanel(); warn(&quot;Awake lua---&gt;&gt;&quot;..gameObject.name);end –初始化面板–function MessagePanel.InitPanel() this.btnClose = transform:Find(“Button”).gameObject;end –单击事件–function MessagePanel.OnDestroy() warn(“OnDestroy—-&gt;&gt;&gt;”);end Ctrl脚本 MessageCtrl.lua和PromptCtrl.lua两个Ctrl 脚本是UI界面的逻辑处理脚本，该脚本主要用于实例化游戏物体，处理游戏物体本身的逻辑，并对游戏物体内的按钮绑定相关的事件处理方法，在Ctrl 脚本中会访问使用Panel 脚本中查找到的游戏物体引用。 1.MessageCtrl.lua 脚本：“弹出信息面板”的界面逻辑功能实现脚本. MessageCtrl = {}; –定义一个和当前脚本同名的表.local this = MessageCtrl; –把当前表存储到this局部变量中. –定义需要使用到的变量用local修饰.local message;local transform;local gameObject; –构建函数–function MessageCtrl.New() warn(“MessageCtrl.New—&gt;&gt;”); return this; –返回当前表.end function MessageCtrl.Awake() warn(“MessageCtrl.Awake—&gt;&gt;”); –调用PanelManager.cs脚本中的CreatePanel()方法,创建”面板游戏物体”. –PanelManager.cs是一个”框架脚本”,panel相关的操作方法都被封装到这个脚本中. –CreatePanel(AB资源的名字, 回调方法). PanelManager:CreatePanel(‘Message’, this.OnCreate);end –启动事件–function MessageCtrl.OnCreate(obj) –接收一个obj对象.这个obj就是CreatePanel创建出来的游戏物体. gameObject = obj; –存储该obj对象. local panel = gameObject:GetComponent(&apos;UIPanel&apos;); --获取UIPanel组件并存储. panel.depth = 10; --设置纵深-- message = gameObject:GetComponent(&apos;LuaBehaviour&apos;); --获取LuaBehaviour组件并存储. --调用message中的AddClick静态方法,给关闭按钮添加相应的处理事件方法. --MessagePanel.btnClose就是我们在MessagePanel.lua中查找到的游戏物体. message:AddClick(MessagePanel.btnClose, this.OnClick); warn(&quot;Start lua---&gt;&gt;&quot;..gameObject.name);end –单击事件–function MessageCtrl.OnClick(go) destroy(gameObject); –销毁当前游戏物体.end –关闭事件–function MessageCtrl.Close() PanelManager:ClosePanel(CtrlName.Message);end PanelManager.cs: using UnityEngine;using System.Collections;using System.Collections.Generic;using LuaInterface; namespace SimpleFramework.Manager { public class PanelManager : View { private Transform parent; Transform Parent { get { if (parent == null) { GameObject go = GameObject.FindWithTag(&quot;GuiCamera&quot;); if (go != null) parent = go.transform; } return parent; } } /// &lt;summary&gt; /// 创建面板.\\[主要是通过名字加载AB资源\\] /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; public void CreatePanel(string name, LuaFunction func = null) { //通过名字加载AssetBundle. AssetBundle bundle = ResManager.LoadBundle(name); //开启一个协程. StartCoroutine(StartCreatePanel(name, bundle, func)); Debug.LogWarning(&quot;CreatePanel::&gt;&gt; &quot; + name + &quot; &quot; + bundle); } /// &lt;summary&gt; /// 协程方法,使用AB资源,名称,回调方法,完成面板的实例化. /// &lt;/summary&gt; IEnumerator StartCreatePanel(string name, AssetBundle bundle, LuaFunction func = null) { name += &quot;Panel&quot;; //加载AB资源中的&quot;MessagePanel预制体资源&quot;. GameObject prefab = Util.LoadAsset(bundle, name); //协程等待. yield return new WaitForEndOfFrame(); //安全校验判断. if (Parent.Find(name) != null || prefab == null) { yield break; } //实例化游戏物体(UI面板). GameObject go = Instantiate(prefab) as GameObject; //设置该面板相关的属性. go.name = name; go.layer = LayerMask.NameToLayer(&quot;Default&quot;); go.transform.parent = Parent; go.transform.localScale = Vector3.one; go.transform.localPosition = Vector3.zero; //协程等待. yield return new WaitForEndOfFrame(); //给当前的游戏物体添加一个组件&quot;LuaBehaviour&quot;. go.AddComponent&lt;LuaBehaviour&gt;().OnInit(bundle); //调用回调方法. if (func != null) func.Call(go); Debug.Log(&quot;StartCreatePanel------&gt;&gt;&gt;&gt;&quot; + name); } }} 2.PromptCtrl.lua 脚本：“主面板”的界面逻辑功能实现脚本 require “Common/define” –require引入需要使用到的lua文件. require “3rd/pblua/login_pb”require “3rd/pbc/protobuf” local sproto = require “3rd/sproto/sproto”local core = require “sproto.core”local print_r = require “3rd/sproto/print_r” PromptCtrl = {};local this = PromptCtrl; local panel;local prompt;local transform;local gameObject; –构建函数–function PromptCtrl.New() warn(“PromptCtrl.New—&gt;&gt;”); return this;end function PromptCtrl.Awake() warn(“PromptCtrl.Awake—&gt;&gt;”); PanelManager:CreatePanel(‘Prompt’, this.OnCreate);end –启动事件–function PromptCtrl.OnCreate(obj) gameObject = obj; transform = obj.transform; panel = transform:GetComponent(&apos;UIPanel&apos;); prompt = transform:GetComponent(&apos;LuaBehaviour&apos;); warn(&quot;Start lua---&gt;&gt;&quot;..gameObject.name); this.InitPanel(); --初始化面板-- prompt:AddClick(PromptPanel.btnOpen, this.OnClick);end –初始化面板–function PromptCtrl.InitPanel() panel.depth = 1; –设置纵深– local parent = PromptPanel.gridParent; local itemPrefab = prompt:GetGameObject(‘PromptItem’); for i = 1, 100 do local go = newobject(itemPrefab); go.name = tostring(i); go.transform.parent = parent; go.transform.localScale = Vector3.one; go.transform.localPosition = Vector3.zero; prompt:AddClick(go, this.OnItemClick); local goo = go.transform:Find(&apos;Label&apos;); goo:GetComponent(&apos;UILabel&apos;).text = i; end local grid = parent:GetComponent(&apos;UIGrid&apos;); grid:Reposition(); grid.repositionNow = true; parent:GetComponent(&apos;WrapGrid&apos;):InitGrid();end –滚动项单击事件–function PromptCtrl.OnItemClick(go) log(go.name);end –单击事件–function PromptCtrl.OnClick(go) if TestProtoType == ProtocalType.BINARY then this.TestSendBinary(); end if TestProtoType == ProtocalType.PB_LUA then this.TestSendPblua(); end if TestProtoType == ProtocalType.PBC then this.TestSendPbc(); end if TestProtoType == ProtocalType.SPROTO then this.TestSendSproto(); end warn(“OnClick—-&gt;&gt;&gt;”..go.name);end","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"OpenGL笔记四：着色器基础","slug":"opengl笔记四：shader着色器基础","date":"2017-12-18T20:15:15.000Z","updated":"2020-07-05T08:56:51.123Z","comments":false,"path":"2017/12/19/opengl笔记四：shader着色器基础/","link":"","permalink":"http://yoursite.com/2017/12/19/opengl%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9Ashader%E7%9D%80%E8%89%B2%E5%99%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"OpenGL的可编程管线如下图所示： 顶点处理器—&gt;几何处理器—&gt;裁剪器—&gt;光栅器（片段处理器） [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121901-215x300.png) 顶点处理器，负责对传入渲染管线的每个顶点执行顶点着色器中的内容，顶点着色器并不关心所要渲染的基本图元的拓扑结构。此外，你不能在顶点处理器中丢弃任何一个顶点。每个顶点都只被顶点处理器处理一次。 几何处理器，组成图元所需要的顶点以及其邻接关系都会被提供给着色器。这使得着色器能够考虑除顶点本身之外的其他信息。除此之外，几何处理器也可以将在绘制函数中确定的拓扑关系修改成另外一种拓扑关系。 裁剪器，这是一个单一功能的固定功能单元，通过规范化盒子对图元进行裁剪。同时它还通过近裁剪面和远裁剪面对其进行裁剪。同时他也支持用户自定义裁剪面对场景进行裁剪。未被裁剪掉的顶点会变换到屏幕坐标系之下，之后通过光栅化将顶点按照拓扑结构渲染到屏幕上。 顶点着色器、片元着色器、几何着色器这三个可编程阶段是可选择的，如果我们不向其绑定 Shader 程序就会执行默认的固定管线的函数。 1. GLuint ShaderProgram = glCreateProgram();我们通过创建一个shader程序对象来开始我们的着色器工程，我们将会把所有的shader程序都链接到这个sahder程序对象上。 2. GLuint ShaderObj = glCreateShader(ShaderType);通过调用上面的函数我们创建了两个 Shader 对象，其中一个 Shader 对象的类型为 GL_VERTEX_SHADER，另一个为 GL_FRAGMENT_SHADER。这两个类型的 Shader对象的指定 Shader 源程序和编译 Shader 程序的过程是一样的。 3. const GLchar* p[1]; p[0] = pShaderText; GLint Lengths[1]; Lengths[0]= strlen(pShaderText); glShadersource(ShaderObj, 1, p, Lengths);在对 Shader 对象进行编译之前我们必须为其指定 Shader 源程序，glShadersource 函数需要一个 Shader 对象作为参数，源程序可以分布在多个字符串数组中，你需要提供这些数组的指针数组以及一个用于存放对应数组长度的整数数组。为了简单起见，整个着色器代码我们仅使用一个字符串数组，源程序指针数组和和长度数组都只有一个元素。glShadersource(ShaderObj, 1, p, Lengths)的第二个参数是这两个数组的元素个数。 4. glCompileShader(ShaderObj);编译shader程序。 5. GLint success; glGetShaderiv(ShaderObj, GL_COMPILE_STATUS, &amp;success); if (!success) { GLchar InfoLog[1024]; glGetShaderInfoLog(ShaderObj, sizeof(InfoLog), NULL,InfoLog); fprintf(stderr, &quot;Error compiling shader type %d:&apos;%s&apos;\\n&quot;, ShaderType, InfoLog); }很多时候，你会遇到一些编译错误。上面的代码能获得编译状态并且显示编译器遇到的错误。 6. glAttachShader(ShaderProgram, ShaderObj);最后，我们将编译之后的 Shader 对象附加到程序对象上，这和在 Makefile 中链接一个对象链表类似。因为我们这儿没有 Makefile 所以通过编程来实现这种功能。只有被附加到程序对象上的 Shader 对象才会参与链接过程。 7. glLinkProgram(ShaderProgram);在编译好所有 Shader 对象以及将他们附加到程序对象之后我们就可以进行链接操作。注意在链接程序对象之后你可以通过为每个 Shader 对象调用 glDetachShader 和 glDeleteShader 方法来删除其中的 Shader 对象。OpenGL驱动程序会为其生成的大部分对象维持一个引用计数。如果我们在创建一个 Shader 对象之后又将其删除则驱动程序会将这个 Shader 对象剔除掉，但是如果我们将 Shader 对象附加到程序对象之后调用 glDeleteShader 函数则只会将 Shader 对象标记为删除部分，你需要调用 glDetachShader 函数其引用计数才会下降到0之后才会被移除。 8. glGetProgramiv(ShaderProgram, GL_LINK_STATUS,&amp;Success); if (Success == 0) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL,ErrorLog); fprintf(stderr, &quot;Error linking shader program:&apos;%s&apos;\\n&quot;, ErrorLog); }需要注意的是我们检查程序相关的错误（如链接错误）与检查 Shader 相关错误有些许不同。我们使用 glGetShaderiv 函数和 glGetShaderInfoLog 函数代替 glGetShaderiv 函数和 glGetShaderInfoLog 函数。 9. glValidateProgram(ShaderProgram);对链接了的程序对象进行验证。它们之间的区别是链接主要检查基于着色器组合的错误，而上面调用的函数则是验证基于当前的管线状态程序是否能够成功执行。在一个有多个shader程序和很多状态变化的复杂程序中，在每次绘制之前都进行验证是更加明智的。在我们这个简单的程序中我们仅仅对其调用了一次。当然你也可以仅仅在开发过程中进行这样的验证而避免在最终产品中增加这个不必要的开销。 10. glUseProgram(ShaderProgram);最将链接之后的 Shader 程序对象添加到渲染管线中。除非我们使用其他的 Shader 程序对象来替换当前的程序对象或者通过调用 glUseProgram（NULL）显式的禁用它的使用（并且启用固定管线），否则这个 Shader 程序对象会对每次的绘制都会产生效果。如果你创建的 Shader 程序对象只包含一种类型的 Shader 程序，那么其他阶段的操作会默认的调用固定管线中的功能。 11. #version 330这告诉编译器我们的 Shader 程序是针对3.3版本的 GLSL，如果编译器不支持这个版本则会报错。 12. layout (location = 0) in vec3 Position;这条语句出现在顶点着色器中，他声明了一个指定为顶点属性的float类型三维向量，这个向量在shader中被表示为‘Position’。‘顶点属性’意味着 GPU 中的 Shader 程序每调用一次，顶点缓冲区都会为其提供一个新的顶点数据。语句中的第一部分——layout (location = 0)将属性名称与缓冲区中的属性进行绑定 13. void main()我们可以通过将多个 Shader 对象链接到一起来创建你自己的着色器，但是在每个着色器阶段（VS，GS，FS）只能有一个 main 函数作为着色器的入口点 14. gl_Position = vec4(0.5 * Position.x, 0.5 *Position.y, Position.z, 1.0);在这里我们通过编码对传入的顶点位置进行变换，我们将顶点的 X、Y 分量的值减半而保持 Z 方向值不变，gl-Position 是一个特殊的内置变量，他能够存放齐次（包含X,Y,Z和W分量）顶点坐标。在光栅化过程中系统会寻找这个变量并使用它作为顶点在屏幕上的位置（需要经过一些矩阵变换）。将顶点的X,Y分量减半意味着我们将会看到一个面积只有前面教程中的四分之一的三角形。需要注意的是我们将W分量设置为1.0，这对于三角形的正确显示是非常重要的，实现从3D到2D的投影变换实际上是在两个不同的阶段实现的，首先你需要让所有的顶点都乘上投影矩阵（我们将在后面的教程中对此进行介绍），之后 GPU 在对其进行光栅化之前自动对位置属性（Position）执行透视分割。这意味着 gl-Position 中的所有分量都会除以W分量。 15. out vec4 FragColor;一般情况下片元着色器的作用就是确定片元的颜色，除此之外，片元着色器也完全可以丢弃片元或则改变其Z值（Z值的改变会对之后的深度测试产生影响）。输出颜色是通过声明上面的变量实现，四个分量分别表示R，G，B和A（alpha）。被写入到这个变量中的值会被光栅化程序接受并最终写入到帧缓存中。 16. FragColor = vec4(1.0, 0.0, 0.0, 1.0);没有使用片元着色器的物体都被绘制成默认的白色。这里我们将颜色设置为红色。 项目代码： #include &lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;GL/glew.h&gt; // GLEW扩展库,注意glew.h必须要写在前面#include &lt;GL/freeglut.h&gt; // freeGLUT图形库 #include “ogldev_math_3d.h” //用于OpenGL的3d数学库,这里主要用到了顶点这个数据结构，里面报错的代码可以先注释掉#include “ogldev_util.h” //用于读取文本文件 GLuint VBO; //全局GLuint引用变量，来操作顶点缓冲器对象 // 定义要读取的顶点着色器脚本和片断着色器脚本的文件名，作为文件读取路径const char* pVSFileName = “shader.vs”;const char* pFSFileName = “shader.fs”; static void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空颜色缓存 glEnableVertexAttribArray(0); //开启顶点属性 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, 0); //管线解析bufer中的数据 glDrawArrays(GL\\_TRIANGLES, 0, 3); //画三角形，3个顶点 glDisableVertexAttribArray(0); //禁用顶点数据 glutSwapBuffers(); //交换前后缓存} static void InitializeGlutCallbacks(){ glutDisplayFunc(RenderCallBack);} static void CreateVertexBuffer(){ Vector3f Vertices[3]; //创建含有3个顶点的顶点数组 Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f); Vertices[1] = Vector3f(1.0f, -1.0f, 0.0f); Vertices[2] = Vector3f(0.0f, 1.0f, 0.0f); glGenBuffers(1, &amp;VBO); //创建缓冲器 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(Vertices), Vertices, GL\\_STATIC\\_DRAW); //绑定顶点数据} //使用shader文本编译shader对象，并绑定shader都想到着色器程序中static void AddShader(GLuint ShaderProgram, const char* pShaderText, GLenum ShaderType){ // 根据shader类型参数定义两个shader对象 GLuint ShaderObj = glCreateShader(ShaderType); // 检查是否定义成功 if (ShaderObj == 0) { fprintf(stderr, “Error creating shader type %d\\n”, ShaderType); exit(0); } // 定义shader的代码源 const GLchar\\* p\\[1\\]; p\\[0\\] = pShaderText; GLint Lengths\\[1\\]; Lengths\\[0\\] = strlen(pShaderText); glShaderSource(ShaderObj, 1, p, Lengths); glCompileShader(ShaderObj); // 编译shader对象 // 检查和shader相关的错误 GLint success; glGetShaderiv(ShaderObj, GL\\_COMPILE\\_STATUS, &amp;success); if (!success) { GLchar InfoLog\\[1024\\]; glGetShaderInfoLog(ShaderObj, 1024, NULL, InfoLog); fprintf(stderr, &quot;Error compiling shader type %d: &apos;%s&apos;\\\\n&quot;, ShaderType, InfoLog); exit(1); } // 将编译好的shader对象绑定到program object程序对象上 glAttachShader(ShaderProgram, ShaderObj);} // 编译着色器函数static void CompileShaders(){ // 创建着色器程序 GLuint ShaderProgram = glCreateProgram(); // 检查是否创建成功 if (ShaderProgram == 0) { fprintf(stderr, “Error creating shader program\\n”); exit(1); } // 存储着色器文本的字符串缓冲 string vs, fs; // 分别读取着色器文件中的文本到字符串缓冲区 if (!ReadFile(pVSFileName, vs)) { exit(1); }; if (!ReadFile(pFSFileName, fs)) { exit(1); }; // 添加顶点着色器和片段着色器 AddShader(ShaderProgram, vs.c\\_str(), GL\\_VERTEX\\_SHADER); AddShader(ShaderProgram, fs.c\\_str(), GL\\_FRAGMENT\\_SHADER); // 链接shader着色器程序，并检查程序相关错误 GLint Success = 0; GLchar ErrorLog\\[1024\\] = { 0 }; glLinkProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_LINK\\_STATUS, &amp;Success); if (Success == 0) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Error linking shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 检查验证在当前的管线状态程序是否可以被执行 glValidateProgram(ShaderProgram); glGetProgramiv(ShaderProgram, GL\\_VALIDATE\\_STATUS, &amp;Success); if (!Success) { glGetProgramInfoLog(ShaderProgram, sizeof(ErrorLog), NULL, ErrorLog); fprintf(stderr, &quot;Invalid shader program: &apos;%s&apos;\\\\n&quot;, ErrorLog); exit(1); } // 设置到管线声明中来使用上面成功建立的shader程序 glUseProgram(ShaderProgram);} int main(int argc, char** argv){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); glutInitWindowSize(400, 400); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;Shader三角形&quot;); glutDisplayFunc(RenderCallBack); //开始渲染 InitializeGlutCallbacks(); // 检查GLEW是否就绪，必须要在GLUT初始化之后！ GLenum res = glewInit(); if (res != GLEW\\_OK) { fprintf(stderr, &quot;Error: &apos;%s&apos;\\\\n&quot;, glewGetErrorString(res)); return 1; } glClearColor(0.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 CreateVertexBuffer(); //创建顶点缓冲器 CompileShaders(); // 编译着色器 glutMainLoop(); //通知开始GLUT的内部循环 return 0;} 顶点着色器shader.vs代码： #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 layout (location = 0) in vec3 Position; // 绑定定点属性名和属性，方式二缓冲属性和shader属性对应映射 void main(){ gl_Position = vec4(0.5 * Position.x, 0.5 * Position.y, Position.z, 1.0); // 为glVertexAttributePointer提供返回值} 片段着色器shader.fs代码： #version 330 //告诉编译器我们的目标GLSL编译器版本是3.3 out vec4 FragColor; // 片段着色器的输出颜色变量 // 着色器的唯一入口函数void main(){ // 定义输出颜色值 FragColor = vec4(1.0, 0.0, 0.0, 1.0);} 运行结果： BUG修复：在使用ogldev_util.h这个头文件的时候，运行程序一直报ReadFile函数的错误： 我在网上也发现了一些遇到这种问题的人，但是没有找到解决方案。最终还是靠自己解决了这个问题，主要是把ogldev_util.cpp中的ReadFile的核心代码放到了ogldev_util.h中，然后添加部分引用，下面展示部分代码，只修改ogldev_util.h里面的这部分就行： #ifndef OGLDEV_UTIL_H#define OGLDEV_UTIL_H #ifndef WIN32#include &lt;unistd.h&gt;#endif#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include #include #include &lt;string.h&gt;#include &lt;assert.h&gt;#include “ogldev_types.h” #include #include #ifdef WIN32#include &lt;Windows.h&gt;#else#include &lt;sys/time.h&gt;#endif #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;stdarg.h&gt; using namespace std; bool ReadFile(const char* fileName, string&amp; outFile){ ifstream f(fileName); bool ret = false; if (f.is_open()) { string line; while (getline(f, line)) { outFile.append(line); outFile.append(“\\n”); } f.close(); ret = true; } return ret;}char* ReadBinaryFile(const char* pFileName, int&amp; size); 参考链接： [http://ogldev.atspace.co.uk/www/tutorial04/tutorial04.html](http://ogldev.atspace.co.uk/www/tutorial04/tutorial04.html) [http://blog.csdn.net/cordova/article/details/52495077#cpp](http://blog.csdn.net/cordova/article/details/52495077#cpp)","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"OpenGL笔记三：创建三角形","slug":"opengl笔记三：创建三角形","date":"2017-12-16T10:45:51.000Z","updated":"2020-07-05T08:56:51.118Z","comments":false,"path":"2017/12/16/opengl笔记三：创建三角形/","link":"","permalink":"http://yoursite.com/2017/12/16/opengl%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"","text":"画出图中红线表示的三角形，三个点的坐标分别为(-1,-1,0),(1,-1,0),(0,1,0) [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121601-300x224.png) 1.顶点数组使其包含三个顶点； Vector3f Vertices[3]; //创建含有3个顶点的顶点数组Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f);Vertices[1] = Vector3f(1.0f, -1.0f, 0.0f);Vertices[2] = Vector3f(0.0f, 1.0f, 0.0f); 2.在绘制函数中有两个变化：画三角形而不是点，画三个顶点而不是一个。 glDrawArrays(GL_TRIANGLES, 0, 3); 代码如下： #include &lt;stdio.h&gt;#include &lt;GL/glew.h&gt; // GLEW扩展库,注意glew.h必须要写在前面#include &lt;GL/freeglut.h&gt; // freeGLUT图形库#include “ogldev_math_3d.h” //用于OpenGL的3d数学库,这里主要用到了顶点这个数据结构，里面报错的代码可以先注释掉 GLuint VBO; //全局GLuint引用变量，来操作顶点缓冲器对象 //渲染回调函数static void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空颜色缓存 glEnableVertexAttribArray(0); //开启顶点属性 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, 0); // 管线解析bufer中的数据 glDrawArrays(GL\\_TRIANGLES, 0, 3); ////画三角形，3个顶点 glDisableVertexAttribArray(0); //禁用顶点数据 glutSwapBuffers(); //交换前后缓存} //创建顶点缓冲器static void CreateVertexBuffer(){ Vector3f Vertices[3]; //创建含有3个顶点的顶点数组 Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f); Vertices[1] = Vector3f(1.0f, -1.0f, 0.0f); Vertices[2] = Vector3f(0.0f, 1.0f, 0.0f); glGenBuffers(1, &amp;VBO); //创建缓冲器 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(Vertices), Vertices, GL\\_STATIC\\_DRAW); //绑定顶点数据} //入口函数int main(int argc, char ** argv){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); //显示模式：双缓冲、RGBA glutInitWindowSize(400, 400); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;这是一个三角形&quot;); glutDisplayFunc(RenderCallBack); //开始渲染 // 检查GLEW是否就绪，必须要在GLUT初始化之后！ GLenum res = glewInit(); if (res != GLEW\\_OK) { fprintf(stderr, &quot;Error: &apos;%s&apos;\\\\n&quot;, glewGetErrorString(res)); return 1; } glClearColor(0.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 CreateVertexBuffer(); //创建顶点缓冲器 glutMainLoop(); //通知开始GLUT的内部循环 return 0;} 结果如下： 参考链接： http://ogldev.atspace.co.uk/www/tutorial03/tutorial03.html http://blog.csdn.net/cordova/article/details/52494549","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"OpenGL笔记二：创建顶点","slug":"opengl笔记二：创建顶点","date":"2017-12-15T13:10:05.000Z","updated":"2020-07-05T08:56:51.114Z","comments":false,"path":"2017/12/15/opengl笔记二：创建顶点/","link":"","permalink":"http://yoursite.com/2017/12/15/opengl%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9/","excerpt":"","text":"这次要用到glew库，还将使用顶点缓冲器(VBO). 1.#include &lt;GL/glew.h&gt; ：GLEW扩展库,注意glew.h必须要写在前面，否则会编译出错 2.#include “ogldev_math_3d.h” ： 用于OpenGL的3d数学库,这里主要用到了顶点这个数据结构，里面报错的代码可以先注释掉，可以在网上下载到这个库。 3. // 检查GLEW是否就绪，必须要在GLUT初始化之后！GLenum res = glewInit();if (res != GLEW_OK) { fprintf(stderr, “Error: ‘%s’\\n”, glewGetErrorString(res)); return 1;} 4.Vector3f Vertices[1]：创建含有一个顶点的顶点数组 Vertices[0] = Vector3f(0.0f, 0.0f, 0.0f)：将点置于屏幕中央 5.GLuint VBO：全局GLuint引用变量，来操作顶点缓冲器对象 6.glGenBuffers(1, &amp;VBO)： 创建缓冲器 第一个参数用来定义你想创建的对象的数量，第二个参数是一个GLuint变量的数组的地址，来存储分配给你的引用变量handles 7.glBindBuffer(GL_ARRAY_BUFFER, VBO)：绑定GL_ARRAY_BUFFER缓冲器 目标名GL_ARRAY_BUFFER意思是这个buffer将存储一个顶点的数组 8.glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW)：绑定顶点数据 这个回调函数取得我们之前绑定的目标名参数GL_ARRAY_BUFFER，还有数据的比特数参数，顶点数组的地址，还有一个表示这个数据模式的标志变量。因为我们不会去改变这个buffer的内容所以这里用了GL_STATIC_DRAW标志，相反的标志是GL_DYNAMIIC_DRAW 9.glEnableVertexAttribArray(0)：开启顶点属性 加载到buffer中的顶点位置在固定功能管线中是被认为是索引为0的顶点属性（当没有着色器绑定时被启用）。 10.glBindBuffer(GL_ARRAY_BUFFER, VBO)：绑定GL_ARRAY_BUFFER缓冲器 再次绑定我们的buffer准备开始draw call回调 11.glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0)：管线解析bufer中的数据 第1个参定义了属性的索引，再这个例子中我们知道这个索引默认是0 第2个参数指的是属性中的元素个数（3个表示的是：X,Y,Z坐标）； 第3个参数指的是每个元素的数据类型； 第4个参数指明我们是否想让我们的属性在被管线使用之前被单位化，我们这个例子中希望我们的数据保持不变的被传送； 第5个参数（称作’stride‘）指的是缓冲中那个属性的两个实例之间的比特数距离。 第6个参数是我们需要在管线发现我们的属性的地方定义数据结构中的内存偏移值。在有位置数据和法向量数据的结构中，位置的偏移量为0，而法向量的偏移量则为12。 12.glDrawArrays(GL_POINTS, 0, 1)：开始绘制几何图形(绘制一个点) 这个指令才是GPU真正开始工作的地方。这个指令将整合这个指令收到的绘制参数和之前为这一个点的图形建立的状态数据来将结果渲染在屏幕上。 13.glDisableVertexAttribArray(0)：禁用顶点数据 当顶点短时间内不会被使用的时候及时禁用他们 代码如下： #include &lt;stdio.h&gt;#include &lt;GL/glew.h&gt; // GLEW扩展库,注意glew.h必须要写在前面#include &lt;GL/freeglut.h&gt; // freeGLUT图形库#include “ogldev_math_3d.h” //用于OpenGL的3d数学库,这里主要用到了顶点这个数据结构，里面报错的代码可以先注释掉 GLuint VBO; //全局GLuint引用变量，来操作顶点缓冲器对象 //渲染回调函数static void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空颜色缓存 glEnableVertexAttribArray(0); //开启顶点属性 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, 0); // 管线解析bufer中的数据 glDrawArrays(GL\\_POINTS, 0, 1); //开始绘制几何图形(绘制一个点) glDisableVertexAttribArray(0); //禁用顶点数据 glutSwapBuffers(); //交换前后缓存} //创建顶点缓冲器static void CreateVertexBuffer(){ Vector3f Vertices[1]; //创建含有一个顶点的顶点数组 Vertices[0] = Vector3f(0.0f, 0.0f, 0.0f); //将点置于屏幕中央 glGenBuffers(1, &amp;VBO); //创建缓冲器 glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); //绑定GL\\_ARRAY\\_BUFFER缓冲器 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(Vertices), Vertices, GL\\_STATIC\\_DRAW); //绑定顶点数据} //入口函数int main(int argc, char ** argv){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); //显示模式：双缓冲、RGBA glutInitWindowSize(400, 400); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;这是一个顶点&quot;); glutDisplayFunc(RenderCallBack); //开始渲染 // 检查GLEW是否就绪，必须要在GLUT初始化之后！ GLenum res = glewInit(); if (res != GLEW\\_OK) { fprintf(stderr, &quot;Error: &apos;%s&apos;\\\\n&quot;, glewGetErrorString(res)); return 1; } glClearColor(0.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 CreateVertexBuffer(); //创建顶点缓冲器 glutMainLoop(); //通知开始GLUT的内部循环 return 0;} 结果如下： 参考链接： http://ogldev.atspace.co.uk/www/tutorial02/tutorial02.html http://blog.csdn.net/cordova/article/details/52491762","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"OpenGL笔记一：创建一个窗口","slug":"opengl笔记一：创建一个窗口","date":"2017-12-14T12:58:45.000Z","updated":"2020-07-05T08:56:51.111Z","comments":false,"path":"2017/12/14/opengl笔记一：创建一个窗口/","link":"","permalink":"http://yoursite.com/2017/12/14/opengl%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/","excerpt":"","text":"1.glutInit(&amp;agrc,argue)：调用这个函数来初始化GLUT 2.glutInitDisplayMode：显示模式 ——GLUT—SINGLE：单缓冲模式 ——GLUT_DOUBLE：双缓冲模式 ——GLUT_RGBA：RGBA模式 3.glutInitWindowPosition：窗口的位置 glutInitWindowSize：窗口的大小 glutCreateWindow：窗口的标题 4.glutDisplayFunc：回掉函数 5.glClearColor：设置当帧缓存清空后要使用的颜色值。颜色值有四个通道（RGBA）,使用单位化的值0.0-1.0来表示。 6.glutMainLoop：调用传递指令给GLUT现在开始它的内部循环 7.glClear(GL_COLOR_BUFFER_BIT)：清空当前帧缓存 8.glutSwapBuffers：告诉GLUT交换双缓冲机制中前后两个缓存的角色位置，也就是二者换班，后台的缓存放到前台显示，之前显示的缓存继续到后台开始另一帧的缓存工作 代码如下： #include&lt;GL/freeglut.h&gt; //freeglut窗口库#include //渲染回掉函数void RenderCallBack(){ glClear(GL_COLOR_BUFFER_BIT); //清空当前帧缓存 glutSwapBuffers(); //交换前后缓存} int main(int argc,char ** argv){ glutInit(&amp;argc, argv); //初始化GLUT glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); //显示模式：双缓冲，RGBA glutInitWindowPosition(200, 200); //窗口的位置 glutInitWindowSize(400, 400); //窗口的大小 glutCreateWindow(&quot;我的第一个OpenGL程序&quot;); //窗口的标题 glutDisplayFunc(RenderCallBack); //开始渲染 glClearColor(100.0f, 0.0f, 0.0f, 0.0f); //缓存清空后的颜色值 glutMainLoop(); //开始GLUT的内部循环 return 0;} 运行结果： 参考链接： http://ogldev.atspace.co.uk/www/tutorial01/tutorial01.html http://blog.csdn.net/cordova/article/details/77986123","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"OpenGL+freeglut+glew+glm环境配置","slug":"openglfreeglutglewglm环境配置","date":"2017-12-14T09:44:57.000Z","updated":"2020-07-05T08:56:51.109Z","comments":false,"path":"2017/12/14/openglfreeglutglewglm环境配置/","link":"","permalink":"http://yoursite.com/2017/12/14/openglfreeglutglewglm%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"打算认真学习OpenGL，再不学可能期末就挂了。成绩倒是没那么重要，我的原则是不挂科就行。事实上，我是想学习一下渲染管线，各种光照系统和摄像机这些知识，一入坑肯定深似海，不过没关系，我有时间。学校的图形学老师讲了很多数学的东西，基本没怎么听，老师还在用GLUT，有点老了，所以我用的freeGlut。 配置freeGlut环境比较麻烦，可以按照这个教程去做，可以说是非常详细了。 http://m.blog.csdn.net/j0939115399/article/details/74656672 前面5个步骤我已经完成了并且打包了，可以直接在下面下载，不用再自己配置了。 链接：https://pan.baidu.com/s/1boH0jZx 密码：b7b9 中间的需要配置一下路径： 32位： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121401-300x147.jpg) 64位：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121402-300x145.png) 开始测试： #include &lt;GL/glew.h&gt;#include &lt;GL/freeglut.h&gt;#includevoid displayFunction(){ glClear(GL_COLOR_BUFFER_BIT); glRectf(-0.5, -0.5, 0.5, 0.5); glColor3f(0, 1, 0); glFlush();} int main(int argc,char *argv[]){ glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowSize(600, 600); glutCreateWindow(“The first OpenGL Application”); glewExperimental = true; glewInit(); printf(&quot;OpenGL version: (%s)\\\\n&quot;,glGetString(GL\\_VERSION)); glutDisplayFunc(&amp;displayFunction); glutMainLoop(); return 0;} 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121403-290x300.png) 那个博客的代码有点小问题，你测试的时候就知道了，建议好好看那篇博客，根据那个博客来做，我这篇文章也就是打打辅助。","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"}]},{"title":"Matlab形态学处理之车牌分割","slug":"形态学之车牌分割","date":"2017-12-13T05:41:17.000Z","updated":"2020-07-05T08:56:51.106Z","comments":false,"path":"2017/12/13/形态学之车牌分割/","link":"","permalink":"http://yoursite.com/2017/12/13/%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E8%BD%A6%E7%89%8C%E5%88%86%E5%89%B2/","excerpt":"","text":"将图中的车牌号提取出来并且分割 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121310-300x225.jpg) 操作步骤： 顶帽去背景&gt;&gt;**提取边缘&gt;&gt;膨胀&gt;&gt;去除小对象&gt;&gt;得到车牌区域&gt;&gt;进一步分割** clear,clc,close all;f=imread(‘c5.jpg’);imshow(f); g=rgb2gray(f);figure,imshow(g); se=strel(‘disk’,20);gth=imtophat(g,se); %顶帽操作figure,imshow(gth); e=edge(gth); %边缘提取figure,imshow(e); se=strel(‘line’,9,90);ee=imerode(e,se);figure,imshow(ee); se=strel(‘disk’,18);ed=imdilate(ee,se);figure,imshow(ed); eao=bwareaopen(ed,7000); %去除小对象figure,imshow(eao); [hs,ws]=find(eao==1);a=min(hs);b=max(hs);c=min(ws);d=max(ws);carnumarea=gth(a:b,c:d);figure,imshow(carnumarea); bwcarnumarea=im2bw(carnumarea,0.3);figure,imshow(bwcarnumarea); bao=bwareaopen(bwcarnumarea,30); %去除小对象figure,imshow(bao); [hs2,ws2]=find(bao==1);a1=min(hs2);b1=max(hs2);c1=min(ws2);d1=max(ws2);bc=bao(a1:b1,c1:d1-2);bcb=imclearborder(bc); %去边框figure,imshow(bcb); [ss,~]=getSplitPic(bcb); %分割图像for i=1:size(ss,2) s=ss{i}; figure,imshow(s);end getSplitPic分割函数： function [splitfs,points]=getSplitPic(bw)%函数说明%input:bw为需要分割的二值图%output: splitfs 为元数据 分割好的图片都保存在splitfs中% points 为分割好的坐标 a,b,c,d a:b,c:d%right by Seven 2017.12.3splitfs={};points=[];hs=sum(bw);[,w]=size(bw);c=1;d=1;i=1;while(c&lt;w) while(hs(c)==0&amp;&amp;c&lt;w) c=c+1; end d=c; while(hs(d)&gt;0) d=d+1; end if((d-c)&gt;10) x=bw(:,c:d-1); [r,]=find(x); a=min(r);b=max(r); xi=x(a:b,:); splitfs{i}=xi; points=[points;a,b,c,d-1]; i=i+1; end c=d;end 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121311-300x160.png)","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Matlab形态学处理之膨胀腐蚀以及重建","slug":"matlab图像形态学处理","date":"2017-12-12T18:01:34.000Z","updated":"2020-07-05T08:56:51.104Z","comments":false,"path":"2017/12/13/matlab图像形态学处理/","link":"","permalink":"http://yoursite.com/2017/12/13/matlab%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86/","excerpt":"","text":"此文主要是图像的膨胀，腐蚀，开运算，闭运算，以及图像重建。 注意：所有的腐蚀针对白色对象 实例一：提取身份证号 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121303-300x186.jpg) clear,clc,close all;f=imread(‘id.jpg’);bbb=~im2bw(f);figure,imshow(bbb); se01=strel(‘rectangle’,[10,20]);ccc=imclose(bbb,se01); %闭运算，先膨胀后腐蚀figure,imshow(ccc); se02=strel(‘line’,250,0); %构造结构元素ddd=imerode(ccc,se02); %腐蚀figure,imshow(ddd); eee=imreconstruct(ddd,ccc); %图像重建fff=imreconstruct(eee,bbb);figure,imshow(fff); [hs,ws]=find(fff);A=min(hs);B=max(hs);C=min(ws);D=max(ws);ggg=fff(A:B,C:D);figure,imshow(ggg); 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121305-300x267.png)](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121305.png) 实例二：提取车牌号 [![](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121304-300x200.jpg) clear,clc,close all;f=imread(‘car.JPG’);imshow(f);b=im2bw(f,0.85);figure,imshow(b); se=strel(‘rectangle’,[10,5]);ferode=imerode(b,se);figure,imshow(ferode); brecon=imreconstruct(ferode,b);figure,imshow(brecon); [hs,ws]=find(brecon);a=min(hs);b=max(hs);c=min(ws);d=max(ws);finalbrecon=brecon(a:b,c:d);figure,imshow(finalbrecon); 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121306-300x273.jpg)","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Matlab彩色图像之人脸提取","slug":"matlab彩色图像之人脸提取","date":"2017-12-12T17:36:34.000Z","updated":"2020-07-05T08:56:51.102Z","comments":false,"path":"2017/12/13/matlab彩色图像之人脸提取/","link":"","permalink":"http://yoursite.com/2017/12/13/matlab%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E4%B9%8B%E4%BA%BA%E8%84%B8%E6%8F%90%E5%8F%96/","excerpt":"","text":"提取下图中的人脸，大致操作步骤： rgb**--ycbcr--获取cr分量--根据肤色范围提取ROI–二值化--小对象去除--填充坑洞--垂直投影--根据投影分割成薯条--根据垂直投影分割图使用find找到最高行、最低行--根据坐标分割原图** [ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121301-300x201.jpg) clear,clc,close all;f=imread(‘qqm.jpg’);imshow(f);fycc=rgb2ycbcr(f); %rgb-&gt;ycbcrcr=fycc(:,:,3); %获取cr分量cr(cr&gt;140&amp;cr&lt;160)=255; %根据肤色范围提取ROIcr(cr~=255)=0;cr=im2bw(cr);cr=bwareaopen(cr,200); %删除小对象cr=imfill(cr,’holes’); %填充坑洞figure,imshow(cr); sumh=sum(cr);figure,plot(sumh); %垂直投影[h.w]=size(cr);a=1;b=1;while(sumh(a)==0) a=a+1;endb=a;while(sumh(b)&gt;0) b=b+1;endcrsplit=cr(:,a:b);figure,imshow(crsplit);[rs,cs]=find(crsplit); %使用find找到最高行,最低行c=min(rs);d=max(rs);result=f(c:d,a:b,:);figure,imshow(result); 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/12/17121302-300x191.jpg)","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Unity标准Shader之四大渲染模式","slug":"标准shader之四大渲染模式","date":"2017-11-29T07:21:29.000Z","updated":"2020-07-05T11:22:19.610Z","comments":false,"path":"2017/11/29/标准shader之四大渲染模式/","link":"","permalink":"http://yoursite.com/2017/11/29/%E6%A0%87%E5%87%86shader%E4%B9%8B%E5%9B%9B%E5%A4%A7%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一.四大渲染模式 1.Opaque（不透明） 作用：用于渲染所有不透明的物体，这类物体在场景中是最多的。60%的使用比例。 演示：渲染一个红色的Cylinder。 创建一个Opaque模式的材质球拖到物体身上，调节Albedo颜色： 2.Cutout（镂空） 作用：用于渲染有镂空的物体，这类物体在场景中并不太多。5%的使用比例。 例如：一块破布上面有几个洞，一张残缺不全的纸。 演示：渲染一个镂空的金属网格。 创建Cutout模式的材质球放到cube身上，并设置贴图： 可以看到图中的cube并不是镂空的，我们需要设置一下贴图的Alpha通道值.将贴图的Input Texture Alpha设置成From Gray Scale，点击Apply，可以看到图片镂空了，部分还消失了。 Input Texture Alpha:从图片的Alpha通道取值，该图片没有Alpha通道，所以不应该用这个属性。 From Gray Scale：从灰度值计算Alpha通道。 手动调节Cutout材质球的Alpha Cutoff值，最终效果如下： 3.Fade（隐现） 作用：用于渲染实现物体的渐隐和渐现。这类物体在场景中也不多。5%的使用比例。 演示：使用Albedo 的颜色值中的Alpha 控制模型隐现。 创建Fade模式的材质球放到cube身上，并设置Alpha值 调小Alpha的值： 4.Transparent（透明） 作用：用于渲染有透明效果的物体，这类物体在场景中也比较多。30%的使用比例。 演示：使用Albedo 的颜色值中的Alpha 控制模拟一块玻璃。 创建Transparent模式的材质球放到cube身上，并设置Alpha值，Metallic的值以及Smoothness的值。 二.标准Shader 功能布局 1.渲染模式区域 当创建完一个材质球，并设置Shader 为标准着色器后，第一步就需要根据这个材质球要渲染的物体的特性（不透明物体，透明物体）设置不同的渲染模式。 2.主贴图区域 用于设置Shader 的主要贴图，使用这个区域的贴图和设置项控制模型最终的渲染效果。80%的模型，我们只需要设置这个位置的贴图就够用了。 3.次贴图区域 用于设置Shader 的次要贴图，用于给模型增加细节。一般不会用到这个位置的设置项。但是一些需要近距离观察的模型，设置完上方的主贴图，再设置下方的次要贴图，能增加模型的精致度。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112915-174x300.png)","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"Unity天空盒与内置Shader基础","slug":"unity天空盒与内置shader基础","date":"2017-11-28T16:09:13.000Z","updated":"2020-07-05T11:22:19.620Z","comments":false,"path":"2017/11/29/unity天空盒与内置shader基础/","link":"","permalink":"http://yoursite.com/2017/11/29/unity%E5%A4%A9%E7%A9%BA%E7%9B%92%E4%B8%8E%E5%86%85%E7%BD%AEshader%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一.颜色空间 1.两种颜色空间 Gamma 空间：移动端，页游，HoloLens，性能比较低的硬件设备。 Linear 空间：PC 端，主机端。 Unity 默认的颜色空间（Color Space）设置选项是选择为Gamma，但是如果我们使用PBR 渲染流程（标准着色器）就必须将颜色空间修改为Linear。 2.修改颜色空间 Edit –&gt; Project Settings –&gt; Player –&gt; Other Settings –&gt;Rendering –&gt; Color Space –&gt; Linear [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112901-287x300.jpg) 二.天空盒 1.天空盒的作用 ①用于渲染显示天空和周围的环境； ②作为场景中的辅助光源。 2.制作天空盒 ①导入“HDR 环境贴图”素材图片； ②将HDR 贴图的“Texture Shape”修改为Cube； [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112905-300x199.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112905.png) ③创建一个材质球，材质球选择Shader 为Skybox/Cubemap; ④将贴图素材赋予给材质球。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112902-300x192.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112902.png) 3.使用天空盒 方法一：Lighting 面板上的Skybox 选项设置要使用的天空盒。 方法二：直接将天空盒拖拽到场景中。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112904-300x240.jpg) 4.天空盒材质参数调整 1.Exposure：调整贴图的亮度。 2.Rotation：旋转贴图，很多时候贴图上有太阳，我们可以通过旋转让贴图上的太阳和场景里面的方向光重叠。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112907-300x191.png) 最终效果：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112903-300x252.jpg) 三.内置Shader Unity 中内置的Shader 分可以分为三组，他们具备不同的作用和使用场合： 1.Unity5.x 新Shader 2.Unity5.x 标准Shader（用于PBR 渲染） 3.Unity4.x 旧版Shader（用于支持旧版项目的渲染） [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112906-249x300.png)","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"}]},{"title":"UGUI之表格布局组件Grid Layout Group","slug":"ugui之表格布局组件grid-layout-group","date":"2017-11-28T12:45:25.000Z","updated":"2020-07-05T11:23:24.325Z","comments":false,"path":"2017/11/28/ugui之表格布局组件grid-layout-group/","link":"","permalink":"http://yoursite.com/2017/11/28/ugui%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6grid-layout-group/","excerpt":"","text":"一.Grid Layout Group 组件 Grid Layout Group：表格(网格)布局组件，可以让数据按表格的形式排列。 Cell Size：子物体尺寸； Spacing：子物体之间的间距； Start Corner：子物体开始的角度位置； Start Axis：子物体开始的轴向； Child Alignment：子物体对其方式； Constraint：约束方式，灵活–灵活列数–灵活行数； Padding：控制所有子物体的整体的外边距。 二.签到页面案例 数据量有限，在一个界面内能直接显示完毕，不需要滑屏滚动。 层级结构： Image [背景图片] |—Grid Layout Group [表格布局组件] |—Item [N 个同级别的子物体] 如图所示,这里EMPTY中的Rect Transform的Width和Height跟BG背景数值一样大。[ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112811-300x186.png) 二.背包页面案例 数据量很大，在一个界面内无法直接显示完毕，需要使用上下滑屏来显示数据。 层级结构： Image + ScrollRect + Mask [背景图片，滑动组件，区域遮罩] |—Grid Layout Group [表格布局组件] |—Item [N 个同级别的子物体] 操作步骤，在案例一的基础上： 第一步:在BG上加入Mask组件，起到遮罩的作用，再加入ScrollRect 组件，取消勾选Horizontal是问了不让它左右滑动，再将EMPTY拖入到ScrollRect 的Comtent中。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112812-298x300.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112812.png) 第二步:再EMPTY中加入Content Size Fitter组件，进行内容尺寸的过滤，并设置Vertical Fit为Preferred Size。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112813-300x240.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112813.png) 最终效果就是下面的动态图： [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112814-300x183.gif)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件CanvasScaler画布定位","slug":"ugui之ui组件canvasscaler画布定位","date":"2017-11-28T10:24:59.000Z","updated":"2020-07-05T11:23:24.319Z","comments":false,"path":"2017/11/28/ugui之ui组件canvasscaler画布定位/","link":"","permalink":"http://yoursite.com/2017/11/28/ugui%E4%B9%8Bui%E7%BB%84%E4%BB%B6canvasscaler%E7%94%BB%E5%B8%83%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"一.Canvas Scaler 组件介绍 在Unity 项目开发过程中，对于UI 界面有一个很关键的技术，叫做“屏幕自适应”，就是说我们的游戏UI要能自动适配不同的屏幕比例和屏幕尺寸。 在UGUI 中用于实现“屏幕自适应”需要用到两个组件： ①AnChors [锚点] ②Canvas Scaler [画布定位器] 这两个组件配合使用，才能相对完美的实现UI 屏幕自适应的开发需求。 Canvas Scaler 组件有三种定位模式： ①Constant Pixel Size ②Scale With Screen Size ③Constant Physical Size 二.Constant Pixel Size 模式 1.模式介绍 该模式可以称之为“恒定(固定)像素大小模式”，UGUI 默认就是该模式。 该模式下的Scale Factor 参数会作用于Canvas 游戏物体的Scale 参数。 在该模式下无论屏幕尺寸发生什么样的变化，UI 元素的大小都不会改变。 2.相关属性 Scale Factor：比例因子，默认保持为1 即可； Reference Pixels Per Unit：参考像素单位，默认保持为100 即可。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112808-300x287.png) 三.Scale With Screen Size 模式 1.模式介绍 该模式可以称之为“跟随屏幕尺寸缩放模式”，在手游项目开发中，使用该模式。 该模式下UI 元素的尺寸就不是固定的了，会跟随屏幕的尺寸比例进行相应的自动缩放。 2.相关属性 Reference Resolution：参考分辨率，设置成项目开发时使用的分辨率。 Screen Match Mode：屏幕匹配模式，推荐用第一种模式。 |—Match Width Or Height [匹配宽度或者高度] |—Expand [扩大] —Shrink [缩小] Match：匹配，当屏幕匹配模式选择为Match Width Or Height 时该属性有效。 一个滑块控制条，0~1，代表宽和高。 横屏游戏用Height 匹配，竖屏游戏用Width 匹配[以短方向进行匹配]。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112809-282x300.jpg) 四.Contant Physical Size 模式 该模式可以称之为“恒定(固定)的物理尺寸”，和Constant Pixel Size类似，但是只能通过RectTransform来改变大小,在该模式下UI 元素永远保持固定的物理尺寸，使用场合较少. [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112810-288x300.jpg) 总结： Constant Pixel Size和Scale With Screen Size，都是“固定模式”不适合手游项目的开发，手游由于屏幕分辨率不统一，必须要做UI 自适应，所以选择Scale With Screen Size 模式。 目前只靠这个模式还无法完成自适应，还需要用到AnChors 组件。","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Canvas画布","slug":"ugui之ui-组件canvas-画布","date":"2017-11-28T09:08:25.000Z","updated":"2020-07-05T11:23:24.159Z","comments":false,"path":"2017/11/28/ugui之ui-组件canvas-画布/","link":"","permalink":"http://yoursite.com/2017/11/28/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6canvas-%E7%94%BB%E5%B8%83/","excerpt":"","text":"一.Canvas 组件介绍 Canvas 组件的用途是用于UGUI 系统内的UI 游戏物体的渲染。 如果没有该组件，所有的UGUI 游戏物体都将无法显示。 而Canvas 组件本身又分为三种渲染模式： ①Screen Space - Overlay ②Screen Space - Camera ③World Space 这三种渲染模式分别用于不同的渲染需求，Canvas 组件上其余的属性都是根据我们选择的不同的渲染模式，而跟随发生改变的。 也就是说：不同的渲染模式，对应不同的控制属性。 二.Overlay 模式 1.模式介绍 该模式全称是Screen Space-Overlay（屏幕空间-覆盖模式）。 屏幕空间：指的是电脑或者手机显示屏的2D 空间，x 轴和y 轴； 覆盖模式：指的是UI 元素永远在3D 元素的前面，UI 覆盖3D； Canvas 创建出来后，默认就是该模式。 备注：该模式和摄像机无关，即使场景内没有摄像机，UI 游戏物体照样渲染。 在Overlay 模式下，UGUI 和摄像机无关。 2.相关属性 Pixel Perfect：完美像素，UI 和屏幕像素对应，UI 图片不会出现锯齿边缘； Sort Order：排序层，用于设置画布的深度层级（场景存在多个Canvas 时）； 在同一个场景内是允许出现多个UGUI 的Canvas 画布 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112805-300x300.jpg) 三.Camera 模式 1.模式介绍 该模式全称是Screen Space-Camera（屏幕空间-摄像机模式）。 摄像机模式：设置成该模式后，需要指定一个摄像机游戏物体，指定完毕后，UGUI 就会自动出现在该摄像机的“投射范围”内。 如果现在隐藏掉摄像机游戏物体，UGUI 也是无法渲染显示的。 2.相关属性 Render Camera：渲染摄像机，指定用于渲染UGUI 元素的摄像机； Plane Distance：面板距离，控制UGUI 元素和摄像机之间的距离。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112806-274x300.png) 四.WorldSpace 模式 1.模式介绍 该模式全称就是WorldSpace（世界空间模式）。 世界空间模式：是相对于屏幕空间而言的，世界空间是x，y，z 三个轴向。 设置成该模式后，UGUI 就相当于是场景内的一个普通的“Cube 游戏模型”，我们可以在场景内任意的移动UGUI 元素的位置。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112807-294x300.jpg)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件ScrollRect卷动区域","slug":"ugui之ui-组件scrollrect-卷动区域","date":"2017-11-28T07:19:28.000Z","updated":"2020-07-05T11:23:24.254Z","comments":false,"path":"2017/11/28/ugui之ui-组件scrollrect-卷动区域/","link":"","permalink":"http://yoursite.com/2017/11/28/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6scrollrect-%E5%8D%B7%E5%8A%A8%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"一.ScrollRect 组件介绍 1.ScrollRect：卷动区域。 “卷动区域”是在ScrollBar 的基础之上延伸出来的UI 界面效果。 单独是ScrollBar 组件是无意义的，需要结合ScrollRect 才能真正实现功能。 2.ScrollRect 组成部分分析 ScrollRect Image [核心组件，背景图片] |—Mask Image [遮罩，用于遮罩的图片] |—空物体[用于卷动显示的数据] |—横向卷动条[ScrollBar 游戏物体] |—纵向卷动条[ScrollBar 游戏物体 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112803-300x165.jpg) 3.ScrollRect 多种展现形态 无卷动条：当数据区域的数据量没有超过Mask 范围的时候； 纵向卷动条：当数据量纵向比较多的时候； 横向卷动条：当数据量横向比较多的时候。 二.ScrollRect 组件属性 1.基本控制属性 Content：ScrollRect 控制的数据区域； Horizontal：控制数据是否可以横向拖动； Vertical：控制数据是否可以纵向拖动； Movement Type：三种运动类型；[不限制– 弹性– 不动] 2.引用控制属性 Viewport：视口区域的引用； Scrollbar：Scrollbar 游戏物体的引用； Visibilty：卷动条的清晰度，保持默认即可[第三个]； Spacing：控制卷动条和数据区域之间的间距。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112804-279x300.png) 三.ScrollRect 事件绑定 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class tempUGUI : MonoBehaviour { private ScrollRect m\\_ScrollRect; void Start () { m\\_ScrollRect = gameObject.GetComponent&lt;ScrollRect&gt;(); m\\_ScrollRect.onValueChanged.AddListener(ScrollRectValueChange); } private void ScrollRectValueChange(Vector2 value){ Debug.Log(value.x+&quot; &quot;+value.y); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件InputField输入栏","slug":"ugui之ui-组件inputfield-输入栏","date":"2017-11-27T17:52:55.000Z","updated":"2020-07-05T11:23:24.188Z","comments":false,"path":"2017/11/28/ugui之ui-组件inputfield-输入栏/","link":"","permalink":"http://yoursite.com/2017/11/28/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6inputfield-%E8%BE%93%E5%85%A5%E6%A0%8F/","excerpt":"","text":"一.InputField 组件介绍 1.InputField：输入栏，输入框。 输入栏的主要用途是接收用户输入的单行数据，常见于输入用户名，密码。 2.InputField 组成部分分析 InputField Image [整体控制组件，背景图片] |—Text [提示文本] |—Text [接收用户输入的文本] [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112801-300x177.jpg) 二.InputField 组件特有属性 Text Component：用于接收显示用户输入内容的Text 组件； Text：在该区域输入的文本会直接显示在Text 组件上； Character Limit：字符限制，表示该输入框能输入的最大长度，0 表示不限制； Content Type：内容类型，用于限制输入的数据类型； |—Standard（标准类型）：什么字符都能输入，只要是当前字体支持的。 |—Integer Number（整数类型）：只能输入一个整数。 |—Decimal Number（十进制数）：能输入整数或小数。 |—Alpha numeric（文字和数字）：能输入数字和字母。 |—Name（姓名类型）：能输入英文及其他文字，当输入英文时自动姓名化（首字母大写）。 |—Password（密码类型）：输入的字符隐藏为星号。 Line Type：行类型，用于设置输入栏是单行还是多行； |—Single Line：单行模式，也是默认模式； |—Multi Line Submit：多行，不支持回车键换行； |—Multi Line NewLine：多行，支持回车键换行。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112802-192x300.jpg) 三.InputField 事件绑定 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class tempUGUI : MonoBehaviour { private InputField m\\_InputField; void Start () { m\\_InputField = gameObject.GetComponent&lt;InputField&gt;(); //当值改变事件 m\\_InputField.onValueChanged.AddListener(InputFieldValueChange); //当停止编辑事件，即输入结束 m\\_InputField.onEndEdit.AddListener(InputFieldValueStop); } private void InputFieldValueChange(string value){ Debug.Log(value); } private void InputFieldValueStop(string value) { Debug.Log(&quot;输入结束&quot;+value); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Scrollbar卷动条","slug":"ugui之ui-组件scrollbar-卷动条","date":"2017-11-27T08:34:06.000Z","updated":"2020-07-05T11:23:24.193Z","comments":false,"path":"2017/11/27/ugui之ui-组件scrollbar-卷动条/","link":"","permalink":"http://yoursite.com/2017/11/27/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6scrollbar-%E5%8D%B7%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"一.Scrollbar 介绍 Scrollbar：卷动条。浏览器最右边竖向的下滑条就是卷动条的例子。 二.Scrollbar 组成部分分析 Scrollbar Image [整体功能控制+ 背景图片显示] |—空物体[控制子物体活动范围] |—Image [滑块图片] [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112701-300x179.jpg) 三.Scrollbar 组件特有属性 Size：用于控制滑块的大小； Number Of Steps：用于控制滑块每次移动的步长。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112702-245x300.jpg) 四.Scrollbar 事件监听 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class tempUGUI : MonoBehaviour { private Scrollbar m\\_Scrollbar; void Start () { m\\_Scrollbar = gameObject.GetComponent&lt;Scrollbar&gt;(); m\\_Scrollbar.onValueChanged.AddListener(ButtonClickTest); } private void ButtonClickTest(float value){ Debug.Log(value); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Slider滑块","slug":"ugui之ui-组件slider-滑块","date":"2017-11-25T15:49:59.000Z","updated":"2020-07-05T11:23:24.253Z","comments":false,"path":"2017/11/25/ugui之ui-组件slider-滑块/","link":"","permalink":"http://yoursite.com/2017/11/25/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6slider-%E6%BB%91%E5%9D%97/","excerpt":"","text":"一.Slider 组成 1.Slider：滑块 Slider 一般是由两部分组成：滑块，滑动条。 2.Slider 组件[核心控制组件] |—Image 组件[Slider 的背景图片] |—空物体[用于控制填充图片的活动范围] |—Image 组件[填充图片] |—空物体[用于控制滑块图片的活动范围] |—Image 组件[滑块图片] [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112511-300x144.jpg) 二.Slider 组件属性 1.基本属性 Slider 组件的一部分属性和Toggle，Button 是一样的。 需要通过单击操作来触发的UI 组件，他们都有一部分属性是相同的。 2.特有属性 Fill Rect：滑块条游戏物体的Transform； Handle Rect：滑块游戏物体的Transform； Direction：滑块的滑动方向； Min Value：滑块组件最小值； Max Value：滑块组件最大值； Whole Numbers：整数，勾选后Slider 只能整数控制； Value：当前滑块组件的值。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112512-219x300.jpg) 三.Slider 事件监听 监听Slider 组件的值改变事件： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class tempUGUI : MonoBehaviour { private Slider m\\_Slider; void Start () { m\\_Slider = gameObject.GetComponent&lt;Slider&gt;(); m\\_Slider.onValueChanged.AddListener(ButtonClickTest); } private void ButtonClickTest(float value){ Debug.Log(value); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Toggle复选框","slug":"ugui之ui-组件toggle-复选框","date":"2017-11-25T08:36:22.000Z","updated":"2020-07-05T11:23:24.289Z","comments":false,"path":"2017/11/25/ugui之ui-组件toggle-复选框/","link":"","permalink":"http://yoursite.com/2017/11/25/ugui%E4%B9%8Bui-%E7%BB%84%E4%BB%B6toggle-%E5%A4%8D%E9%80%89%E6%A1%86/","excerpt":"","text":"一.Toggle 组件介绍 1.Toggle：切换键，复选框。[简单演示] 2.Toggle 组成部分分析 Toggle 组件[核心组件，用于控制整个UI 游戏物体] |—Image 组件[背景图片] | |—Image 组件[复选标记，只要当选中时，该图片才会显示] |—Text 组件[功能文字描述] [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112509-300x150.jpg) 二.Toggle 组件属性 1.基本属性 Toggle 组件和Button 组件的基本属性是比较类似的，所以这里不再写了。可以去看看button组件。 2.特有属性 Is On：表示当前Toggle 的状态，是选中还是未选中。另外该属性只是响应 UI 的状态切换，在面板上操作该属性不会影响UI 状态。 Target Graphic：对应的是Toggle 的背景图； Graphic：对应的是Toggle 的选中图。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112510-254x300.png) 三.Toggle 事件监听 1.“当值改变事件”监听 m_Toggle.onValueChanged.AddListener(ToggleChanged); 2.通过代码改变Toggle 状态 m_Toggle.isOn = true; using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class tempUGUI : MonoBehaviour { private Toggle m\\_Toggle; void Start () { m\\_Toggle = gameObject.GetComponent&lt;Toggle&gt;(); m\\_Toggle.onValueChanged.AddListener(ButtonClickTest); } void Update(){ if (Input.GetKeyDown(KeyCode.W)){ m\\_Toggle.isOn = false; } else if (Input.GetKeyDown(KeyCode.S)){ m\\_Toggle.isOn = true; } } private void ButtonClickTest(bool temp){ Debug.Log(temp); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Button按钮","slug":"ugui之ui组件button按钮","date":"2017-11-25T08:04:47.000Z","updated":"2020-07-05T11:23:24.319Z","comments":false,"path":"2017/11/25/ugui之ui组件button按钮/","link":"","permalink":"http://yoursite.com/2017/11/25/ugui%E4%B9%8Bui%E7%BB%84%E4%BB%B6button%E6%8C%89%E9%92%AE/","excerpt":"","text":"一.Button 面板属性 1.基本属性 Interactable：是否可用，表示当前的按钮是否可以交互。 Transition：过渡，Color Tint 和Sprite Swap以及Animation。 项目开发过程中，最常用的就是图片过渡方式，按钮交互过程中，切换不同的图片进行状态的展示。 2.颜色过渡(Color Tint) Normal Color：默认颜色 Highlighted Color：高亮颜色 Pressed Color：按下颜色 Disabled Color：不可用颜色 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112506-238x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112506.jpg) 3.图片过渡(Sprite Swap) Target Graphic：默认图片，按钮要控制改变的组件。 Highlighted Sprite：高亮图片，鼠标进入就会触发；点击按钮后，如果不点击其他位置，则一直触发。项目开发过程中，**该图片可以为空**。 Pressed Sprite：按下图片，鼠标按下切换成该状态。 Disabled Sprite：不可用图片，按钮禁用后显示的图片 这里Target Graphic用的图片就是图中Image组件的图片。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112507-265x300.png) 4.播放动画过渡模式(Animation) Normal Trigger（默认触发器）：默认状态触发。 Highlighted Trigger（高亮触发器）：选中状态或是鼠标靠近会进入高亮状态。 Pressed Trigger（按下触发器）：鼠标点击或是按钮处于选中状态时按下enter键。 Disabled Trigger（禁用触发器）：禁用时触发。 Auto Generate Animatior（自动生成动画控制器）： 点击此按钮，会自动生成一个包含了以上四种状态以及四种动画的animatior [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112508-259x300.jpg) 二.Button 事件绑定 1.事件绑定介绍 当我们点击按钮后，需要执行代码逻辑，这个代码逻辑，往往封装到一个方法内，然后和当前按钮的单击事件进行绑定。 2.属性面板绑定[不推荐使用] ①创建一个脚本，挂载到按钮游戏物体上，编写一个无参无返回值且公开的方法； ②属性面板上的OnClick 面板添加一个新的项； ③拖拽当前的这个脚本赋值给新添加的项； ④在Function 的位置选择对应的方法。 3.代码绑定 ①在脚本内编写一个无参无返回值且私有的方法； ②代码查找到Button 游戏物体并存储为对象； ③Button 对象.onClick.AddListener(方法名)。 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class tempUGUI : MonoBehaviour { private Button m\\_Button; // Use this for initialization void Start () { m\\_Button = gameObject.GetComponent&lt;Button&gt;(); m\\_Button.onClick.AddListener(ButtonClickTest); } private void ButtonClickTest(){ Debug.Log(&quot;www.wjgbaby.com&quot;); }}","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Image图片","slug":"ugui之ui组件image图片","date":"2017-11-25T06:02:17.000Z","updated":"2020-07-05T11:23:24.308Z","comments":false,"path":"2017/11/25/ugui之ui组件image图片/","link":"","permalink":"http://yoursite.com/2017/11/25/ugui%E4%B9%8Bui%E7%BB%84%E4%BB%B6image%E5%9B%BE%E7%89%87/","excerpt":"","text":"一.Image 组件 使用方式有两种：1.显示纯粹的颜色；2.指定图片源，用于显示图片。 注意事项：导入Unity 内的图片资源，如果是用于UI 显示的，需要手动将这些图片的类型修改为“Sprite(2D and UI)”。 二.组件面板核心属性 Source Image：设置用于显示的图片。 Color：设置用于显示的颜色。 两个“数据源”可以分开使用，也可以同时使用，如果同时时候，颜色会改变图片的显示色调。如果使用图片，那么颜色就要设置成白色，否则会影响图片效果。 Set Native Size：设置图片以原始尺寸显示。 设置完图片，首先就需要点击一下该按钮，保证图片是原始尺寸比例。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112505-246x300.png) 三.Image 四种显示方式 1.Image Type：图片显示类型 Simple：简单模式–&gt; 60% Sliced：九宫模式–&gt; 20% Tiled：平铺模式–&gt; 几乎不会用到 Filled：填充模式–&gt; 20% 2.Simple 简单模式 Preserve Aspect：勾选后图片会等比例进行缩放，不会变形。 3.Sliced 九宫模式 注意：默认的图片是不支持该模式的，需要编辑图片，设置图片的九宫边框。 设置边框的步骤： ①选中图片-&gt;属性区域点击“Sprite Editor”; ②在编辑面板，设置图片的Border 边框数值； ③设置完毕后，不要忘记点击Apply 保存操作。 操作： 设置完毕边框后，对图片进行横向或者纵向拉伸，这个时候图片就会以图片的中心区域进行拉伸，不会拉伸图片的边框效果。 4.Tiled 平铺模式 操作：设置成了该模式后，改变图片区域的大小，图片就会以瓷砖平铺的方式进行显示。 如果使用的图片设置了九宫边框，则只会平铺中间区域，不会平铺边框。 5.Filled 填充模式 Fill Method：填充方式；水平，垂直，或者角度量； Fill Origin：填充起点；跟随填充方式发生改变； Fill Amount：填充量；0~1 表示从无到填充满。","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"UGUI之UI组件Text文本","slug":"ugui之ui组件text文本","date":"2017-11-24T19:18:53.000Z","updated":"2020-07-05T11:23:24.325Z","comments":false,"path":"2017/11/25/ugui之ui组件text文本/","link":"","permalink":"http://yoursite.com/2017/11/25/ugui%E4%B9%8Bui%E7%BB%84%E4%BB%B6text%E6%96%87%E6%9C%AC/","excerpt":"","text":"UGUI虽然不是太难的东西，但是知识点还是很多的。目前UGUI学的不精，因此有系统的完整学习一遍是很有必要的，我会尽量把笔记做详细，方便以后回顾。 一.Canvas 形态 当我们鼠标选中Canvas 游戏物体后，在Scene 面板会显示一个白色边框，虽然四个角都有“调节点”，但是这个的范围是不可以手动调节的，如下图所示，Rect Transform不可以调节： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112501-300x200.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112501.jpg) 这个Canvas 的宽和高是自动适配当前的Scene 视图的宽和高的，也就是说会跟随Scene 视图的形态发生宽和高的改变。 如果出现“奇怪的形状”,那是因为你的Scene 的奇怪比例导致的，如下图所示： [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112502-269x300.jpg) 在当前状态最常用的操作是：手型工具，2D 工具。 二.Text 游戏物体组成部分 ①Rect Transform：用于控制UI 物体的基本属性。 ②Canvas Renderer：画板UI 渲染器，UI 游戏物体必备且不可编辑的组件。 ③Text 组件：当前UI 物体的的核心组件。 ④Default UI Material：默认UI 材质球，UI 的显示也是需要材质球的。 备注： ①②④是所有的UGUI 游戏物体必备的组件，其实UI 的形态改变，就是通过使用不同的UI 组件来实现的。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112503-155x300.jpg) 三.Text 面板属性 Text：文本 控制当前的UI 游戏物体要显示的文本内容。 Font：字体 控制文字显示的样子；Unity 支持的字体格式是TTF 格式。 在企业项目开发中，一款游戏，一般会使用到三到五款字体文件。 Font Style：字体样式 正常字体，加粗，倾斜，加粗并且倾斜。 这样的字体样式在Word，Excel，Web 开发都是有的，最基础的字体美化。 Font Size：字体大小 控制字体的显示大小，但是当字体很大的时候，需要配合调整当前区域的宽和高，否则字体将因为空间太小，无法显示。 Line Spacing：行间距 当Text 内的文本是多行数据的时候，控制行与行之间的间隔空隙。 Rich Text：富文本支持 勾选开启后，我们可以在Text 内编写富文本标签。 比如：&lt;color=“red”&gt;www.wjgbaby.com Alignment：对其方式 控制文本在区域内的九宫显示位置。 Horizontal Overflow：水平溢出 Wrap：文本将自动换行，当达到水平边界 Overflow：文本可以超出水平边界，继续显示 Vertical Overflow：垂直溢出 Truncate：文本不显示超出垂直边界的部分 Overflow：文本可以超出垂直边界，继续显示 Best Fit：勾选后，编辑器会变化，显示Min Size和Max Size Min Size：最小大小 Max Size：最大大小 当边框很大时，文字最大显示Max Size字体大小；当边框很小时，文字最小显示Min Size字体大小，边框显示不了MinSize字体大小就不再显示文字了。 Color：颜色 控制文本显示的颜色。 Raycast Target：射线投射目标 当前游戏物体是否接受射线，如果取消勾选，射线将会直接穿透该物体，勾选则会阻挡射线。 备注：UGUI 的UI 交互，是系统以鼠标点击位置发射射线与UI 进行交互的，比如说button按钮就是摄像机一直向按钮的UI发送射线，如果取消勾选Raycast Target，交互事件就不会执行。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112504-260x300.png)","categories":[],"tags":[{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"}]},{"title":"ULua服务器端基础与bug解决","slug":"ulua服务器端基础与bug解决","date":"2017-11-23T12:54:54.000Z","updated":"2020-07-05T11:24:00.943Z","comments":false,"path":"2017/11/23/ulua服务器端基础与bug解决/","link":"","permalink":"http://yoursite.com/2017/11/23/ulua%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B8%8Ebug%E8%A7%A3%E5%86%B3/","excerpt":"","text":"一.ULua服务器端简介 SimpleFramework 项目的根文件夹下有一个叫做Server 的文件夹,它是一个独立的VS 项目工程，可以 直接使用VS 打开该项目。[ 这个项目就是ULua ，和该程序进行网络通信，完整热更新资源的下载。 这个Server 项目就是Socket 方式. 二.服务器端使用 1.配置服务器端程序 VS 打开项目后，打开工程中的Service\\HttpServer.cs 脚本文件，以下是部分代码。 using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Net;using System.Text;using System.Threading;using System.Threading.Tasks; namespace SimpleFramework.Service { class HttpServer : HttpService { Thread thread; public HttpServer(int port) { host = &quot;http://localhost:6688/&quot;; } public void Start() { thread = new Thread(new ThreadStart(Listen)); thread.Start(); } public new void Stop() { base.Stop(); thread.Abort(); } string AssetPath { get { string exePath = Environment.CurrentDirectory; exePath = exePath.Replace(&apos;\\\\\\\\&apos;, &apos;/&apos;); exePath = exePath.Substring(0, exePath.IndexOf(&quot;/Server/&quot;)); return exePath + &quot;/Assets/StreamingAssets&quot;; } } string GetMimeType(string file) { string extName = Path.GetExtension(file.ToLower()); switch (extName) { case &quot;.png&quot;: return &quot;image/png&quot;; case &quot;.jpg&quot;: return &quot;image/jpeg&quot;; case &quot;.txt&quot;: return &quot;text/plain&quot;; default: return &quot;application/octet-stream&quot;; } }①配置服务器端ip 地址和端口 配置第15 行的host 中的ip ，为当前服务器电脑的ip，端口可以保持默认； 如果是在本地测试，这里的ip 就写我们当前电脑的ip 即可。 ②热更新资源目录，服务器端“给”客户端的资源存放在： 第28 行AssetPath 进行配置，默认位置就是我们项目的StreamingAssets文件夹下。 2.编译服务器端程序 生成–&gt;生成解决方案。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112306-300x137.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112306.png) 3.运行服务器端程序 编译后的程序：Server\\bin\\Debug\\SuperSocket.SocketService.exe [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112302-300x145.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112302.png) 鼠标选中这个可执行程序，右键-->以管理员权限运行，在弹出的黑窗口内输入“r”即可成功运行。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112303-300x143.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112303.jpg) 4.可能遇到的Bug 在运行编译后的服务器端程序的时候，可能会出现一个Bug。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112304-300x159.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112304.png) 该Bug 修复步骤(Win10 系统)： ①以管理员权限运行cmd； ②在cmd 窗口内输入命令：lodctr /r ，按回车执行； ③修复成功。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112305-300x166.png)","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"ULua配置AppConst和打包AssetBundle","slug":"ulua配置appconst和打包assetbundle","date":"2017-11-22T13:43:04.000Z","updated":"2020-07-05T11:24:00.952Z","comments":false,"path":"2017/11/22/ulua配置appconst和打包assetbundle/","link":"","permalink":"http://yoursite.com/2017/11/22/ulua%E9%85%8D%E7%BD%AEappconst%E5%92%8C%E6%89%93%E5%8C%85assetbundle/","excerpt":"","text":"一.框架配置文件 1.AppConst 文件 在SimpleFramework 这个框架项目中，有一个配置文件AppConst.cs， 该文件所在位置是：Scripts/ConstDefine/AppConst.cs。 在这个文件中配置了很多项目开发过程中，需要使用到的“公共常量信息”。 简单分析： 字段用“const”关键字修饰，方法用“static”关键字修饰，该脚本内所有的字段，方法，在外部脚本都可以使用“类名.xxxx”进行访问使用。 作用和价值： 该脚本的作用类似于“总控制台”，通过改变该脚本内的信息，就可以改变项目的一些核心状态。 AppConst.cs: using UnityEngine;using System;using System.Collections;using System.Collections.Generic; namespace SimpleFramework { public class AppConst { public const bool DebugMode = false; //调试模式-用于内部测试 /// &lt;summary&gt; /// 如果想删掉框架自带的例子，那这个例子模式必须要 /// 关闭，否则会出现一些错误。 /// &lt;/summary&gt; public const bool ExampleMode = true; //例子模式 /// &lt;summary&gt; /// 如果开启更新模式，前提必须启动框架自带服务器端。 /// 否则就需要自己将StreamingAssets里面的所有内容 /// 复制到自己的Webserver上面，并修改下面的WebUrl。 /// &lt;/summary&gt; public const bool UpdateMode = false; //更新模式-默认关闭 public const bool AutoWrapMode = true; //自动添加Wrap模式 public const bool UsePbc = true; //PBC public const bool UseLpeg = true; //lpeg public const bool UsePbLua = true; //Protobuff-lua-gen public const bool UseCJson = true; //CJson public const bool UseSproto = true; //Sproto public const bool LuaEncode = false; //使用LUA编码 public const int TimerInterval = 1; public const int GameFrameRate = 30; //游戏帧频 public const string AppName = &quot;SimpleFramework&quot;; //应用程序名称 public const string AppPrefix = AppName + &quot;\\_&quot;; //应用程序前缀 public const string WebUrl = &quot;http://localhost:6688/&quot;; //测试更新地址 public static string UserId = string.Empty; //用户ID public static int SocketPort = 0; //Socket服务器端口 public static string SocketAddress = string.Empty; //Socket服务器地址 public static string LuaBasePath { get { return Application.dataPath + &quot;/uLua/Source/&quot;; } } public static string LuaWrapPath { get { return LuaBasePath + &quot;LuaWrap/&quot;; } } }} 二.AssetBundle 文件 1.AB 打包命令 Game 菜单以及菜单下的子命令是通过uLua\\Editor\\Packager.cs 编辑器扩展脚本实现的。 2.框架案例AB 包 在我们执行完毕AB 打包命令后，在StreamingAssets 文件夹下，会出现3个后缀为“.assetbundle”的AB 包，这三个包就是Examples 示例工程需要使用到的AB 包。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112207-300x223.png) 演示： 将AppConst 脚本中的ExampleMode 修改为false，就不会再生成示例工程的AB 资源。 public class AppConst { public const bool DebugMode = true; //调试模式-用于内部测试 /// &lt;summary&gt; /// 如果想删掉框架自带的例子，那这个例子模式必须要 /// 关闭，否则会出现一些错误。 /// &lt;/summary&gt; public const bool ExampleMode = false; //例子模式如图所示：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112208-300x229.png) 3.生成自己的AB 包 将项目资源中的某个预制体设置Asset Labels 信息，然后使用Game 菜单下的命令打包成AB 资源。 你会发现我们自己的AssetBundle 文件无法打包成功。 需要分析Packager.cs 编辑器扩展脚本文件，Packager.cs原代码（部分）： \\[MenuItem(&quot;Game/Build Windows Resource&quot;, false, 13)\\] public static void BuildWindowsResource() { BuildAssetResource(BuildTarget.StandaloneWindows, true); } /// &lt;summary&gt; /// 生成绑定素材 /// &lt;/summary&gt; public static void BuildAssetResource(BuildTarget target, bool isWin) { if (AppConst.ExampleMode) { HandleExampleBundle(target); } HandleLuaFile(isWin); AssetDatabase.Refresh(); }分析结果如下： ①示例工程中的资源并没有手动指定AssetLabels 信息，而是在编辑器扩展脚本内，使用代码的方式，动态指定AssetLabels 信息，然后一个资源一个资源 单独打包成AB 包； ②如果想实现能打包我们自己的AssetBundle 资源，需要对该脚本进行修改。需要对AppConst.ExampleMode 为假的情况进行代码处理： 让脚本可以打包项目中所有指定了AssetLabels 信息的游戏物体为AB 包。 演示： 新建一个Sphere物体，设置AssetBundle文件名和后缀 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112209-300x120.png) Packager.cs改造后的代码： \\[MenuItem(&quot;Game/Build Windows Resource&quot;, false, 13)\\] public static void BuildWindowsResource() { BuildAssetResource(BuildTarget.StandaloneWindows, true); } /// &lt;summary&gt; /// 生成绑定素材 /// &lt;/summary&gt; public static void BuildAssetResource(BuildTarget target, bool isWin) { if (AppConst.ExampleMode) { HandleExampleBundle(target); } else { BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath, BuildAssetBundleOptions.None, target); } HandleLuaFile(isWin); AssetDatabase.Refresh(); }结果如下，成功生成Sphere的AB包 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112210-300x184.png) 4.可能出现的Bug 在打包AssetBundle 资源时，可能出现LuaWrap 文件夹下的脚本文件报错的情况，解决方法步骤如下：**先清空LuaWrap 文件，然后生成AB 资源，最后再重新生成LuaWrap 文件。** 三.Lua 和files 文件 1.Lua 文件夹 StreamingAssets 下的lua 文件夹内的代码在打包AB 资源的时候，一块复制过来的。在ULua 热更新环境下，lua 文件不会被打包成AB 资源，而是直接从服务器端下载.lua 原生文件到本地。 2.files.txt 文件 在StreamingAssets 文件夹下有一个叫做files.txt 的文本文件，这个文件叫做：热更新清单文件。 作用类似于AssetBundle 原生的“目录manifest 文件”。 files 文件内包含AB 包和Lua 文件的路径信息，以及用于校验的MD5 值。 因为ULua 环境下，lua 脚本不会打包成ab 包，也就意味着lua 脚本文件的信息不会出现在“目录manifest 文件”中，但是我们热更新的时候又需要知道更新哪些lua 文件，所以说出现了这个files.txt 热更新清单文件。","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"ULua框架之C#与Lua交互","slug":"ulua框架之c与lua交互","date":"2017-11-22T07:48:31.000Z","updated":"2020-07-05T11:24:00.949Z","comments":false,"path":"2017/11/22/ulua框架之c与lua交互/","link":"","permalink":"http://yoursite.com/2017/11/22/ulua%E6%A1%86%E6%9E%B6%E4%B9%8Bc%E4%B8%8Elua%E4%BA%A4%E4%BA%92/","excerpt":"","text":"一.uLua 文件夹结构 ①Core：uLua 核心； ②Docs：uLua 文档，其实就是LuaInterface 的PDF 使用文档； ③Editor：uLua 编辑器扩展； [备注：项目内所有的Editor 文件夹都是编辑器扩展文件夹，并不局限于根目录] ④Examples：uLua 自带演示案例； ⑤Source：cstolua 核心目录 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112201-227x300.png) 二.uLua 环境下的代码交互 1.基础介绍 在前面我们演示过在VS2013 环境下使用LuaInterface 项目中的两个DLL 文件来实现C#与Lua 的交互。 而在uLua 环境下本质也是通过LuaInterface 来实现Lua 与C#语言交互的。 但是uLua 对LuaInterface 进行了二次的封装，所以在代码书写上和原生的会稍有不同。 2.C#代码中执行Lua 代码 LuaState lua = new LuaState(); lua.DoString(); 说明: &lt;1&gt;同样需要在C#代码中引入LuaInterface； &lt;2&gt;原生的Lua 解析器对象“Lua”被二次封装成了“LuaState”； &lt;3&gt;LuaState 类存在的位置是：uLua\\Core\\Lua.cs。 3.Lua 代码中操作Unity 内的类[反射方式/ 原生方式] 创建一个游戏物体，名字叫wjg，有Box Colider ： using System.Collections;using System.Collections.Generic;using UnityEngine;using LuaInterface; public class LuaAndUnityTest : MonoBehaviour{ private string str = @” luanet.load_assembly(‘UnityEngine’) GameObject = luanet.import_type(‘UnityEngine.GameObject’) BoxCollider = luanet.import_type(‘UnityEngine.BoxCollider’) local player = GameObject(‘wjg’) player:AddComponent(luanet.ctype(BoxCollider)) “; // Use this for initialization void Start () { //创建Lua解析器对象 LuaState luaState = new LuaState(); luaState.DoString(str); }} 效果如图： 说明： &lt;1&gt;这种方式就是我们之前在VS 环境下演示的方式； &lt;2&gt;luanet 已经被封装到了LuaInterface 命名空间内，所以我们可以在Lua代码中直接使用luanet 这个对象； &lt;3&gt;在Lua 环境内操作C#中的类创建对象，不要写new 关键字！！！ &lt;4&gt;在Lua 环境内操作C#中的类创建对象，访问对象中的方法使用分号（:）； &lt;5&gt;这种“反射方式”在项目开发中并不常用，但是也有用无之地，真正大量使用的是下方的Wrap 方式。 4.包装新的Wrap 脚本 当我们用Lua 的Wrap 方式访问Unity 中的组件脚本，或者自己写的脚本的使 用，如果这些脚本没有自动生成“xxxxWrap”,项目运行后，就会报错。 遇到这种情况，我们就需要往框架的Wrap 生成器中添加我们要处理的新的类。 步骤如下： ①找到uLua\\Editor\\WrapFile.cs 打开该脚本， 使用该格式进行添加：_GT(typeof(类名)) ； ②Lua–&gt;Clear LuaBinder File + Wrap File 清空原有的Wrap 文件； ③Lua–&gt;Gen Lua Wrap Files 重新生成Wrap 文件； 这样就能看的新增的Wrap 脚本文件了。 演示：比如下面的Animator 脚本，如何生成Wrap 格式的文件 首先按③生成Wrap文件，在uLua\\Source\\LuaWrap可以看到没有Animator 的Wrap文件 添加_GT(typeof(Animator)) 清空原有Wrap文件，重新生成 5.Lua 代码中操作Unity 内的类[Wrap 方式] LuaScriptMgr lua = new LuaScriptMgr(); lua.Start(); 说明： &lt;1&gt;这种是在uLua 开发过程中最常用的方式，95%+情况都是使用这种方式； &lt;2&gt;Wrap 方式实现Lua 调用C#，依赖的是之前生成的LuaWrap 文件； [也就是我们通过菜单自动生成到uLua\\Source\\LuaWrap 下的脚本文件] &lt;3&gt;当使用Wrap 方式时，运行Lua 代码需要使用LuaScriptMgr； &lt;4&gt;需要把AppConst.cs 脚本中的的DebugMode 修改为true。 创建一个游戏物体，名字叫WJG，有Box Colider ，Animator： using System.Collections;using System.Collections.Generic;using UnityEngine;using LuaInterface; public class LuaAndUnityTest : MonoBehaviour{ private string str = @” luanet.load_assembly(‘UnityEngine’) GameObject = luanet.import_type(‘UnityEngine.GameObject’) BoxCollider = luanet.import_type(‘UnityEngine.BoxCollider’) local player = GameObject(‘wjg’) player:AddComponent(luanet.ctype(BoxCollider)) “; private string str02 = @&quot; luanet.load\\_assembly(&apos;UnityEngine&apos;) GameObject = UnityEngine.GameObject BoxCollider = UnityEngine.BoxCollider Animator = UnityEngine.Animator local player = GameObject(&apos;WJG&apos;) player:AddComponent(BoxCollider.GetClassType()) player:AddComponent(Animator.GetClassType()) &quot;; // Use this for initialization void Start (){ /\\* //创建Lua解析器对象 LuaState luaState = new LuaState(); luaState.DoString(str); \\*/ LuaScriptMgr luaScriptMgr = new LuaScriptMgr(); luaScriptMgr.Start(); luaScriptMgr.DoString(str02); }} 效果如图：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17112206-300x221.jpg)","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"STL二分查找算法","slug":"stl二分查找算法","date":"2017-11-19T08:33:11.000Z","updated":"2020-07-05T08:56:51.039Z","comments":false,"path":"2017/11/19/stl二分查找算法/","link":"","permalink":"http://yoursite.com/2017/11/19/stl%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"","text":"用binary_search进行二分查找 用法一：在从小到大排好序的基本类型数组上进行二分查找 binary_search(数组名+n1，数组名+n2,值); n1和n2都是int类型的表达式，可以包含变量 如果n1=0,则 + n1可以不写 查找区间为下标范围为[n1,n2)的元素，下标为n2的元素不在查找区间内 在该区间内查找”等于”值”的元素，返回值为true(找到）或false(没找到） “等于”的含义： a 等于 B &lt;=&gt; a &lt; b和b &lt; a都不成立 用法二：在用自定义排序规则排好序的、元素为任意的T类型的数组中进行二分查找 binary_search(数组名+n1，数组名+n2,值，排序规则结构名()); 查找时的排序规则，必须和排序时的规则一致！ binary_search用法实例： #include #include #include using namespace std;struct Rule //按个位数从小到大排{ bool operator()( const int &amp; a1,const int &amp; a2) { return a1%10 &lt; a2%10; }};void Print(int a[],int size) { for(int i = 0;i &lt; size;++i) { cout &lt;&lt; a[i] &lt;&lt; “,” ; } cout &lt;&lt; endl;}int main() { int a[] = { 12,45,3,98,21,7}; sort(a,a+6); Print(a,6); cout &lt;&lt;”result:”&lt;&lt; binary_search(a,a+6,12) &lt;&lt; endl; cout &lt;&lt;”result:”&lt;&lt; binary_search(a,a+6,77) &lt;&lt; endl; sort(a,a+6,Rule()); //按个位数从小到大排 Print(a,6); cout &lt;&lt;”result:”&lt;&lt; binary_search(a,a+6,7) &lt;&lt; endl; cout &lt;&lt;”result:”&lt;&lt; binary_search(a,a+6,8,Rule()) &lt;&lt; endl;//这里的8跟98的个位数相比 return 0;} 输出结果： 3,7,12,21,45,98, result:1 result:0 21,12,3,45,7,98, result:0 result:1 用lower_bound二分查找下界 用法一：在对元素类型为T的从小到大排好序的基本类型的数组中进行查找 T * lower_bound(数组名+n1,数组名+n2,值); 返回一个指针 T * p; *p 是查找区间里下标最小的，大于等于”值” 的元素。如果找不到，p指向下标为n2 的元素 用法二：在元素为任意的T类型、按照自定义排序规则排好序的数组中进行查找 T * lower_bound(数组名+n1,数组名+n2,值,排序规则结构名()); 返回一个指针 T * p; *p 是查找区间里下标最小的，按自定义排序规则，可以排在”值”后面的元素。如果找 不到，p指向下标为n2的元素 用upper_bound二分查找上界 用法一：在元素类型为T的从小到大排好序的基本类型的数组中进行查找 T * upper_bound(数组名+n1,数组名+n2,值); 返回一个指针 T * p; *p 是查找区间里下标最小的，大于”值”的元素。如果找不到，p指向下标为n2的元素 用法二：在元素为任意的T类型、按照自定义排序规则排好序的数组中进行查找 T * upper_bound(数组名+n1,数组名+n2,值,排序规则结构名()); 返回一个指针 T * p; *p 是查找区间里下标最小的，按自定义排序规则，必须排在”值”后面的元素。如果找 不到，p指向下标为n2的元素 lower_bound,upper_bound用法示例： #include #include #include using namespace std;struct Rule{ bool operator()( const int &amp; a1,const int &amp; a2) { return a1%10 &lt; a2%10; }};void Print(int a[],int size) { for(int i = 0;i &lt; size;++i) { cout &lt;&lt; a[i] &lt;&lt; “,” ; } cout &lt;&lt; endl;}#define NUM 7int main(){ int a[NUM] = { 12,5,3,5,98,21,7}; sort(a,a+NUM); Print(a,NUM); // =&gt; 3,5,5,7,12,21,98, int * p = lower_bound(a,a+NUM,5); cout &lt;&lt; *p &lt;&lt; “,” &lt;&lt; p-a &lt;&lt; endl; //=&gt; 5,1 p = upper_bound(a,a+NUM,5); cout &lt;&lt; *p &lt;&lt; endl; //=&gt;7 cout &lt;&lt; * upper_bound(a,a+NUM,13) &lt;&lt; endl; //=&gt;21 sort(a,a+NUM,Rule()); Print(a,NUM); //=&gt;21,12,3,5,5,7,98, cout &lt;&lt; * lower_bound(a,a+NUM,16,Rule()) &lt;&lt; endl; // =&gt; 7 cout &lt;&lt; lower_bound(a,a+NUM,25,Rule()) - a&lt;&lt; endl; // =&gt; 3 cout &lt;&lt; upper_bound(a,a+NUM,18,Rule()) - a &lt;&lt; endl; // =&gt; 7 if( upper_bound(a,a+NUM,18,Rule()) == a+NUM) cout &lt;&lt; “not found” &lt;&lt; endl; //=&gt; not found cout &lt;&lt; * upper_bound(a,a+NUM,5,Rule()) &lt;&lt; endl; // =&gt;7 cout &lt;&lt; * upper_bound(a,a+NUM,4,Rule()) &lt;&lt; endl; // =&gt;5 return 0;}","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"STL排序算法Sort","slug":"stl排序算法sort","date":"2017-11-18T14:17:51.000Z","updated":"2020-07-05T08:56:51.037Z","comments":false,"path":"2017/11/18/stl排序算法sort/","link":"","permalink":"http://yoursite.com/2017/11/18/stl%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95sort/","excerpt":"","text":"用sort进行排序 要使用STL其中的算法，需要#include sort(数组名+n1，数组名+n2） n1和n2都是int类型的表达式，可以包含变量 如果n1=0,则 + n1可以不写 将数组中下标范围为[n1,n2)的元素从小到大排序，下标为n2的元素不在排序区间内 用法一：对基本类型的数组从小到大排序 int a[] = {15,4,3,9,7,2,6};sort(a,a+7); //对整个数组从小到大排序 int a[] = {15,4,3,9,7,2,6};sort(a,a+3); // 结果：{3,4,15,9,7,2,6} int a[] = {15,4,3,9,7,2,6};sort(a+2,a+5); //结果：{15,4,3,7,9,2,6} 用法二：对元素类型为T的基本类型数组从大到小排序 sort(数组名+n1，数组名+n2,greater()） int a[] = {15,4,3,9,7,2,6};sort(a+1,a+4,greater()); //结果：{15,9,4,3,7,2,6} 用法三：用自定义的排序规则，对任何类型T的数组排序 sort(数组名+n1，数组名+n2,排序规则结构名()) 排序规则结构的定义方式： struct 结构名{ bool operator()( const T &amp; a1,const T &amp; a2) { //若a1应该在a2前面，则返回true //否则返回false。 }}; #include #include #include using namespace std; struct Rule1 //按从大到小排序{ bool operator()(const int &amp; a1, const int &amp; a2) { return a1 &gt; a2; }};struct Rule2 //按个位数从小到大排序{ bool operator()(const int &amp; a1, const int &amp; a2) { return a1 % 10 &lt; a2 % 10; }}; void Print(int a[], int size) { for (int i = 0; i &lt; size; ++i) cout &lt;&lt; a[i] &lt;&lt; “,”; cout &lt;&lt; endl;} int main(){ int a[] = { 12,45,3,98,21,7 }; sort(a, a + sizeof(a) / sizeof(int)); //从小到大 cout &lt;&lt; “1) “; Print(a, sizeof(a) / sizeof(int)); sort(a, a + sizeof(a) / sizeof(int), Rule1()); //从大到小 cout &lt;&lt; “2) “; Print(a, sizeof(a) / sizeof(int)); sort(a, a + sizeof(a) / sizeof(int), Rule2()); //按个位数从小到大 cout &lt;&lt; “3) “; Print(a, sizeof(a) / sizeof(int)); return 0;} 输出结果: 1) 3,7,12,21,45,98, 2) 98,45,21,12,7,3, 3) 21,12,3,45,7,98, 用sort对结构数组进行排序 #include #include #include using namespace std; struct Student { char name[20]; int id; double gpa;}; Student students [] = { {“Jack”,112,3.4},{“Mary”,102,3.8}, {“Mary”,117,3.9}, {“Ala”,333,3.5}, {“Zero”,101,4.0}}; struct StudentRule1 { //按姓名从小到大排 bool operator() (const Student &amp; s1,const Student &amp; s2) { if(_stricmp(s1.name,s2.name) &lt; 0) return true; return false; }};struct StudentRule2 { //按id从小到大排 bool operator() (const Student &amp; s1,const Student &amp; s2) { return s1.id &lt; s2.id; }};struct StudentRule3 {//按gpa从高到低排 bool operator() (const Student &amp; s1,const Student &amp; s2) { return s1.gpa &gt; s2.gpa; }}; void PrintStudents(Student s[], int size) { for (int i = 0; i &lt; size; ++i) cout &lt;&lt; “(“ &lt;&lt; s[i].name &lt;&lt; “,” &lt;&lt; s[i].id &lt;&lt; “,” &lt;&lt; s[i].gpa &lt;&lt; “) “; cout &lt;&lt; endl;} int main() { int n = sizeof(students) / sizeof(Student); sort(students, students + n, StudentRule1()); //按姓名从小到大排 PrintStudents(students,n); sort(students,students+n,StudentRule2()); //按id从小到大排 PrintStudents(students,n); sort(students,students+n,StudentRule3()); //按gpa从高到低排 PrintStudents(students,n); return 0;} 输出结果： (Ala,333,3.5) (Jack,112,3.4) (Mary,102,3.8) (Mary,117,3.9) (Zero,101,4) (Zero,101,4) (Mary,102,3.8) (Jack,112,3.4) (Mary,117,3.9) (Ala,333,3.5) (Zero,101,4) (Mary,117,3.9) (Mary,102,3.8) (Ala,333,3.5) (Jack,112,3.4)","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"二分法求方程的根","slug":"二分法求方程的根","date":"2017-11-17T15:03:01.000Z","updated":"2020-07-05T11:19:26.041Z","comments":false,"path":"2017/11/17/二分法求方程的根/","link":"","permalink":"http://yoursite.com/2017/11/17/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%96%B9%E7%A8%8B%E7%9A%84%E6%A0%B9/","excerpt":"","text":"求下面方程的一个根：f(x) = x3-5x2+10x-80 = 0 f(x)=x的3次方-5乘以(x的平方)+10x-80=0 若求出的根是a，则要求 |f(a)| &lt;= 10-6（小于等于10的负6次方） 解法：对f(x)求导，得f’(x)=3x2-10x+10（3乘以(x的平方)-10x=10）。由一元二次方程求根公式知方程 f’(x)= 0 无解，因此f’(x)恒大于0。故f(x)是单调递增的。易知 f(0) &lt; 0且f(100)&gt;0,所以区间[0,100]内必然有且只有一个根。由于f(x)在[0,100]内是单调的，所以可以用二分的办法在区间[0,100]中寻找根。 #include #include #include using namespace std;double EPS = 1e-6; double f(double x) { return x*x*x - 5*x*x + 10*x - 80;} int main() { double root, x1 = 0, x2 = 100, y; root = x1 + (x2 - x1) / 2; int triedTimes = 1; //记录一共尝试多少次 y = f(root); while (fabs(y) &gt; EPS) { if (y &gt; 0) x2 = root; else x1 = root; root = x1 + (x2 - x1) / 2; y = f(root); triedTimes++; } printf(“%.8f\\n”, root); printf(“%d”, triedTimes); return 0;} 输出结果： 5.70508593 32","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"二分查找函数","slug":"二分查找函数","date":"2017-11-17T14:57:27.000Z","updated":"2020-07-05T11:18:49.042Z","comments":false,"path":"2017/11/17/二分查找函数/","link":"","permalink":"http://yoursite.com/2017/11/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0/","excerpt":"","text":"1.写一个函数BinarySeach，在包含size个元素的、从小到大排序的int数组a里查找元素p,如果找到，则返回元素下标，如果找不到，则返回-1。要求复杂度O(log(n)) int BinarySearch(int a[], int size, int p)//复杂度O(log(n)){ int L = 0; //查找区间的左端点 int R = size - 1; //查找区间的右端点 while( L &lt;= R) { //如果查找区间不为空就继续查找 int mid = L+(R-L)/2; //取查找区间正中元素的下标 if( p == a[mid] ) return mid; else if( p &gt; a[mid]) L = mid + 1; //设置新的查找区间的左端点 else R = mid - 1; //设置新的查找区间的右端点 } return -1;} 2.写一个函数LowerBound，在包含size个元素的、从小到大排序的int数组a里查找比给定整数p小的，下标最大的元素。找到则返回其下标，找不到则返回-1 int LowerBound(int a[], int size, int p) //复杂度O(log(n)){ int L = 0; //查找区间的左端点 int R = size - 1; //查找区间的右端点 int lastPos = -1; //到目前为止找到的最优解 while( L &lt;= R) { //如果查找区间不为空就继续查找 int mid = L+(R-L)/2; //取查找区间正中元素的下标 if(a[mid]&gt;= p) R = mid - 1; else { lastPos = mid; L = mid+1; } } return lastPos;}","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"冒泡排序(Bubble Sort)","slug":"冒泡排序bubble-sort","date":"2017-11-17T14:48:30.000Z","updated":"2020-07-05T11:19:15.703Z","comments":false,"path":"2017/11/17/冒泡排序bubble-sort/","link":"","permalink":"http://yoursite.com/2017/11/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort/","excerpt":"","text":"1.将整个数组a分为有序的部分和无序的两个部分。前者在右，后者在左边。 2.开始，整个数组都是无序的。有序的部分没有元素。 3.每次要使得无序部分最大的元素移动到有序部分第一个元素的左边。移动的方法是：依次比较相邻的两个元素，如果前面的比后面的大，就交换他们的位置。这样，大的元素就像水里气泡一样不断往上浮。移动结束有序部分增加了一个元素。 4.直到无序的部分没有元素 void BubbleSort(int a[], int size){ for (int i = size - 1; i &gt; 0; –i) { //每次要将未排序部分的最大值移动到下标i的位置 for(int j = 0; j &lt; i; ++j) //依次比较相邻的两个元素 if( a[j] &gt; a[j+1]) { int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; } }}","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"插入排序(Insertion Sort)","slug":"插入排序insertion-sort","date":"2017-11-17T14:45:57.000Z","updated":"2020-07-05T11:10:15.169Z","comments":false,"path":"2017/11/17/插入排序insertion-sort/","link":"","permalink":"http://yoursite.com/2017/11/17/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort/","excerpt":"","text":"1.将整个数组a分为有序的部分和无序的两个部分。前者在左边，后者在右边。 2.开始有序的部分只有a[0]，其余都属于无序的部分 3.每次取出无序部分的第一个（最左边）元素，把它加入到有序部分。假设插入到合适位置p, 则原p位置及其后面的有序部分元素，都向右移动一个位子。有序的部分即增加了一个元素。 4.直到无序的部分没有元素 void InsertionSort(int a[], int size){ for (int i = 1; i &lt; size; ++i) { //a[i]是最左的无序元素，每次循环将a[i]放到合适位置 for (int j = 0; j &lt; i; ++j) if (a[j]&gt;a[i]) { //要把a[i]放到位置j，原下标j到 i-1的元素都往后移一个位子 int tmp = a[i]; for (int k = i; k &gt; j; –k) a[k] = a[k - 1]; a[j] = tmp; break; } }}","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"选择排序(Selection Sort)","slug":"选择排序selection-sort","date":"2017-11-17T14:42:28.000Z","updated":"2020-07-05T11:19:15.736Z","comments":false,"path":"2017/11/17/选择排序selection-sort/","link":"","permalink":"http://yoursite.com/2017/11/17/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselection-sort/","excerpt":"","text":"如果有N个元素需要排序，那么首先从N个元素中找到最小的那个(称为第0小的)放在第0个位子上(和原来的第0个位子上的元素交换位置)，然后再从剩下的N-1个元素中找到最小的放在第1个位子上，然后再从剩下的N-2个元素中找到最小的放在第2个位子上……直到所有的元素都就位。 void SelectionSort(int a[], int size){ for (int i = 0; i &lt; size - 1; ++i) {//每次循环后将第i小的元素放好 int tmpMin = i; //用来记录从第i个到第size-1个元素中，最小的那个元素的下标 for (int j = i + 1; j &lt; size; ++j) { if (a[j] &lt; a[tmpMin]) tmpMin = j; } //下面将第i小的元素放在第i个位子上，并将原来占着第i个位子的元素挪到后面 int tmp = a[i]; a[i] = a[tmpMin]; a[tmpMin] = tmp; }}","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"函数指针和qsort库函数","slug":"函数指针和qsort库函数","date":"2017-11-16T13:09:11.000Z","updated":"2020-07-05T08:56:51.025Z","comments":false,"path":"2017/11/16/函数指针和qsort库函数/","link":"","permalink":"http://yoursite.com/2017/11/16/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8Cqsort%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数指针定义： 函数指针是指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。函数指针有两个用途：调用函数和做函数的参数。 定义形式： 类型名 (* 指针变量名)(参数类型1, 参数类型2,…); 例如： int (*pf)(int ,char); 表示pf是一个函数指针，它所指向的函数，返回值类型应是int，该函数应有两个参数，第一个是int 类型，第二个是char类型 使用实例(求两个数最小数)： #include &lt;stdio.h&gt;void PrintMin(int a,int b) { if( a&lt;b ) printf(“%d”,a); else printf(“%d”,b);}int main() { void (* pf)(int ,int); int x = 4, y = 5; pf = PrintMin; pf(x,y); return 0;} qsort库函数 C语言快速排序库函数： void qsort(void *base, int nelem, unsigned int width, int ( * pfCompare)( const void *, const void *)); 可以对任意类型的数组进行排序 base: 待排序数组的起始地址 nelem: 待排序数组的元素个数 width: 待排序数组的每个元素的大小（以字节为单位） pfCompare: 函数指针，它指向一个“比较函数”。 该比较函数应为以下形式： int 函数名(const void * elem1, const void * elem2); 比较函数是程序员自己编写的 排序就是一个不断比较并交换位置的过程。 qsort函数在执行期间，会通过pfCompare指针调用 “比较函数”，调用时将要比较的两个元素的地址传给“比较函数”,然后根据“比较函数”返回值判断两个元素哪个更应该排在前面。 int 比较函数名(const void * elem1, const void * elem2); 比较函数编写规则： 1.如果 * elem1应该排在 * elem2前面，则函数返回值是负整数 2. 如果 * elem1和* elem2哪个排在前面都行，那么函数返回0 3. 如果 * elem1应该排在 * elem2后面，则函数返回值是正整数 实例： 下面的程序，功能是调用qsort库函数，将一个unsigned int数组按照个位数从小到大进行排序。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM 5int MyCompare( const void * elem1, const void * elem2 ){ unsigned int * p1, * p2; p1 = (unsigned int *) elem1; // “* elem1” 非法 p2 = (unsigned int *) elem2; // “* elem2” 非法 return (* p1) - (* p2);}int main(){ unsigned int an[NUM] = { 8,123,11,10,4 }; qsort( an,NUM,sizeof(unsigned int), MyCompare); for( int i = 0;i &lt; NUM; i ++ ) printf(“%d “,an[i]); return 0;} 输出结果：4 8 10 11 123","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"内存操作库函数memset和memcpy","slug":"内存操作库函数memset和memcpy","date":"2017-11-16T12:51:49.000Z","updated":"2020-07-05T08:56:51.023Z","comments":false,"path":"2017/11/16/内存操作库函数memset和memcpy/","link":"","permalink":"http://yoursite.com/2017/11/16/%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%BA%93%E5%87%BD%E6%95%B0memset%E5%92%8Cmemcpy/","excerpt":"","text":"内存操作库函数memset 头文件cstring中声明: void * memset(void * dest,int ch,int n); 将从dest开始的n个字节，都设置成ch。返回值是dest。ch只有最低的字节起作用 将szName的前10个字符，都设置成’a’： char szName[200] = “”;memset( szName,’a’,10);cout &lt;&lt; szName &lt;&lt; endl; 输出：aaaaaaaaaa 将数组内容全部设置成0: int a[100];memset(a,0,sizeof(a)); 结果数组a的所有元素都变成0 内存操作库函数memcpy 头文件cstring中声明: void * memcpy(void * dest, void * src, int n); 将地址src开始的n个字节，拷贝到地址dest。返回值是dest。 将数组a1的内容拷贝到数组a2中去，结果是a2[0] = a1[0], a2[1] = a1[1]……a2[9] = a1[9] ： int a1[10];int a2[10];memcpy( a2, a1, 10*sizeof(int)); 编写内存操作库函数memcpy void * MyMemcpy( void * dest , const void * src, int n){ char * pDest = (char * )dest; char * pSrc = ( char * ) src; for( int i = 0; i &lt; n; ++i ) { //逐个字节拷贝源块的内容到目的块 * (pDest + i) = * ( pSrc + i ); } return dest;}","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"矩阵相乘","slug":"矩阵相乘","date":"2017-11-15T15:31:43.000Z","updated":"2020-07-05T11:19:15.726Z","comments":false,"path":"2017/11/15/矩阵相乘/","link":"","permalink":"http://yoursite.com/2017/11/15/%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/","excerpt":"","text":"编程求两个矩阵相乘的结果。输入第一行是整数m,n， 表示第一个矩阵是m行n列的。接下来时一个m×n的矩阵。 再下一行的输入是整数p,q，表示下一个矩阵是p行q列（n=p） 再接下来就是一个p行q列的矩阵。 要求输出两个矩阵相乘的结果矩阵(1 &lt; m,n,p,q &lt;= 8)。 [ 输入样例(2行3列，3行3列 ： 2 3 2 4 5 2 1 3 3 3 1 1 1 2 3 2 0 1 4 输出样例： 10 19 30 4 8 16 代码如下： #include using namespace std;#define ROWS 8#define COLS 8int a[ROWS][COLS];int b[ROWS][COLS];int c[ROWS][COLS]; //结果int main() { int m,n,p,q; cin &gt;&gt; m &gt;&gt; n; for(int i = 0;i&lt;m; ++i) //读入a矩阵 for(int j = 0; j &lt; n; ++j) cin &gt;&gt; a[i][j]; cin &gt;&gt; p &gt;&gt; q; for(int i = 0;i&lt;p; ++i) //读入b矩阵 for(int j = 0; j &lt; q; ++j) cin &gt;&gt; b\\[i\\]\\[j\\]; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; q; ++j) { c\\[i\\]\\[j\\] = 0; for (int k = 0; k &lt; n; ++k) c\\[i\\]\\[j\\] += a\\[i\\]\\[k\\] \\* b\\[k\\]\\[j\\]; } } for (int i = 0; i&lt;m; ++i) { for (int j = 0; j &lt; q; ++j) { cout &lt;&lt; c\\[i\\]\\[j\\] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0;}","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"如何有一个好的生活习惯","slug":"如何有一个好的生活习惯","date":"2017-11-10T08:21:02.000Z","updated":"2020-07-05T15:03:27.916Z","comments":false,"path":"2017/11/10/如何有一个好的生活习惯/","link":"","permalink":"http://yoursite.com/2017/11/10/%E5%A6%82%E4%BD%95%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E7%94%9F%E6%B4%BB%E4%B9%A0%E6%83%AF/","excerpt":"","text":"现在是下午四点 我突然意识到今天还没吃饭 中午有点小事情没顾得上吃 然后就一直在实验室 如果不是刚才肚子告诉我 我可能还不知道 早上基本从来不吃 因为起不来 我理想中的生活习惯是 晚上11点准时睡 早上七点20准时起 一日三餐要吃好吃饱 每周去打两三次篮球、 最好每天晚上能跑跑步 看上去很简单的几条 如果不是真的热爱 自制真的很难 我决定一点点做到上面这几条 突然看到桌子上这货盯着我 不知道能不能吃 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17111001-300x169.jpg)","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"筛选法求n以内素数","slug":"筛选法求n以内素数","date":"2017-11-07T13:54:23.000Z","updated":"2020-07-05T11:19:15.741Z","comments":false,"path":"2017/11/07/筛选法求n以内素数/","link":"","permalink":"http://yoursite.com/2017/11/07/%E7%AD%9B%E9%80%89%E6%B3%95%E6%B1%82n%E4%BB%A5%E5%86%85%E7%B4%A0%E6%95%B0/","excerpt":"","text":"判断一个数n是不是素数，可以用2到 根号n之间的所有整数去除n，看能否整除。如果都不能整除，那么n是素数(慢）。 筛选法求素数：把2到n中所有的数都列出来，然后从2开始，先划掉n内所有2的倍数，然后每次从下一个剩下的数(必然是素数)开始，划掉其n内的所有倍数。最后剩下的数，就都是素数。 空间换时间，加快了计算速度。 代码如下： #include //筛法求素数#include using namespace std; int MAX_NUM = 100;char isPrime[101]; //最终如果isPrime[i]为1，则表示i是素数,之所以加1是因为我们有100个数字，而数组从0开始 int main(){ for (int i = 2; i &lt;= MAX_NUM; ++i) //开始假设所有数都是素数 isPrime[i] = 1; for (int i = 2; i &lt;= MAX\\_NUM; ++i) //每次将一个素数的所有倍数标记为非素数 { if (isPrime\\[i\\]) //只标记素数的倍数 for (int j = 2 \\* i; j &lt;= MAX\\_NUM; j += i) isPrime\\[j\\] = 0; //将素数 i 的倍数标记为非素数 } for( int i = 2;i &lt;= MAX\\_NUM; ++i) if( isPrime\\[i\\]) cout &lt;&lt; i &lt;&lt; endl; system(&quot;pause&quot;); return 0;}","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"用freopen重新定向输入","slug":"用freopen重新定向输入","date":"2017-11-07T13:26:06.000Z","updated":"2020-07-05T08:56:51.002Z","comments":false,"path":"2017/11/07/用freopen重新定向输入/","link":"","permalink":"http://yoursite.com/2017/11/07/%E7%94%A8freopen%E9%87%8D%E6%96%B0%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5/","excerpt":"","text":"调试程序时，每次运行程序都要输入测试数据，太麻烦。 可以将测试数据存入文件，然后用freopen将输入由键盘 重定向为文件，则运行程序时不再需要输入数据了。 声明：FILE *freopen( const char *path, const char *mode, FILE *stream ); 参数说明： path: 文件名，用于存储输入输出的自定义文件名。 mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。 stream: 一个文件，通常使用标准流文件。 标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。 代码如下： 输入一串数字，求最大值 #include using namespace std;int main(){ //此后所有输入都来自文件 D:\\test.txt freopen(“D:\\\\test.txt”, “r”, stdin); int n, mx = 0; while (cin &gt;&gt; n) { if (n &gt; mx) mx = n; } printf(&quot;%d&quot;, mx);} 文件D:\\\\test.txt的内容：23 45 777 888 99 674 1288 输出结果：1288","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"OJ输入数据的处理","slug":"oj输入数据的处理","date":"2017-11-07T12:48:33.000Z","updated":"2020-07-05T08:56:51.000Z","comments":false,"path":"2017/11/07/oj输入数据的处理/","link":"","permalink":"http://yoursite.com/2017/11/07/oj%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"scanf表达式的值 scanf(…)表达式的值为int，表示成功读入的变量个数 int n,m;printf(“%d”,scanf(“%d%d”,&amp;n,&amp;m)); 输入：34 56 输出：2 输入：34 a 输出：1 输入：a 56 输出：0 scanf(…) 值为EOF(即-1)则说明输入数据已经结束 int n,m;while(scanf(“%d%d”,&amp;n,&amp;m) != EOF){ //EOF是直接能拿来用的符号常量 printf(“%d”,n+m);} 也可以： int n,m;while(scanf(“%d%d”,&amp;n,&amp;m) == 2){ printf(“%d”,n+m);} Windows系统下,不停输入两个整数再敲回车， 则不停输出它们的和，直到输入 Ctrl+Z 然后 回车,程序结束 cin表达式的值 cin &gt;&gt; m &gt;&gt; n … 表达式的值，在成功读入 所有变量时为true，否则为false int n,m;while(cin &gt;&gt; n &gt;&gt; m ){ printf(“%d”,n+m);} 循环会一直持续下去，直到输入 Ctrl+Z 然后 回车,程序结束 处理无结束标记的OJ题目输入 输入若干个(不知道多少个)正整数，输出其中的最大值 Sample Input: 2 3 4 5 6 787 54532 12 Sample Output： 54532 代码如下： #include #include using namespace std;int main(){ int n, mx = 0; //或 while(scanf(“%d”,&amp;n) == 1){ while(scanf(“%d”,&amp;n) != EOF) { if( n &gt; mx ) mx = n; } printf(“%d”,mx); return 0;} 或者： #include #include using namespace std;int main(){ int n, mx = 0; while( cin &gt;&gt; n) { if( n &gt; mx ) mx = n; } printf(“%d”,mx); return 0;}","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"Ulua基础之框架入门","slug":"ulua基础之框架入门","date":"2017-11-01T09:25:51.000Z","updated":"2020-07-05T11:24:00.961Z","comments":false,"path":"2017/11/01/ulua基础之框架入门/","link":"","permalink":"http://yoursite.com/2017/11/01/ulua%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/","excerpt":"","text":"ULua 基础介绍 1.SimpleFramework 框架介绍 ①ULua 集成开发环境叫做：SimpleFramework，最新版是0.4.1。 ②SimpleFramework 分为两个版本： NGUI 版和UGUI 版，区别是NGUI 版本的框架资源中含有NGUI 这个插件。 ③SimpleFramework 本身不是Unitypackage 格式，而是一个Unity3D的项目工程，也就是说，我们可以用Unity 直接打开这个项目工程。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17110101-300x47.png) 2.SimpleFramework 和ULua的关系： SimpleFramework &gt; ULua &gt; Lua ULua 是对原生Lua 环境进行了一次“包装”，用于满足Unity 环境下的热更新需求。为了更方便的使用，于是又对ULua 进行“二次包装”，包装成了一个框架：SimpleFramework。 框架资源结构 1.六个根文件夹 ①Examples：SimpleFramework 热更新案例； ②Lua：SimpleFramework 框架自带的Lua 源码文件； ③NGUI：NGUI3.8.2，当你需用更高版本的NGUI 时，替换即可，不需要碰； ④Plugins：uLua 运行所依赖的底层库文件，不需要碰； ⑤Scripts：SimpleFramework 自带的C#脚本文件； ⑥uLua：uLua 全部代码。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/11/17110102-300x207.png)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17110102.png)**2.框架自带菜单命令** Lua 菜单：uLua 环境相关处理命令； Game 菜单：用于打包不同平台的AssetBundle 文件。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17110104-300x215.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/11/17110104.jpg) **3.框架使用步骤** **Lua-->Gen Lua Wrap File [生成Wrap 文件(必备操作)]** 该命令用于生成“Lua 包装文件”，存放在uLua\\Source\\LuaWrap 目录下。该文件夹下全部是C#脚本，这些脚本文件的名称特点是：脚本名+ Wrap； **Wrap 文件介绍：** 该文件夹下的脚本对Unity 内常用组件脚本的二次包装，Lua 环境运行后，会把这些Wrap 文件加载到Lua 运行环境(Lua 虚拟机)中，最终的效果就是：Lua 调用Wrap 文件，Wrap 文件调用C#，来实现Lua 调用C#。生成Wrap 文件的目的是为了提高Lua 的执行效率。 **Game-->Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]** Game-->Build Windows Resource 生成Windows 平台下的AB 文件。生成后的AB 会存放到StreamingAssets 文件夹下。在生成的过程中同时还会把Lua 文件夹下的所有脚本拷贝到该目录，存放到lua 文件夹下。 **4.Lua 文件夹结构分析** SimpleFramework 框架自带的Lua 源码文件。 ①3rd：第三方的Lua 脚本插件； ②Common：公共Lua 文件目录； ③Controller：控制器目录； ④Logic：管理器目录； ⑤System：cstolua 的系统目录； ⑥View：视图层目录。 备注： 这些文件夹中的Lua 脚本如果直接使用SciTE 打开，脚本中的中文注释是乱 码状态，可以使用NotePad++打开，中文就不会出现乱码。 我们自己写的Lua 脚本也是存放在Lua 文件夹中。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/11/17110103-300x200.png)","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"图像几何变换之Bee和Whale互换眼睛","slug":"图像几何变换之bee和whale互换眼睛","date":"2017-10-30T12:43:30.000Z","updated":"2020-07-05T08:56:50.984Z","comments":false,"path":"2017/10/30/图像几何变换之bee和whale互换眼睛/","link":"","permalink":"http://yoursite.com/2017/10/30/%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E4%B9%8Bbee%E5%92%8Cwhale%E4%BA%92%E6%8D%A2%E7%9C%BC%E7%9D%9B/","excerpt":"","text":"首先看两张图，Bee的眼睛较大，Whale的眼睛较小，我们要做的就是把他们两个眼睛互换，而且还要保证它的新眼睛大小一致。简单来说就是，比如博主我是大眼睛，那我就一直是大眼睛。 1.Bee： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17103004-300x243.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17103004.png) 2.Whale: [![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17103005-300x154.png) Matlab代码： clc,clear,close allBee=rgb2gray(imread(‘bee.png’));Whale=rgb2gray(imread(‘Whale.png’));subplot(421),imshow(Bee),title(‘Bee’); %Bee原图subplot(422),imshow(Whale),title(‘Whale’); %Whale原图 BeeEyes=Bee(146:200,317:380); %Bee眼睛的位置subplot(423),imshow(BeeEyes),title(‘Bee的眼睛’);WhaleEyes=Whale(147:170,110:135); %Whale眼睛的位置subplot(424),imshow(WhaleEyes),title(‘Whale的眼睛’); %将Bee和Whale眼睛的位置变成白色Bee(146:200,317:380)=255;Whale(147:170,110:135)=255;subplot(425),imshow(Bee),title(‘失去眼睛的Bee’);subplot(426),imshow(Whale),title(‘失去眼睛的Whale’); BeeEyes=imresize(BeeEyes,0.5); %变成原图的0，5倍WhaleEyes=imresize(WhaleEyes,3); %变成原图的3倍 Bee_h=(200-146)/2+146;Bee_w=(380-317)/2+317; %Bee_h,Bee_w为Bee眼睛中心点Bee_w=round(Bee_w); %round四舍五入[h1,w1]=size(WhaleEyes); %size取WhaleEyes图像大小bh=Bee_h-round(h1/2);bw=Bee_w-round(w1/2);Bee(bh:bh+h1-1,bw:bw+w1-1)=WhaleEyes;subplot(427),imshow(Bee),title(‘Bee的新眼睛’); Whale_h=(170-147)/2+147;Whale_h=round(Whale_h);Whale_w=(135-110)/2+110;Whale_w=round(Whale_w);[h2,w2]=size(BeeEyes);wh=Whale_h-round(h2/2);ww=Whale_w-round(w2/2);Whale(wh:wh+h2-1,ww:ww+w2-1)=BeeEyes;subplot(428),imshow(Whale),title(‘Whale的新眼睛’); 代码处理后的效果如下，从第四行可以看到它们已经成功换了眼睛。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17103007-300x152.jpg)","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Wiener滤波之复原运动模糊图像","slug":"wiener滤波之复原运动模糊图像","date":"2017-10-23T12:56:49.000Z","updated":"2020-07-05T08:56:50.982Z","comments":false,"path":"2017/10/23/wiener滤波之复原运动模糊图像/","link":"","permalink":"http://yoursite.com/2017/10/23/wiener%E6%BB%A4%E6%B3%A2%E4%B9%8B%E5%A4%8D%E5%8E%9F%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A%E5%9B%BE%E5%83%8F/","excerpt":"","text":"在生活中，我们可能会遇到因为摄像机大幅度抖动而造成的照片模糊，比如下面着两张图，人眼根本无法辨别原本的内容，还好我们有Matlab。 1.模糊的车牌照：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102302-300x134.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102302.png) 2.能看清图2中的文字吗[![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102303.png) 代码如下： clc,clear,close all %截取图中的某部分区域a=imread(‘yang.png’);b=a(160:230,190:280);figure;subplot(321),imshow(a);title(‘原图’);subplot(322),imshow(b);title(‘处理后的图’); %Wiener滤波处理运动模糊的车牌照c=imread(‘chePai.png’);subplot(323),imshow(c);%摄像物体逆时针方向以30度运动了20个像素d=fspecial(‘motion’,20,30);e=deconvwnr(c,d,0.02); %一般用0.02subplot(324),imshow(e); %Wiener滤波处理运动模糊的文字f=imread(‘text.png’);subplot(325),imshow(f);%摄像物体逆时针方向以30度运动了50个像素g=fspecial(‘motion’,50,30);h=deconvwnr(f,g,0.016);subplot(326),imshow(h); 结果如下，可以看到上面的两张图片经过处理后，清晰度改善了很多。[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102304-300x196.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102304.jpg) 项目Github地址：[https://github.com/WJGwjg/mixCode/tree/master/matlabWiener%E6%BB%A4%E6%B3%A2","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"灰度图之垂直投影和水平投影","slug":"灰度图之垂直投影和水平投影","date":"2017-10-23T12:30:53.000Z","updated":"2020-07-05T08:56:50.979Z","comments":false,"path":"2017/10/23/灰度图之垂直投影和水平投影/","link":"","permalink":"http://yoursite.com/2017/10/23/%E7%81%B0%E5%BA%A6%E5%9B%BE%E4%B9%8B%E5%9E%82%E7%9B%B4%E6%8A%95%E5%BD%B1%E5%92%8C%E6%B0%B4%E5%B9%B3%E6%8A%95%E5%BD%B1/","excerpt":"","text":"Matlab代码： clc,clear,close all I=imread(‘pic.png’);g=rgb2gray(I); %灰度化处理 figuresubplot(221),imshow(I);title(‘原图’);subplot(222),imshow(g);title(‘灰度图’); [m, n]=size(I); %水平投影for x=1:m S(x)=sum(I(x,:));endx=1:m;subplot(223),plot(x,S(x));title(‘水平投影’); %垂直投影for y=1:n S(y)=sum(I(1:m,y));endy=1:n;subplot(224),plot(y,S(y));title(‘垂直投影’); 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102301-300x155.jpg)","categories":[],"tags":[{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"AssetBundle之服务端资源下载到本地","slug":"assetbundle之服务端资源下载到本地","date":"2017-10-22T08:37:51.000Z","updated":"2020-07-05T11:20:23.711Z","comments":false,"path":"2017/10/22/assetbundle之服务端资源下载到本地/","link":"","permalink":"http://yoursite.com/2017/10/22/assetbundle%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0/","excerpt":"","text":"在实际项目中，我们不可能每次启动程序都从服务端获取AssetBundle文件。一般都是将获取到的AssetBundle文件存放在本地，方便以后调用。 这两篇博客，都是属于AssetBundle比较核心一部分东西，用到的API也比较多，但是我基本都加了注释，要想熟练掌握还需要多练习的。之所以写下来，大致是为了当作自己的学习笔记，方便日后回头看，可以说是是查漏补缺吧。 这篇主要是写了如何用WWW下载资源，以及用IO系统来存放我们下载的资源。 代码如下： using System;using System.IO;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Networking;//引入UnityEngine.Networking用来执行网络操作 public class load : MonoBehaviour{ //根目录的文件夹产生的AssetBundless文件地址 private string rootAssetBundle = @”http://www.wjgbaby.com/unityModel/AssetBundless/AssetBundless&quot;; //根目录地址 private string assetBundleRoot = @”http://www.wjgbaby.com/unityModel/AssetBundless/&quot;; void Start () { //开启协程 StartCoroutine(&quot;DownloadAssetBundless&quot;); } /// &lt;summary&gt; /// 下载根目录AssetBundle文件 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator DownloadAssetBundless() { //创建一个获取AssetBundle 文件的web 请求. UnityWebRequest request = UnityWebRequest.GetAssetBundle(rootAssetBundle); //发送web请求 yield return request.SendWebRequest(); //从web获取内容，返回一个AssetBundle类型的数据 AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request); //获取AssetBundless.manifest的manifest文件 AssetBundleManifest manifest = ab.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); //获取AssetBundless.manifest文件中的所有AssetBundle的名称信息 string\\[\\] assets= manifest.GetAllAssetBundles(); for (int i = 0; i &lt;assets.Length;i++) { Debug.Log(assetBundleRoot+assets\\[i\\]); //开启协程 //StartCoroutine(DownLoadSingleAssetBundel(assetBundleRoot + assets\\[i\\])); StartCoroutine(DownloadAssetBundleAndSave(assetBundleRoot + assets\\[i\\])); } } /\\* /// &lt;summary&gt; /// 下载模型单个的AssetBundle文件 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator DownLoadSingleAssetBundel(string str) { UnityWebRequest request = UnityWebRequest.GetAssetBundle(str); yield return request.SendWebRequest(); AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request); //通过获取AssetBundle对象获取内部所有资源的名称，返回在一个数组 string\\[\\] names= ab.GetAllAssetNames(); //遍历数组，服务端下载所有文件 for (int i= 0;i&lt; names.Length;i++) { //截取路径地址中的文件名，且无后缀名. 需要引入System.IO 命名空间. string shortName = Path.GetFileNameWithoutExtension(names\\[i\\]); GameObject go = ab.LoadAsset&lt;GameObject&gt;(shortName); GameObject.Instantiate&lt;GameObject&gt;(go, Vector3.zero, Quaternion.identity); } } \\*/ /// &lt;summary&gt; /// 下载AssetBundle文件并保存在本地 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator DownloadAssetBundleAndSave(string url) { //通过WWW 类创建一个web 请求，参数填写AssetBundle 的url 下载地址. WWW www = new WWW(url); //将对象作为数据返回，这个www 对象就是请求(下载）来的数据 yield return www; //www.isDone,一个属性，表示下载状态是否完毕 if (www.isDone) { ////使用IO技术将www对象存储到本地. SaveAssetBundle(Path.GetFileName(url), www.bytes, www.bytes.Length); } } /// &lt;summary&gt; /// 保存AssetBundle文件到本地 /// &lt;/summary&gt; private void SaveAssetBundle(string fileName,byte\\[\\] bytes,int count) { FileInfo fileInfo = new FileInfo(Application.dataPath+&quot;//&quot;+fileName); FileStream fs = fileInfo.Create(); //fs.Write(字节数组, 开始位置, 数据长度); fs.Write(bytes, 0, count); fs.Flush(); //文件写入存储到硬盘 fs.Close(); //关闭文件流对象 fs.Dispose(); //销毁文件对象 } } 结果如下,可以看到player.ab和plane.ab已经从我的web服务器被下载到了Assets目录下。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102201-300x145.png)","categories":[],"tags":[{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://yoursite.com/tags/AssetBundle/"}]},{"title":"AssetBundle之服务端资源加载","slug":"assetbundle之服务端资源下载","date":"2017-10-21T14:17:33.000Z","updated":"2020-07-05T11:21:11.964Z","comments":false,"path":"2017/10/21/assetbundle之服务端资源下载/","link":"","permalink":"http://yoursite.com/2017/10/21/assetbundle%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"我把AssetBundless整个文件的资源都放在了我的web服务器上，里面除了有AssetBundless自身的4个文件之外，还有player和plane各4个文件。[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102103-300x118.png) 将本地打包好的AssetBundle 文件上传至web 服务器，然后本地从web 服务器端下载所有的AssetBundle 文件。从服务器端下载AssetBundle 文件，我们需要这些文件的web 路径地址，每一个地址对应一个AssetBundle 文件。 我们不可能在代码中写几十上百个文件的web 地址，所以说我们需先下载“目录”的AssetBundle 文件，在这里也就是AssetBundless.manfiest，然后通过它里面的AssetBundle 名称再来间接的获取其他的AssetBundle 文件的下载路径地址。 代码如下： using System;using System.IO;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Networking;//引入UnityEngine.Networking用来执行网络操作 public class load : MonoBehaviour{ //根目录的文件夹产生的AssetBundless文件地址 private string rootAssetBundle = @”http://www.wjgbaby.com/unityModel/AssetBundless/AssetBundless&quot;; //根目录地址 private string assetBundleRoot = @”http://www.wjgbaby.com/unityModel/AssetBundless/&quot;; void Start () { //开启协程 StartCoroutine(&quot;DownloadAssetBundless&quot;); } /// &lt;summary&gt; /// 下载根目录AssetBundle文件 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator DownloadAssetBundless() { //创建一个获取AssetBundle 文件的web 请求. UnityWebRequest request = UnityWebRequest.GetAssetBundle(rootAssetBundle); //发送web请求 yield return request.SendWebRequest(); //从web获取内容，返回一个AssetBundle类型的数据 AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request); //获取AssetBundless.manifest的manifest文件 AssetBundleManifest manifest = ab.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); //获取AssetBundless.manifest文件中的所有AssetBundle的名称信息 string\\[\\] assets= manifest.GetAllAssetBundles(); for (int i = 0; i &lt;assets.Length;i++) { Debug.Log(assetBundleRoot+assets\\[i\\]); //开启协程 StartCoroutine(DownLoadSingleAssetBundel(assetBundleRoot + assets\\[i\\])); } } /// &lt;summary&gt; /// 下载模型单个的AssetBundle文件 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator DownLoadSingleAssetBundel(string str) { UnityWebRequest request = UnityWebRequest.GetAssetBundle(str); yield return request.SendWebRequest(); AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request); //通过获取AssetBundle对象获取内部所有资源的名称，返回在一个数组 string\\[\\] names= ab.GetAllAssetNames(); //遍历数组，服务端下载所有文件 for (int i= 0;i&lt; names.Length;i++) { //截取路径地址中的文件名，且无后缀名. 需要引入System.IO 命名空间. string shortName = Path.GetFileNameWithoutExtension(names\\[i\\]); GameObject go = ab.LoadAsset&lt;GameObject&gt;(shortName); GameObject.Instantiate&lt;GameObject&gt;(go, Vector3.zero, Quaternion.identity); } }} 结果如下，两个物体都是从web服务器加载过来的。[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17102101-300x173.jpg)","categories":[],"tags":[{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://yoursite.com/tags/AssetBundle/"}]},{"title":"AssetBundle之本地资源加载","slug":"assetbundle之本地资源加载","date":"2017-10-21T06:55:13.000Z","updated":"2020-07-05T11:20:23.714Z","comments":false,"path":"2017/10/21/assetbundle之本地资源加载/","link":"","permalink":"http://yoursite.com/2017/10/21/assetbundle%E4%B9%8B%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"AssetBundle资源既可以留在本地，也可以存在服务器上不占用安装包体积，这篇文章是写本地加载的。 一:加载AB 资源到内存 AssetBundle ab = AssetBundle.LoadFromFile(“AB 包完整路径”) 从一个完整的路径位置加载AB 资源包到内存，返回一个AssetBundle 对象. 二：从AB 资源中获取资源 T resName = ab.LoadAsset(“游戏资源名称”) 通过获取到的AssetBundle 对象的“加载资源”方法，从AssetBundle 对象内获取对应的游戏物体资源，并且返回该资源. 代码如下： using System.Collections;using System.Collections.Generic;using UnityEngine; public class load : MonoBehaviour{ void Start () { string str = Application.dataPath + “/AssetBundless/player.ab”; //AssetBundle ab = AssetBundle.LoadFromFile(&quot;AB 包完整路径&quot;) AssetBundle ab = AssetBundle.LoadFromFile(str); //T resName = ab.LoadAsset&lt;T&gt;(&quot;游戏资源名称&quot;) //注意名字用的是player原来的Prefab的名字 GameObject ga = ab.LoadAsset&lt;GameObject&gt;(&quot;Necromancer&quot;); GameObject.Instantiate(ga, Vector3.zero, Quaternion.identity); }} 注意点： 1.路径不要写错 2.文件名要写上后缀 3.LoadAsset里面的名字要写Prefab的名字 4.在unity中运行时是正常的，但是打包到windows平台就会加载不出来模型。 这涉及到加载路径，主要是StreamingAssets的问题，这个我准备以后写。 到时候我会把Unity中Resources，Editor，StreamingAssets，Plugins这几个特殊的文件夹一块写出来。","categories":[],"tags":[{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://yoursite.com/tags/AssetBundle/"}]},{"title":"大吉大利，今晚吃鸡","slug":"大吉大利，今晚吃鸡","date":"2017-10-19T15:51:25.000Z","updated":"2020-07-05T15:03:27.904Z","comments":false,"path":"2017/10/19/大吉大利，今晚吃鸡/","link":"","permalink":"http://yoursite.com/2017/10/19/%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%EF%BC%8C%E4%BB%8A%E6%99%9A%E5%90%83%E9%B8%A1/","excerpt":"","text":"最近有个叫绝地求生的游戏挺火的 得了第一名 系统就会出现“大吉大利，今晚吃鸡” 今天下午跟三个室友去网吧第一次玩 我打的还是比较稳的 打了一下午，就杀了一个人 还TM是跳完伞刚降落碰到的一个人 用拳头硬刚的… 主要是我那几个室友也不会玩 四个新手 这种考验操作的游戏 不多花时间肯定打不好 等以后有空了再玩吧 我叫武大锤 万万没想到 最后我还是成功吃鸡了 黄昏的时候 四位少年走在东方多伦多的街道上 嘈杂的空气中 突然飘来一阵香味 定睛一瞅 一家炒鸡店 嗯 炒鸡超级好吃 下午也打得很爽 这就够了。","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"AssetBundle资源打包之细节分析","slug":"assetbundle资源打包之细节分析","date":"2017-10-19T15:30:27.000Z","updated":"2020-07-05T11:20:23.714Z","comments":false,"path":"2017/10/19/assetbundle资源打包之细节分析/","link":"","permalink":"http://yoursite.com/2017/10/19/assetbundle%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85%E4%B9%8B%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/","excerpt":"","text":"一.资源打包选项 在AssetBundle 打包过程中，有一个BuildAssetBundleOptions 枚举类型，通过设置不同的枚举参数，可以实现不同的压缩方式。 1.BuildAssetBundleOptions.None 使用LZMA 压缩算法进行压缩，打包后的资源体积最小。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101902-300x158.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101902.png) **2.BuildAssetBundleOptions.UncompressedAssetBundle** 不使用压缩方式，打包后的AssetBundle 体积最大，但是加载速度最快。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101901-300x181.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101901.png) **3.BuildAssetBundleOptions.ChunkBasedCompression** 使用LZ4 压缩算法进行压缩，打包后的AssetBundle 体积和加载速度介于二 者之间。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101903-300x144.png) 代码如下： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor; public class test{ //LZMA压缩 [MenuItem(“Build/AssetBundle(LZMA压缩)”)] static void Build01() { string path = Application.dataPath + “/AssetBundless”; BuildPipeline.BuildAssetBundles(path, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64); Debug.Log(&quot;LZMA压缩打包成功&quot;); } //无压缩 \\[MenuItem(&quot;Build/AssetBundle(无压缩)&quot;)\\] static void Build02() { string path = Application.dataPath + &quot;/AssetBundless&quot;; BuildPipeline.BuildAssetBundles(path, BuildAssetBundleOptions.UncompressedAssetBundle, BuildTarget.StandaloneWindows64); Debug.Log(&quot;无压缩打包成功&quot;); } //LZ4压缩 \\[MenuItem(&quot;Build/AssetBundle(LZ4压缩)&quot;)\\] static void Build() { string path = Application.dataPath + &quot;/AssetBundless&quot;; BuildPipeline.BuildAssetBundles(path, BuildAssetBundleOptions.ChunkBasedCompression, BuildTarget.StandaloneWindows64); Debug.Log(&quot;LZ4压缩打包成功&quot;); }} 二.manifest 文件 AssetBundle 打包完毕后的资源包，由两部分组成。 一：资源打包出来的AssetBundle 文件； 二：AssetBundle 文件配套的manifest 文本文件。 1.meta文件： .meta 文件不属于AssetBundle 打包后的产物。 在Unity3D 环境内，每个资源都会自动生成一个同名同后缀的.meta 文件。这个文件用于存储该资源的一些基本信息。 比如：“创建时间，版本ID，AssetBundle 名称，后缀等信息”。 找到player的prefab文件，打开它的meta文件，如图所示，可以看到meta记录了player被打包的名字和后缀。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101906-300x213.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101906.png) **2.manifest 文件介绍** manifest 文件和.meta 文件作用类似。 manifest 文件是用于专门存储打包后的AssetBundle 文件的基本信息的。 主要包含以下信息： CRC 校验码：类似于MD5，用于计算出该资源的一个特殊信息标示； ClassTypes 列表：当前资源关联使用到了Unity 中的哪些类，这些类是以编号索引的形式存在的，每个编号都对应一个类文件。 player.ab.manifest: [![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101904-217x300.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101904.png) **3.目录manifest 文件** 在我们打包出来的AssetBundle 文件中，有一个特殊的manifest 文件。 这个manifest 文件是和用于存储AssetBundle 的文件夹同名的文件，且只在根文件夹下有唯一的一个。 这个manifest 文件可以称之为“AssetBundle 目录文件”，因为这个文件中内存储了打包出来的所有的AssetBundle 的文件的索引信息。 通过这个目录文件，可以找到所有的AssetBundle 文件,可以看到图中有player和plane的Name. [![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101905-282x300.png)","categories":[],"tags":[{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://yoursite.com/tags/AssetBundle/"}]},{"title":"AssetBundle资源打包之基本操作","slug":"assetbundle资源打包之基本操作","date":"2017-10-18T11:40:35.000Z","updated":"2020-07-05T11:20:23.711Z","comments":false,"path":"2017/10/18/assetbundle资源打包之基本操作/","link":"","permalink":"http://yoursite.com/2017/10/18/assetbundle%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"AssetBundle 的作用类似于电脑上的WinRAR，360 好压之类的压缩软件，可以将一个或者多个资源进行打包管理，顺带还可以对资源的体积进行压缩。 在Unity 内，除去C#脚本文件以外，选中任何文件后，在Inspector 面板的下方都会出现一个Asset Lables 功能区域，通过这个功能可以给资源设置AssetBundle 的文件名和文件后缀。 文件名：资源打包成AssetBundle 后的文件名，类似于压缩包的名字； 后缀：企业开发中常用的后缀有unity3d，assetbundle，ab，其他自定义； 备注：文件名和后缀名都是小写格式。 在Asset Labels 区域填写AssetBundle 名称的时候，名称是可以分目录嵌套的，比如：文件夹名/文件名。 核心API ： BuildPipeline.BuildAssetBundles(路径, 选项, 平台); ①BuildAssetBundles：打包所有设置了AssetLabels 的资源； ②路径：打包出来的AssetBundle 文件存放的位置； ③选项：设置AssetBundle 打包过程中的选项，None 表示忽略该选项； ④平台：AssetBundle 是平台之间不兼容的，IOS，Android 是两套资源 1.如图所示，给我们的两个模型分别设置AssetBundle名字为player和plane，设置后缀为ab。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101801-300x241.png)](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101801.png) 2.在Assets面板新建一个叫Editor的文件夹以及一个AssetBundless文件夹[![](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101802-283x300.png) 3.在Editor里面新建一个脚本，起名为test，取消继承MonoBehaviour，引入命名空间UnityEditor 代码如下： using System.Collections;using System.Collections.Generic;using UnityEngine;//引入命名空间“UnityEditor”using UnityEditor; public class test{ //“特性”扩展编辑器 [MenuItem(“Window/buildAsset”)] //静态无返回值 static void Build() { //存放路径 string path = Application.dataPath + &quot;/AssetBundless&quot;; //BuildPipeline.BuildAssetBundles(路径, 选项, 平台) //打包选项无,windows64平台 BuildPipeline.BuildAssetBundles(path, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64); Debug.Log(&quot;打包成功&quot;); }} 4.点击Window下的buildAsset按钮，Unity会自动打包所有AssetBundle文件到AssetBundless文件夹内，打包后的文件如图所示,可以看到两个模型都已经被压缩了。[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101803-300x100.png)","categories":[],"tags":[{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://yoursite.com/tags/AssetBundle/"}]},{"title":"Lua 与C#交互之Lua 调用C#","slug":"lua-与c交互之lua-调用c","date":"2017-10-14T13:22:26.000Z","updated":"2020-07-05T11:24:00.909Z","comments":false,"path":"2017/10/14/lua-与c交互之lua-调用c/","link":"","permalink":"http://yoursite.com/2017/10/14/lua-%E4%B8%8Ec%E4%BA%A4%E4%BA%92%E4%B9%8Blua-%E8%B0%83%E7%94%A8c/","excerpt":"","text":"在独立的Lua 脚本文件内，我们需要访问项目内已经存在的C#脚本，这些C#脚本都是我们之前已经写好的。 也就是说，我们热更新下来的Lua 代码，要能访问已经存在的C#代码。 Lua不仅可以访问我们C#项目中的代码，还可以访问C#官方的类库。 操作步骤： 1.导入luanet.dll，语法格式：require “luanet” 2.获取程序集，语法格式：luanet.load_assembly（“程序集名”） 3.获取类型，语法格式：变量名= luanet.import_type（“程序集名.类名”） C#代码： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using LuaInterface; namespace lua_Interaction_C{ class Program { static void Main(string[] args) { Lua lua = new Lua(); lua.DoFile(&quot;wjgCode.lua&quot;); Console.ReadKey(); } static double num = 888.666; //加减乘除 static int JiaFa(int a,int b) {return a + b;} static int JianFa(int a, int b) {return a -b;} static int ChengFa(int a, int b) {return a \\* b;} static int ChuFa(int a, int b) {return a / b;} }} Lua代码： --导入luanet.dll，语法格式：require “luanet”require(“luanet”) –获取程序集，语法格式：luanet.load_assembly（“程序集名”)luanet.load_assembly(“lua_Interaction_C”) –获取类型，语法格式：变量名= luanet.import_type（“程序集名.类名”）vsCode=luanet.import_type(“lua_Interaction_C.Program”) –调用C#中的代码print(vsCode.num) print(vsCode.JiaFa(3,6))print(vsCode.JianFa(18,6))print(vsCode.ChengFa(6,6))print(vsCode.ChuFa(88,22)) –热更新核心逻辑：项目打包完成后，直接修改Lua文件的代码就能修改C#的代码 –获取C#中System程序集luanet.load_assembly(“System”) –获取C#中System程序集的Console类Console=luanet.import_type(“System.Console”) Console.WriteLine(“齐天大圣孙悟空”) 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101401-300x159.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua 与C#交互之C#调用Lua","slug":"lua-与c交互之c调用lua","date":"2017-10-13T15:45:00.000Z","updated":"2020-07-05T11:24:00.921Z","comments":false,"path":"2017/10/13/lua-与c交互之c调用lua/","link":"","permalink":"http://yoursite.com/2017/10/13/lua-%E4%B8%8Ec%E4%BA%A4%E4%BA%92%E4%B9%8Bc%E8%B0%83%E7%94%A8lua/","excerpt":"","text":"一.Lua与C#的代码空间分配 我们用VS写在C#项目里面调用Lua代码，实际上最后都是在Lua代码空间来运行，这个空间由系统分配。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101301-300x140.jpg) 二.C#内执行Lua代码 语法格式：Lua 解析器对象.DoString(“Lua 代码”) 注意点：①DoString（）方法主要用于执行一些较短的Lua 代码片段； ②DoString（）方法执行过的代码，都会添加到Lua 代码空间，在Lua 代码文件中，是直接可以访问到这些代码的。 代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using LuaInterface; namespace C_Interaction_Lua{ class Program { static void Main(string[] args) { //实例化出一个Lua空间 Lua lua = new Lua(); //1.变量的声明与访问 lua.DoString(&quot;name=&apos;wuJianGang&apos; age=&apos;18&apos; school=&apos;zzu&apos;&quot;); lua.DoString(&quot;print(name,age,school)&quot;); //2.for循环语句 //for语句普通格式： lua.DoString(&quot;for i=1,5,1 do print(i) end&quot;); Console.WriteLine(&quot;-----------------------&quot;); //for语句加@符号后的格式，代码更易读和美观 lua.DoString(@&quot;for i=6,10,1 do print(i) end&quot;); //3.函数的定义域调用 lua.DoString(@&quot;function Init() print(&apos;I am luaFunction&apos;) end Init()&quot;); //4.table数组的声明与访问 lua.DoString(&quot;tableA={&apos;wwwww&apos;,&apos;jjjjj&apos;,&apos;ggggg&apos;}&quot;); lua.DoString(@&quot;for i=1,table.getn(tableA),1 do print(tableA\\[i\\]) end&quot;); Console.ReadKey(); } }} 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101302-300x164.jpg) 三.C#内执行Lua 文件 语法格式：Lua 解析器对象.DoFile(“[路径]Lua 文件.lua”) 操作步骤： ①添加-&gt;新建项-&gt;常规-&gt;文本文件，改名且后缀写为.lua，设置属性为始终较新则复制 但是这样创建出来的文件，文件格式是UTF-8 BOM 类型，运行后会抛异常。 ②使用Notepad++之类的文本编辑器，建议将类型修改成ANSI 类型，也可以是UTF-8 类型 两种类型区别： UTF-8 类型，即可运行正常，但是这种文档类型不支持中文显示； ANSI 类型，中英文都都支持。 注意点 在Lua 脚本文件内访问DoString 函数添加到“Lua 代码空间”的代码： GetString（）：取Lua 脚本中的字符串数据； GetNumber（）：取Lua 脚本内的数值数据； GetFunction（）：取Lua 脚本内的函数，并执行。 Lua代码： print(‘66666’)print(‘你好，我叫武建港’) –Lua代码空间有我们之前定义的字段，方法，table表print(name,age,school)Init()print(tableA[2]) webName=’武建港博客’webURL=’www.wjgbaby.com&#39; myNumber=666.66 function Test() print(‘这里调用的是Lua脚本里的Test()’)end function Add(num01,num02) return num01+num02end C#代码： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using LuaInterface; namespace C_Interaction_Lua{ class Program { static void Main(string[] args) { //实例化出一个Lua空间 Lua lua = new Lua(); //1.变量的声明与访问 lua.DoString(&quot;name=&apos;wuJianGang&apos; age=&apos;18&apos; school=&apos;zzu&apos;&quot;); lua.DoString(&quot;print(name,age,school)&quot;); //2.for循环语句 //for语句普通格式： lua.DoString(&quot;for i=1,5,1 do print(i) end&quot;); Console.WriteLine(&quot;---------------------------------------&quot;); //for语句加@符号后的格式，代码更易读和美观 lua.DoString(@&quot;for i=6,10,1 do print(i) end&quot;); //3.函数的定义域调用 lua.DoString(@&quot;function Init() print(&apos;I am luaFunction&apos;) end Init()&quot;); //4.table数组的声明与访问 lua.DoString(&quot;tableA={&apos;wwwww&apos;,&apos;jjjjj&apos;,&apos;ggggg&apos;}&quot;); lua.DoString(@&quot;for i=1,table.getn(tableA),1 do print(tableA\\[i\\]) end&quot;); Console.WriteLine(&quot;---------------------------------------&quot;); lua.DoFile(&quot;wjg.lua&quot;); Console.WriteLine(&quot;---------------------------------------&quot;); //GetString（）：取Lua 脚本中的字符串数据 string webName = lua.GetString(&quot;webName&quot;); string webURL= lua.GetString(&quot;webURL&quot;); Console.WriteLine(webName+&quot;:&quot;+webURL); //GetNumber（）：取Lua 脚本内的数值数据 double myNumber =lua.GetNumber(&quot;myNumber&quot;); Console.WriteLine(myNumber); //GetFunction（）：取Lua 脚本内的函数，并执行 LuaFunction luaFunctionTest= lua.GetFunction(&quot;Test&quot;); //调用方法(变量) luaFunctionTest.Call(); LuaFunction luaFunctionAdd= lua.GetFunction(&quot;Add&quot;); //存入object object\\[\\] obj= luaFunctionAdd.Call(8, 6); Console.WriteLine(&quot;lua里Add()方法两个数相加的的结果：&quot;+obj\\[0\\]); Console.ReadKey(); } }} 结果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17101303-300x233.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Unity检测物体在屏幕内外","slug":"unity检测物体在屏幕内外","date":"2017-10-10T09:54:39.000Z","updated":"2020-07-05T08:56:50.963Z","comments":false,"path":"2017/10/10/unity检测物体在屏幕内外/","link":"","permalink":"http://yoursite.com/2017/10/10/unity%E6%A3%80%E6%B5%8B%E7%89%A9%E4%BD%93%E5%9C%A8%E5%B1%8F%E5%B9%95%E5%86%85%E5%A4%96/","excerpt":"","text":"好记性不如烂笔头。虽然是很细的东西，但是为了防止以后忘记，还是记一下比较好。 直接将代码挂到gameobject上，然后去检测Console面板。 代码如下: using System.Collections;using System.Collections.Generic;using UnityEngine; public class StayOrLeave : MonoBehaviour{ //物体在屏幕内 void OnBecameVisible() { Debug.Log(gameObject.name +”出现(OnBecameVisible)”); } //物体在屏幕外 void OnBecameInvisible() { Debug.Log(gameObject.name+&quot;丢失(OnBecameInvisible)&quot;); } // 当可见时开启行为 //function OnBecameVisible() //{ // enabled = true; //}} 官方解释: 当renderer(渲染器)在任何相机上可见时调用OnBecameVisible。 这个消息发送到所有附在渲染器的脚本上。 OnBecameVisible 和 OnBecameInvisible可以用于只需要在物体可见时才进行的计算。 OnBecameVisible可以被用作协同程序，在函数中调用yield语句。当在编辑器中运行时，场景面板相机也会导致这个函数被调用。 Unity圣典链接：http://www.ceeger.com/Script/MonoBehaviour/MonoBehaviour.OnBecameVisible.html","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"Lua与C#交互之环境配置","slug":"lua与c交互之环境配置","date":"2017-10-04T08:11:31.000Z","updated":"2020-07-05T11:26:07.744Z","comments":false,"path":"2017/10/04/lua与c交互之环境配置/","link":"","permalink":"http://yoursite.com/2017/10/04/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Lua与C#交互要用到LuaInterface，起到桥梁的作用。 LuaInterface 是一个开源的项目工程，内部有两个核心的DLL 文件： ①LuaInterface.dll：在C#代码中操作Lua 代码需要依赖该文件； ②luanet.dll：在Lua 代码中访问C#的类库脚本需要依赖该文件。 环境配置要点： 一：将两个dll文件拷贝到项目当中去，并且设置属性为“如果较新则复制”； 二：在项目中添加LuaInterface.dll的引用； 三：在项目中写入命名空间 using LuaInterface 如图所示： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17100401-300x291.png) 代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using LuaInterface;//引入命名空间 namespace tempTest{ class Program { static void Main(string[] args) { //创建一个Lua解析器对象 //在C#代码中执行Lua代码，靠的就是这个对象 Lua lua = new Lua(); lua\\[&quot;name&quot;\\] = &quot;wjg&quot;; lua\\[&quot;age&quot;\\] = 18; Console.WriteLine(lua \\[&quot;name&quot;\\]); Console.WriteLine(lua\\[&quot;age&quot;\\]); Console.ReadKey(); } }} 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/10/17100402-300x179.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"C#字符串的内存分配和驻留池机制","slug":"c字符串的内存分配和驻留池","date":"2017-09-30T06:34:39.000Z","updated":"2020-07-05T08:56:50.959Z","comments":false,"path":"2017/09/30/c字符串的内存分配和驻留池/","link":"","permalink":"http://yoursite.com/2017/09/30/c%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E9%A9%BB%E7%95%99%E6%B1%A0/","excerpt":"","text":"1.当有多个字符串变量包含了同样的字符串实际值时，CLR可能不会为它们重复地分配内存，而是让它们统统指向同一个字符串对象实例。 str01与str02的值相同，在对str02初始化的时候。并没有重新开辟内存，而是直接将地址指向str01的“wjg”。 string str01 = “wjg”;string str02 = “wjg”; //因为String类重载了==操作符来比较String对象包含的实际值//所以不能用same=str01==str02bool same = (object)str01 == (object)str02;Console.WriteLine(same);//结果为TrueConsole.ReadKey(); 字符串有不变性，一旦实例化完成就永远不会变了，我们每次对一个String对象进行操作时（比如说使用Trim，Replace等方法），并不是真的对这个String对象的实例进行修改，而是返回一个新的String对象实例作为操作执行的结果。 这样的话，CLR把我们的str01和str02共用一个地址就是合理的了，因为不管他们两个谁改变了，都不会影响到对方。这样可以优化内存。 为了维护这个机制，就出现了我们要说的驻留池，驻留池记录了所有在代码中使用字面量声明的字符串实例的引用。 这说明使用字面量声明的字符串会进入驻留池，而其他方式声明的字符串并不会进入，也就不会自动享受到CLR防止字符串冗余的机制的好处了，看第2条： 2.虽然str01和str02因为值相同所以指向同一个内存地址，但是并非2个值相同的字符串就对应同一个内存地址 string str03 = “jiangang”;StringBuilder sb = new StringBuilder();sb.Append(“jian”);sb.Append(“gang”);string str04 = sb.ToString(); bool SAME= (object)str03 == (object)str04;Console.WriteLine(SAME);//结果为FalseConsole.ReadKey(); 因为虽然str03，str04表示的是相同的字符串，但是由于str04不是通过字面量声明的，CLR在为sb.ToString()方法的返回值分配内存时，并不会到驻留池中去检查是否有值为jiangang的字符串已经存在了，所以自然不会让str04指向驻留池内的对象. 3.string.Intern方法：检索系统对指定 String 的引用。 在CLR中，维护名为暂存池中，包含对每个声明，或在程序中以编程方式创建的唯一字符串的单个引用的表，从而节约字符串存储区。 因此，具有特定值的文本字符串的实例仅一次系统中存在。 例如，如果将相同的文本字符串分配给几个变量，则运行时检索对文字字符串的相同引用从暂存池中，并将其分配给每个变量。 Intern方法使用暂存池中搜索的值相等的字符串_str_。 如果存在这样的字符串，则返回它在暂存池中的引用。 如果字符串不存在，对引用_str_添加到暂存池中，则返回该引用。 在下面的示例中，具有值为”MyTest”，字符串 s5 已经留用，因为它是在程序中的文本。 System.Text.StringBuilder类生成一个新的字符串对象，具有 s5相同的值。 该字符串的引用分配给 s6。 Intern具有相同的值为 s6的字符串方法搜索。 由于存在这样的字符串，该方法将返回分配给 s5 中的同一个引用。 然后，该引用被分配给 s7。 由于它们引用不同的对象; 因此，引用 s5 和 s6 比较不相等，引用 s5 和 s7比较结果相等，这是因为它们引用的相同的字符串。 string s5 = “MyTest”;string s6 = new StringBuilder().Append(“My”).Append(“Test”).ToString();string s7 = String.Intern(s6); Console.WriteLine((Object)s6 == (Object)s5); //结果为FalseConsole.WriteLine((Object)s7 == (Object)s5); //结果为TrueConsole.ReadKey(); 完整代码： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace StringTemp{ class Program { static void Main(string[] args) { string str01 = “wjg”; string str02 = “wjg”; //因为String类重载了==操作符来比较String对象包含的实际值 //所以不能用same=str01==str02 bool same = (object)str01 == (object)str02; Console.WriteLine(same);//结果为True //Console.ReadKey(); string str03 = &quot;jiangang&quot;; StringBuilder sb = new StringBuilder(); sb.Append(&quot;jian&quot;); sb.Append(&quot;gang&quot;); string str04 = sb.ToString(); bool SAME= (object)str03 == (object)str04; Console.WriteLine(SAME);//结果为False //Console.ReadKey(); string s5 = &quot;MyTest&quot;; string s6 = new StringBuilder().Append(&quot;My&quot;).Append(&quot;Test&quot;).ToString(); string s7 = String.Intern(s6); Console.WriteLine((Object)s6 == (Object)s5); //结果为False Console.WriteLine((Object)s7 == (Object)s5); //结果为True Console.ReadKey(); } }} 结果如下： 官方文档：https://msdn.microsoft.com/en-us/library/system.string.intern(v=vs.110).aspx","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"多事之周——GYB培训","slug":"多事之周-gyb培训","date":"2017-09-24T13:31:37.000Z","updated":"2020-07-05T15:03:27.921Z","comments":false,"path":"2017/09/24/多事之周-gyb培训/","link":"","permalink":"http://yoursite.com/2017/09/24/%E5%A4%9A%E4%BA%8B%E4%B9%8B%E5%91%A8-gyb%E5%9F%B9%E8%AE%AD/","excerpt":"","text":"这一周应该是我大学以来最累的一周了 一点都不像我自由主义的风格 主要是忙在了实验室招新，3天的GYB创业培训等等。 实验室招新，有人来就要有人走 因为基地要求我们团队最多14人 结果就是最后20人左右的队伍只留了7个人 然后又招了7个学弟学妹 这些新人我和中一都是一一面试，精挑细选的 花费了我们不少时间和精力。 GYB培训收获巨大，有些简单的道理你可能真的不懂。 周五到周日是三天的GYB创业培训 参加培训的大概35人左右 大部分是项目负责人或技术骨干，也有几个公司的老板。 老师是区政府派来的 她来了之后发现我们已经并不适合GYB的课程了 因此第一天主要是让每个项目负责人讲解自己的项目， 然后我们大家帮忙分析项目的优势劣势。 GYB第二天上午，老师把GYB的东西快速讲了下。 GYB第二天下午，我们玩了一个游戏,名字是企业基本周期运作模拟。 我在网上找了篇链接，游戏规则如下：https://wenku.baidu.com/view/811705ddc850ad02df804148.html 所有人分成3组，大概10人在一组，分成红绿蓝三个队 我是绿队的老板，我们队名字叫做“青青草原”公司 由于对规则的不熟悉，以及人员的分工不合理和产品质量的问题和我的领导问题 最后，青青草原公司成功破产了…… 一共也就卖出去了3顶帽子 这一次真的让我感觉到了自己的阅历太浅太浅 典型的眼高手低 里面的合同签订方式，人员调配，产品质量保证，如何与竞争对手相处，企业风险评估，财务预算，财务计划…… 都让我学到了很多。 GYB第三天，我们玩了一个新游戏，名字是供给和需求。 游戏规则我也在网上找了一份，规则：https://wenku.baidu.com/view/b1743c8e26fff705cc170ab0.html 这一次我退到了二线，青青草原公司换了一个新老板，简称史总 这次我们算是“赢了“ 红队，红红火火公司第四周就宣布破产 蓝队，蓝精灵公司最后亏损180 我们绿队，青青草原公司亏损100，不过没有任何债务，都还清了。 这次我们发挥的我觉得还不错，首先是对游戏规则的把握上 我事先用电脑查了，让队员们都看了看 其次就是新老板的领导也非常好，每个人各司其职，分工明确 还有就是产品质量非常好，没有坏一顶帽子。 但是最后三家公司其实都是失败的，因为都没挣钱 最后大家一起分析了问题所在，问题还是很多的 我们3家公司出发点就是错的，都想搞死对方，这是主要原因 没能处理好制造商，零售商，市场，银行之间的关系。 其实大家是可以一起挣钱的，最后无非就是谁挣的多一点，谁少一点。 在商业上呀，还是不要老想这如何搞死别人，因为这个人死了还会有下一个他 还有就是要在法律许可范围内，稍不注意，你可能就是在搞垄断 对市场要有一个清晰的认识，搞清楚的你的竞争对手到底是谁 要以一个求同存异，合作共赢的心态去做事情 做账要细之又细，多做风险评估 对你的员工有时候要适当放权 合同至少要一式两份 把握好你的产品质量（第一次游戏死得很惨，一部分原因是因为产品质量没搞好，然后就越来越被动） 搞清楚游戏规则，现实生活中要对政府的政策了如指掌，这样才能利益最大化 最后放一张合照吧，希望下次还能一起参加SYB培训课，能看到我吗，最帅的那个小哥哥就是我，哈哈哈哈哈哈哈哈哈 2017.9.24.21.40 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/09/17092401-300x225.jpg)","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"C#中==和Equal的区别","slug":"c中和equal的区别","date":"2017-09-18T12:44:53.000Z","updated":"2020-07-05T08:56:50.956Z","comments":false,"path":"2017/09/18/c中和equal的区别/","link":"","permalink":"http://yoursite.com/2017/09/18/c%E4%B8%AD%E5%92%8Cequal%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"昨天晚上在群里看到了这道题，我上去就答错了。 正确答案是：true true false true [ ](http://www.wjgbaby.com/wp-content/uploads/2017/09/17091801-300x127.png) 今天经过仔细研究，发现知识点还不少。 涉及到值类型，引用类型，堆栈空间，装箱，以及C#的字符串内存驻留机制，这个机制我会写在下一篇文章里。 ==与Equal区别： 1.==比较的是栈空间的值，Equal比较的是堆空间的值 C#有值类型和引用类型： 值类型在栈空间存放，==比较的是值在栈空间的数据是否相等，因为值类型在堆空间没有数据，所以Equal的作用此时和==相同，都比较的是栈空间的数据。 引用类型的数据的地址在栈空间，值则在堆中存放。==比较的是两个栈中的地址是否相等，Equal比较的就是堆中的对象的值是否相等。 2.string类型 C#中的string类型是引用类型，赋值操作则是按值类型操作。 string str01=“wjg”string str02=“wjg” str01与str02的值相同，在对str02初始化的时候。并没有重新开辟内存，而是直接将地址指向str01的“wjg”。 因此str01，str02的==比较和Equal比较的意义是一样的，都比较值类型即可 注意点：虽然str01和str02因为值相同所以指向同一个内存地址，但是并非2个相同值相等的字符串就对应同一个内存地址。这一点我会在下一篇文章C#的字符串内存驻留机制里面写。 代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace ConsoleApplication1{ class People { private string name; public string Name { get { return name; } set { name = value; } } public People(string name) { this.name = name; } } class Program { static void Main(string\\[\\] args) { string a = new string(new char\\[\\] { &apos;w&apos;, &apos;j&apos;, &apos;g&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;y&apos;, &apos;.&apos;, &apos;c&apos;, &apos;o&apos;, &apos;m&apos; }); string b = new string(new char\\[\\] { &apos;w&apos;, &apos;j&apos;, &apos;g&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;y&apos;, &apos;.&apos;, &apos;c&apos;, &apos;o&apos;, &apos;m&apos; }); Console.WriteLine(a == b); //结果为true Console.WriteLine(a.Equals(b));//结果为true object g = a; object h = b; Console.WriteLine(g == h);//结果为false Console.WriteLine(g.Equals(h));//结果为true People p1 = new People(&quot;wjg&quot;); People p2 = new People(&quot;wjg&quot;); Console.WriteLine(p1 == p2);//结果为false Console.WriteLine(p1.Equals(p2));//结果为false People p3 = new People(&quot;wjg&quot;); People p4 = p3; Console.WriteLine(p3 == p4);//结果为true Console.WriteLine(p3.Equals(p4));//结果为true Console.ReadLine(); } }} 结果如下： C#字符串的内存分配和驻留池机制： http://www.wjgbaby.com/2017/09/30/c%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%92%8c%e9%a9%bb%e7%95%99%e6%b1%a0/","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Lua面对对象之继承关系","slug":"lua面对对象之继承关系","date":"2017-09-17T17:26:33.000Z","updated":"2020-07-05T11:24:00.943Z","comments":false,"path":"2017/09/18/lua面对对象之继承关系/","link":"","permalink":"http://yoursite.com/2017/09/18/lua%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/","excerpt":"","text":"子类继承父类，在子类中就可以访问到父类中的公开的字段和方法。 下面的代码是Father类作为父类，Boy为子类继承自Father。 Boy既可以看作实例化的对象，同时也可以看作子类并添加构造方法。 代码如下： --声明父类Father={name} function Father:Init(name) local temp={} setmetatable(temp,self) self.__index=self self.name=name return tempend function Father:talk() print(Father.name..”,”..”我是你父类”)end –声明子类，继承自父类–括号内可以写nil，也可以不写Boy=Father:Init(nil) function Boy:Init(name) –继承的核心代码： local temp=Father:Init(name) setmetatable(temp,self) self.__index=self Boy.name=name return tempend function Boy:shoot() print(Boy.name..”,”..”我是你子类”)end –实例化一个子类对象boy=Boy:Init(“武哥哥”)–调用子类的方法boy.shoot()–调用父类的方法boy.talk() 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “4.lua”武哥哥,我是你子类武哥哥,我是你父类 Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua面对对象之类与对象","slug":"lua面对对象之类与对象","date":"2017-09-13T03:33:37.000Z","updated":"2020-07-05T11:24:00.938Z","comments":false,"path":"2017/09/13/lua面对对象之类与对象/","link":"","permalink":"http://yoursite.com/2017/09/13/lua%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Lua本身是没有类和对象的概念的，但是呢大多数程序员都习惯了类和对象的这种套路，不好改正。 程序员心里想的应该是：既然Lua你没有类和对象，那我就自己造一个。 接下来我们就用table表来模拟出Lua的类和对象，以及构造方法。 代码如下： --初始化一个类Person={name=”asd”,age,sex,address} –模拟类的构造方法，类与对象核心语句:function Person:new() temp={} –将类[表]设置为temp的元表 setmetatable(temp,Person) Person.__index=Person return tempend –模拟类中的一个普通方法function Person:start() –self关键字，类似C#的this print(self.name,self.age,self.sex,self.address)end –实例化对象man=Person:new()man.name=”武建港”man.age=18man.sex=”男”man.address=”中国” woman=Person:new()woman.name=”董小姐”woman.age=18woman.sex=”女”woman.address=”美国” –调用类中的方法man:start()woman:start() –比较两个对象是否用的同一个空间print(man==woman) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “4.lua”武建港 18 男 中国董小姐 18 女 美国false Exit code: 0 注意点： ①访问对象中的字段：格式是“对象名.字段名” ②访问对象中的方法：格式是“对象名:方法名”（注意是冒号）","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"验证table是引用型数据","slug":"验证table是引用型数据","date":"2017-09-12T15:07:40.000Z","updated":"2020-07-05T11:24:00.958Z","comments":false,"path":"2017/09/12/验证table是引用型数据/","link":"","permalink":"http://yoursite.com/2017/09/12/%E9%AA%8C%E8%AF%81table%E6%98%AF%E5%BC%95%E7%94%A8%E5%9E%8B%E6%95%B0%E6%8D%AE/","excerpt":"","text":"代码如下： str01=”wjgbaby.com”str02=”wjgbaby.com” table01={“111”,”222”,”333”}table02={“111”,”222”,”333”} print(str01==str02)print(table01==table02) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “4.lua”truefalse Exit code: 0 因为str01和str02里面数据是值类型，因为值相同，所以返回为true table01和table02虽然表里的成员相同，但是存储地址不同，即为引用类型，所以返回false 总结： 值类型的数据判断相同的条件是：值（内容）相同； 引用型的数据判断相同的条件是：地址相同.","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"一吻便杀一个人","slug":"一吻便杀一个人","date":"2017-09-12T10:26:29.000Z","updated":"2020-07-05T15:03:32.164Z","comments":false,"path":"2017/09/12/一吻便杀一个人/","link":"","permalink":"http://yoursite.com/2017/09/12/%E4%B8%80%E5%90%BB%E4%BE%BF%E6%9D%80%E4%B8%80%E4%B8%AA%E4%BA%BA/","excerpt":"","text":"“一吻便颠倒众生，一吻便杀一个人” 这是杨千嬅在《处处吻》里面的一句歌词 我觉得用在这里挺合适。 最近关于WePhone的开发者之死新闻很多 我的一位室友，一位android大佬这样看待这件事： 男性程序员把大部分时间用在了技术上 身边很少有女性，而且也不怎么会跟女性交流 所以单身较多 结果突然来了个漂亮的，一直缠着你 就很难抵挡住诱惑。 我们都在这个行业里 大致了解这个行业的艰辛 我是赞同大佬的的观点的 同时我也认为这个开发者太过于胆小懦弱。 今天看了一篇腾讯推送的文章 觉得有些部分不错 以下摘自腾讯新闻： **人们看到了一种代表性的笨拙，当面临一个又一个情感问题，婚姻问题考验的时候，苏的解决方式无非两种，一个是给钱，一个是哀求。这说明他对婚姻缺少认知，婚姻并不是交易，最终是建立在感情基础之上。** 婚姻也并不容易。新一代白手起家、改天换地的科技新富，他们自信是不断学习，不断能力迭代的一代，但他们的成长、阅历和传统社会齐根切断，告别了传统阅世“家学”的浸染，也没有现代成熟模型的参照，实际可能退化到连普通生活问题都难以处理。即网友说的“智商超群，情商为零。” 可以说，他们有把握技术和创富能力，却陷入了把握人生全面幸福能力的危机。这是有风险的，这样的人生也不应该被认为是成功的。 如果人生可以重来，怎样改变他们身上这种代表性的笨拙？人生情感课程的通关最终自于实操。社会不应再完全负面看待早恋，也应当提倡年轻人试婚同居。 腾讯新闻链接：http://view.news.qq.com/original/intouchtoday/n4012.html","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"Lua的Metatable元表","slug":"lua的metatable元表","date":"2017-09-12T08:33:18.000Z","updated":"2020-07-05T11:24:00.909Z","comments":false,"path":"2017/09/12/lua的metatable元表/","link":"","permalink":"http://yoursite.com/2017/09/12/lua%E7%9A%84metatable%E5%85%83%E8%A1%A8/","excerpt":"","text":"在Lua中使用一个表操作另外的一个表的时候就需要用到metatable 1.关联两个表[将表B 设置成表A 的元表]，需要用一个新的函数： setmetatable(表A, 表B) 2.getmetatable(表名) 如果表名有元表，就返回元表的类型和地址；如果没有元表，则返回一个nil。 3.__index索引(注意前面是两个_) 设置元表的“__index 索引”，让这个索引指向元表自身，代码如下： 元表名.__index = 元表名 然后我们再使用“表名.键名”的方式访问表内的成员。 比如下面代码中的两个表tableA和tableB，如果表tableA 中没有，就会自动访问表tableB 中的成员。 代码如下： tableA={str01=”达康书记”,str02=”育良书记”,str03=”小金子”}tableB={str04=”猴子”,str05=”吴法官”,str06=”齐同伟”} tableB.__index=tableB –setmetatable(表A, 表B)–将tableB设置为tableA的元表setmetatable(tableA,tableB) –getmetatable(表名)–如果表名有元表，就返回元表的类型和地址–如果没有元表，则返回一个nilprint(getmetatable(tableA))print(getmetatable(tableB)) print(tableA.str01)print(tableA.str02)print(tableA.str03)print(tableA.str04)print(tableA.str05)print(tableA.str06) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “temp.lua”table: 00BE98A8nil达康书记育良书记小金子猴子吴法官齐同伟 Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua的模块化实现","slug":"lua的模块化实现","date":"2017-09-11T11:45:04.000Z","updated":"2020-07-05T11:24:00.921Z","comments":false,"path":"2017/09/11/lua的模块化实现/","link":"","permalink":"http://yoursite.com/2017/09/11/lua%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"1.新建一个名为temp的lua文件，代码如下： --初始化模块，命名与文件名相同temp={}–定义变量：模块名.变量名temp.name=”WuJianGang” –定义方法：模块名.方法名function temp.jiafa(a,b) print(a..”+”..b..”=”..(a+b))end function temp.jianfa(a,b) print(a..”-“..b..”=”..(a-b))end –返回模块名return temp 2.新建一个名为test的lua文件，代码如下： --require(“temp”)–require引入模块，上下两种引入形式都对require “temp” print(temp.name) temp.jiafa(3,4)temp.jianfa(8,6) 运行test.lua文件的结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/09/17091101-300x181.jpg)","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua笔记之table表","slug":"lua笔记之table表","date":"2017-09-10T10:32:04.000Z","updated":"2020-07-05T11:24:00.938Z","comments":false,"path":"2017/09/10/lua笔记之table表/","link":"","permalink":"http://yoursite.com/2017/09/10/lua%E7%AC%94%E8%AE%B0%E4%B9%8Btable%E8%A1%A8/","excerpt":"","text":"Lua 语言中的数组其实就是table 类型。 table 是Lua 语言中的一种“代码格式结构”，而Lua 当中的数组就是使用table 这种结构实现的。 下面的这些文字知识点是别人总结的，我感觉这个总结的非常好，没有一句废话，完全就是标准呀。所以这次就没有自己写文字总结，但是代码不敢偷懒，是自己写的。 一.给table 赋值 有两种操作： 1.数组方式，就是以角标方式进行赋值，1,2,3,4,5….. 2.键值对方式，类似于C#当中的Dictionary&lt;k, v&gt;泛型字典. 二.迭代器方式遍历table for key, value in ipairs(表名) do print(key, value) end 备注：如果是数组结构，用ipairs 方法；如果是键值对结构，用pairs 方法. 三.table相关方法 &lt;1&gt;增加元素 table.insert(表名, [位置], 值) 往指定的位置增加元素，如果不写位置，默认往最后一个位置增加。 这个方式适合“数组模式”，不太适合“键值对模式”。 键值对就用：表名[‘键’] = 值的方式添加即可。 &lt;2&gt;移除元素 table.remove(表名, [位置]) 如果不写位置，默认移除最后一个元素，如果位置值超出范围，不会报错，也不 会有元素被移除。 这个方式适合“数组模式”，不能用于“键值对模式”。 键值对就用：表名[‘键’] = nil 的方式移除即可。 &lt;3&gt;table 长度 table.getn(表名) 返回table 表的长度。 这个方式适合“数组模式”，不能用于“键值对模式”。 键值对就用：迭代器迭代，然后累加一个变量的方式获得长度。 上面东西比较多，大致看下就行，关键还是要看代码，代码如下： --数组的数组类型是table类型array={1,2,3,4,5,6}print(“Lua数组的类型是:”..type(array)) print(“———–以数组角标方式对table01赋值———-“)table01={}table01[1]=”郑州大学北校区”table01[2]=”郑州大学新校区” –数组模式增加元素table.insert(table01,3,”郑州大学东校区”)table.insert(table01,4,”郑州大学南校区”)–数组模式移除元素table.remove(table01,3)–数组长度print(“table01的长度是”..table.getn(table01)) print(“———–迭代器方式遍历table01—————“)for key,value in ipairs(table01) do print(key,value)end print(“———————————————–”)print(“———————————————–”) print(“———–以键值对方式对table02赋值———–”)table02={}table02[“马云”]=”阿里巴巴”table02[“任正非”]=”华为” –键值对方式增加元素table02[“李彦宏”]=”百度”–键值对方式移除元素table02[“马云”]=nil–键值对方式不能用table.getn获取长度–我们定义一个index，利用迭代器的迭代获取长度index=0 print(“———–迭代器方式遍历table02—————“)–注意ipairs和pairs的区别for key,value in pairs(table02) do print(key,value) index=index+1endprint(“table02的长度是”..index) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”Lua数组的类型是:table———–以数组角标方式对table01赋值———-table01的长度是3———–迭代器方式遍历table01—————1 郑州大学北校区2 郑州大学新校区3 郑州大学南校区 ———–以键值对方式对table02赋值———–———–迭代器方式遍历table02—————任正非 华为李彦宏 百度table02的长度是2 Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua作用域研究","slug":"lua作用域研究","date":"2017-09-08T15:57:11.000Z","updated":"2020-07-05T11:24:00.965Z","comments":false,"path":"2017/09/08/lua作用域研究/","link":"","permalink":"http://yoursite.com/2017/09/08/lua%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%A0%94%E7%A9%B6/","excerpt":"","text":"Lua 语言中的变量，默认全部都是全局变量，就算是声明在函数内的变量，也是 全局变量。 如果想在Lua 中声明局部变量，需要使用“local”关键字明确标示出来。 变量的默认值是nil，类似于C#中的null。 我在下面代码中加入了注释，直接看代码吧： --虽然temp001变量加了local成了局部变量–但是在meth函数内部依然可以访问–原因是因为变量仍在脚本中，类似于C#的privite–外部脚本无法调用temp001这个变量local temp001=”11111”temp002=”22222” print(temp001,temp002) –定义局部函数,但是在该脚本仍然可以调用–外部脚本无法调用此函数local function meth() print(temp002,temp001) –定义在函数内的局部变量temp003 local temp003=”333333” --Lua中所有脚本默认都是全局变量 temp004=&quot;44444&quot; print(temp003)end meth() –无法访问到temp003,就会输出nil，与null作用相同print(temp003) print(temp004) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”11111 2222222222 11111333333nil44444 Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua函数以及“委托”","slug":"lua函数以及委托","date":"2017-09-08T14:26:34.000Z","updated":"2020-07-05T11:24:00.909Z","comments":false,"path":"2017/09/08/lua函数以及委托/","link":"","permalink":"http://yoursite.com/2017/09/08/lua%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%A7%94%E6%89%98/","excerpt":"","text":"Lua是解析型语言，C#等语言是编译型语言。 C#在执行的时候会编译出一个可执行文件来执行，但是Lua是一句一句的来执行。 所以Lua 语言中在脚本编写顺序上必须先定义函数，然后在下方才可以调用。 1.Lua函数格式： [局部/全局] function 函数名（[参数列表]） –函数体 end function Hello() print(“你好”)end function Add(a,b) print(a+b)end Hello();Add(6,8) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”你好14 Exit code: 0 2.我在文章的标题部分给委托打上了双引号，主要原因就是Lua是没有委托这个概念的，因为Lua是真的可以直接把一个方法当作参数来传递。 function Hello() print(“你好”)end function Add(a,b) print(a+b)end –Hello();–Add(6,8) ————–委托————function DeleHello(method) method()end function DeleAdd(a,b,method) method(a,b)end DeleHello(Hello)DeleAdd(3,4,Add) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”你好7 Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Lua之数组语法","slug":"lua之数组语法","date":"2017-09-06T08:40:19.000Z","updated":"2020-07-05T11:24:00.904Z","comments":false,"path":"2017/09/06/lua之数组语法/","link":"","permalink":"http://yoursite.com/2017/09/06/lua%E4%B9%8B%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Lua的数组相比于C#而言有很多不同，比如一个数组可以存放任何类型的数据，以及可以后续往数组中传值，还有遍历输出的时候数组的下标是从1开始的。 至于为什么下标从1开始，我还专门去查了查，原因是，Lua是巴西天主教大学的一个研究小组开发的，巴西人和中国人一样都认为1是自然数的开始，所以就从1开始。 我把一些需要知道的东西都写进了代码的注释里了： --Lua 版本的数组可以存放多种不同类型的数据list01={“止戈为武”,11,2.44,true} –Lua 版本的数组的长度则是不固定的，声明完毕数组后，–我们依然是可以往后续的下标位置上添加值.list01[5]=”www.wjgbaby.com&quot; –获取数组长度table.getntemp=table.getn(list01)print(temp) —————-遍历数组—————––for 循环遍历数组，数组的下标是从1 开始for i=1,table.getn(list01),1do print(list01[i])end 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”5止戈为武112.44truewww.wjgbaby.com Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"finalWebBackground","slug":"finalwebbackground","date":"2017-09-06T02:43:07.000Z","updated":"2020-07-05T08:56:49.191Z","comments":false,"path":"2017/09/06/finalwebbackground/","link":"","permalink":"http://yoursite.com/2017/09/06/finalwebbackground/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"webBackground","slug":"webbackground","date":"2017-09-06T02:20:02.000Z","updated":"2020-07-05T08:56:49.188Z","comments":false,"path":"2017/09/06/webbackground/","link":"","permalink":"http://yoursite.com/2017/09/06/webbackground/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Lua分支与循环","slug":"lua分支与循环","date":"2017-09-05T09:01:53.000Z","updated":"2020-07-05T11:24:00.917Z","comments":false,"path":"2017/09/05/lua分支与循环/","link":"","permalink":"http://yoursite.com/2017/09/05/lua%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"一.分支语法 1.if语句 格式： if(布尔表达式) then 代码体 end 2.if…else…语句 格式： if(布尔表达式) then 代码体 else 代码体 end 3.if…else if…语句（注意else和if要连一块写） 格式： if(布尔表达式) then 代码体 elseif(布尔表达式) then 代码体 else 代码体 end test01=6if(test01==7)then print(11111111111)elseif(test01==8)then print(2222222222)else print(3333333333)end 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”3333333333 Exit code: 0 二.循环语句 1.for 语句 格式： for i = 0, 6, 1 do –代码体 end --0表示初值，6表示i小于等于6,1表示每次循环i加1for i=1,6,1 do print(i)end–print(——————–) 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”123456 Exit code: 0 2.while 语句 格式： while(a &gt; b) do –代码体 end a=5b=8 while(a&lt;b) do print(a) a=a+1end 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”567 Exit code: 0 3.do-while 语句 Lua没有do-while语句，但有一个语句可以替代它 格式： repeat –代码体 until(a &lt; b) a=5b=8 repeat print(a)a=a+1until(a&gt;b)–until与while的意思不相同–可以把until理解为一直到满足条件才停止 结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”5678 Exit code: 0 4.关键字 break：立刻结束当前循环； Lua中没有Continue","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"大三来了，大四还会远吗","slug":"大三了，考研吗？","date":"2017-09-03T09:33:16.000Z","updated":"2020-07-05T15:03:27.904Z","comments":false,"path":"2017/09/03/大三了，考研吗？/","link":"","permalink":"http://yoursite.com/2017/09/03/%E5%A4%A7%E4%B8%89%E4%BA%86%EF%BC%8C%E8%80%83%E7%A0%94%E5%90%97%EF%BC%9F/","excerpt":"","text":"在一个阴雨绵绵的上午 我回到了学校 并没有太多陌生感 毕竟我才离开10天左右。 五六十岁的法国梧桐依然高大魁梧 能笼罩住整个学校 图书馆前面的一个个小帐篷正在为新同学办理入学手续 那些家伙看起来很年轻，就像当年的我 他们正在为这里注入新的活力。 这就大三了 想了一个暑假也没想好是否要考研 其实也没怎么想～ 我觉得我内心是不想考的 但是考上也不亏…… 而且很多基础的东西真的很重要 那要是考不上呢。 算了，到了晚饭时间了 先吃饭，先吃饭。","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]},{"title":"Lua运算符和C#运算符的区别","slug":"lua运算符和c运算符的区别","date":"2017-09-01T10:13:47.000Z","updated":"2020-07-05T11:24:00.940Z","comments":false,"path":"2017/09/01/lua运算符和c运算符的区别/","link":"","permalink":"http://yoursite.com/2017/09/01/lua%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Cc%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一：特殊符号 1.“=”号与“＋”号 C#和Lua 语言中“=”都是赋值符 C#语言中的“＋”号有两个含义：数学意义上的相加，字符串相连； Lua 语言中的“+”号仅仅是数学意义上的相加； Lua 语言中字符串相连需要用到一个新的符号“..”。 print(“Hello World”) print(6+6) str01=”止戈为武”str02=”wjgbaby.com” –错误示范：–[[print(str01+str02)–]] print(str01..str02) 运行结果如下： lua: 1.lua:8: attempt to perform arithmetic on global ‘str01’ (a string value)stack traceback: 1.lua:8: in main chunk [C]: ? Exit code: 1lua -e “io.stdout:setvbuf ‘no’” “1.lua”Hello World12止戈为武wjgbaby.comExit code: 0 2.++与– C#语言中：有++和– Lua 语言中：没有 二：常用运算符 1.算数运算符 符号： + - * / % 对比： C#与Lua 算数运算符相同 2.复合赋值运算符 符号： += -= *= /= %= 对比： Lua 语言中无复合赋值运算符 3.关系运算符 符号： &gt; &lt; &gt;= &lt;= == != 对比： C#当中的不等于是!=，Lua 当中的不等于是~=，其它的关系运算符用法都一样 num1=66num2=88print(num1&gt;num2)print(num1&lt;num2)print(num1&gt;=num2)print(num1&lt;=num2)print(num1==num2)print(num1~=num2) 运行结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”falsetruefalsetruefalsetrue Exit code: 0 4.逻辑运算符 符号： &amp;&amp; || ! 对比： 在Lua 语言中，没有这三个符号，而是三个单词and，or，not。 print((8&gt;6)and(4&gt;3))print((6&gt;8)and(4&gt;3)) print((8&gt;6)or(4&gt;3))print((6&gt;8)or(4&gt;3)) print(not(4&gt;3))print(not(3&gt;4)) 运行结果如下： &gt;lua -e “io.stdout:setvbuf ‘no’” “1.lua”truefalsetruetruefalsetrue Exit code: 0","categories":[],"tags":[{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"C#内置委托之Action与Func","slug":"c内置委托之action与func","date":"2017-08-19T06:57:28.000Z","updated":"2020-07-05T08:56:50.923Z","comments":false,"path":"2017/08/19/c内置委托之action与func/","link":"","permalink":"http://yoursite.com/2017/08/19/c%E5%86%85%E7%BD%AE%E5%A7%94%E6%89%98%E4%B9%8Baction%E4%B8%8Efunc/","excerpt":"","text":"在C#语言的using system的命名空间下，有两个内置委托：Action与Func 1.Action委托(都没有返回值)： Action：无参，无返回值； Action：有参数T(116 个)，无返回值； 2.Func委托(都有返回值)： Func:无参，返回值为T; Func&lt;T1,T2,T&gt;:有参数T1,T2(116个)，返回值为T 代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace actionAndFunc{ class Program { static void Main(string[] args) { //定义Action委托，无参数，无返回值 Action act01; //使用Lambda表达式添加方法语句块 act01 = () =&gt; Console.WriteLine(“我是Action无参数的委托”); act01(); //定义Action委托，有1个参数，无返回值 Action&lt;int&gt; act02; act02 = (int a)=&gt;Console.WriteLine(&quot;我是Action有1个参数的委托{0}&quot;,a); act02(666); //定义Action委托，有2个参数，无返回值 Action&lt;int, string&gt; act03; act03 = (int a, string str) =&gt; { Console.WriteLine(&quot;我是Action有2个参数的委托,第一个参数是{0}，第二个是{1}&quot;,a,str); }; act03(666,&quot;sixsixsix&quot;); Console.WriteLine(&quot;-----------------------------------------------------------------&quot;); Console.WriteLine(&quot;-----------------------------------------------------------------&quot;); //定义Func委托，没有参数，返回值是int Func&lt;int&gt; func01; func01 = () =&gt; { Console.Write(&quot;一个无参数的Func委托，返回值是：&quot;); return 666; }; var temp = func01(); Console.WriteLine(temp); //定义Func委托，有两个string参数，返回值是int,注意返回值是在&lt;&gt;的最后一个 Func&lt;string, string, int&gt; func02; func02 = (string str01, string str02) =&gt; { Console.Write(&quot;{0}一个无参数的Func委托{1}，返回值是：&quot;,str01,str02); return 666; }; var Temp = func02(&quot;我是&quot;,&quot;类型&quot;); Console.WriteLine(Temp); Console.ReadKey(); } }} 运行结果：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081901-300x176.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C#之Lambda表达式","slug":"c之lambda表达式","date":"2017-08-17T12:20:24.000Z","updated":"2020-07-05T08:56:50.921Z","comments":false,"path":"2017/08/17/c之lambda表达式/","link":"","permalink":"http://yoursite.com/2017/08/17/c%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Lambda表达式其实就是匿名方法的进一步简写,也就是匿名方法的升级版。 本篇文章我会在我写的匿名方法的基础上来做更改，匿名方法文章链接：http://www.wjgbaby.com/2017/08/17/c%e4%b9%8b%e5%8c%bf%e5%90%8d%e6%96%b9%e6%b3%95/ Lambda表达式语法： 委托类型 变量 = （[参数列表]）=&gt; { 方法体; }; 注意点： 1.=&gt; 是Lambda 表达式特有符号，读作goes to 2.如果没有参数列表，（）也不能省略，如：（）=&gt; pro.noPad = () =&gt; { Console.WriteLine(“我是Test01”); }; 3.如果参数列表中只有一个参数，（）可以省略 pro.Pad = str =&gt; { Console.WriteLine(“我是{0}”, str); }; 4.如果方法体内只有一句代码，可以省略代码块符号，也就是不用写{ } pro.Pad = (str) =&gt; Console.WriteLine(“我是{0}”, str); ;pro.Pad = str =&gt; Console.WriteLine(“我是{0}”, str); ; 代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace anonymousMethods{ class Program { public delegate void noParameterDelegate(); //无参委托 public delegate void parameterDelegate(string str); //有参委托 public noParameterDelegate noPad; public parameterDelegate Pad; static void Main(string\\[\\] args) { Program pro = new Program(); //老方法 //pro.noPad = Test01; //pro.Pad = Test02; //pro.noPad(); //pro.Pad(&quot;武武武&quot;); //匿名方法 //pro.noPad = delegate () { Console.WriteLine(&quot;我是Test01&quot;); }; //pro.Pad = delegate (string str) { Console.WriteLine(&quot;我是{0}&quot;, str); }; //Lambda表达式 pro.noPad = () =&gt; { Console.WriteLine(&quot;我是Test01&quot;); }; pro.Pad = (str) =&gt; { Console.WriteLine(&quot;我是{0}&quot;, str); }; //一下三句话每句都可以替换掉第35句，即注释上面的这句话 //pro.Pad = str =&gt; { Console.WriteLine(&quot;我是{0}&quot;, str); }; //pro.Pad = (str) =&gt; Console.WriteLine(&quot;我是{0}&quot;, str); ; //pro.Pad = str =&gt; Console.WriteLine(&quot;我是{0}&quot;, str); ; pro.noPad(); pro.Pad(&quot;武武武&quot;); Console.ReadKey(); } /\\* public static void Test01() { Console.WriteLine(&quot;我是Test01&quot;); } public static void Test02(string str) { Console.WriteLine(&quot;我是{0}&quot;,str); }\\*/ }} 结果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081703-300x129.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C#之匿名方法","slug":"c之匿名方法","date":"2017-08-17T04:26:41.000Z","updated":"2020-07-05T08:56:50.919Z","comments":false,"path":"2017/08/17/c之匿名方法/","link":"","permalink":"http://yoursite.com/2017/08/17/c%E4%B9%8B%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"匿名方法从字面意思理解就是没有名字的方法。 在我们实际开发工作中，可能会有一些不常用且代码量小的方法存在，那么我们就可以把他写成匿名方法的形式，这样可以减少方法的繁琐和一些不必要的调用麻烦。 匿名语法格式： 委托类型变量 = delegate（[类型列表]） { 方法体； }； 1，新建一个C#控制台项目，未使用匿名方法的代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace anonymousMethods{ class Program { public delegate void noParameterDelegate(); //无参委托 public delegate void parameterDelegate(string str); //有参委托 public noParameterDelegate noPad; public parameterDelegate Pad; static void Main(string\\[\\] args) { Program pro = new Program(); pro.noPad = Test01; pro.Pad = Test02; pro.noPad(); pro.Pad(&quot;武武武&quot;); Console.ReadKey(); } public static void Test01() { Console.WriteLine(&quot;我是Test01&quot;); } public static void Test02(string str) { Console.WriteLine(&quot;我是{0}&quot;,str); } }} 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081701-300x129.jpg) 2.将以上代码改造成匿名方法的形式： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace anonymousMethods{ class Program { public delegate void noParameterDelegate(); //无参委托 public delegate void parameterDelegate(string str); //有参委托 public noParameterDelegate noPad; public parameterDelegate Pad; static void Main(string\\[\\] args) { Program pro = new Program(); //老方法 //pro.noPad = Test01; //pro.Pad = Test02; //pro.noPad(); //pro.Pad(&quot;武武武&quot;); //匿名方法 pro.noPad = delegate () { Console.WriteLine(&quot;我是Test01&quot;); }; pro.Pad = delegate (string str) { Console.WriteLine(&quot;我是{0}&quot;, str); }; pro.noPad(); pro.Pad(&quot;武武武&quot;); Console.ReadKey(); } /\\* public static void Test01() { Console.WriteLine(&quot;我是Test01&quot;); } public static void Test02(string str) { Console.WriteLine(&quot;我是{0}&quot;,str); }\\*/ }} 结果如下，可以看出跟上面未使用匿名方法一样：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081702-300x141.jpg)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C#之事件特性","slug":"c之事件特性","date":"2017-08-16T11:21:56.000Z","updated":"2020-07-05T08:56:50.916Z","comments":false,"path":"2017/08/16/c之事件特性/","link":"","permalink":"http://yoursite.com/2017/08/16/c%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%89%B9%E6%80%A7/","excerpt":"","text":"C#的事件其实是一个特殊的多播委托，只是加了event关键字来修饰。 在外部访问事件的时候要用+=的形式添加事件，比用=号安全。 1.新建一个C#控制台项目 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace Event{ class Program { //定义委托，注意返回值类型和参数列表类型要与事件所要处理的函数类型相同 public delegate void SendMessagerDelegate(string str); //定义事件，给委托只是增加了一个event关键字就变成了事件 public event SendMessagerDelegate sendMessageDel; //发出事件 public void EventComing(string str) { if(sendMessageDel!=null) { sendMessageDel(str); } } static void Main(string\\[\\] args) { Program pro = new Program(); Student stu01 = new Student(&quot;老王&quot;); Student stu02 = new Student(&quot;老李&quot;); Student stu03 = new Student(&quot;老张&quot;); //使用+=来订阅事件 pro.sendMessageDel += stu01.Message; pro.sendMessageDel += stu02.Message; //发出通知 pro.EventComing(&quot;我是武校长,请同学们9月1号准时到达学校&quot;); Console.WriteLine(&quot;-------------------------------------&quot;); Console.WriteLine(&quot;-------------------------------------&quot;); //取消老李的订阅事件，老李将无法接到通知 pro.sendMessageDel -= stu02.Message; //增加老张订阅事件 pro.sendMessageDel += stu03.Message; //发出通知 pro.EventComing(&quot;我是武校长,请同学们9月1号准时到达学校&quot;); Console.ReadKey(); } } class Student { public string Name; //构造函数 public Student(string name) { Name = name; } //事件要处理的函数，注意要符合SendMessagerDelegate委托的定义 public void Message(string str) { //输出收到的通知消息 Console.WriteLine(str); //对通知消息作出回应，即对事件做出处理 Console.WriteLine(this.Name + &quot;收到消息，我会准时到达学校&quot;); } }} 结果如下： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081601-300x137.jpg)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C#之多播委托","slug":"多播委托","date":"2017-08-14T08:24:21.000Z","updated":"2020-07-05T11:18:34.272Z","comments":false,"path":"2017/08/14/多播委托/","link":"","permalink":"http://yoursite.com/2017/08/14/%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98/","excerpt":"","text":"多播委托是一个“委托链”，可以一次传递(绑定)多个方法。 你也可以理解成一个数组，只是里面存放了很多方法。 多播委托的大致操作步骤： 1.委托类型 变量名称 public static MyDelegate myDelegate; 2.变量名称= 方法名；使用这种方式来给变量赋值； myDelegate = Question; myDelegate += new PersonAAA().AnswerAAA;myDelegate += new PersonBBB().AnswerBBB; myDelegate += Test;myDelegate -= Test; 3.变量名称([参数列表])； myDelegate(); 代码如下： 新建一个multicastDelegate的C#控制台项目，新建两个类PersonAAA和PersonBBB，重点在Program类 using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace multicastDelegate{ class PersonAAA { public void AnswerAAA() { Console.WriteLine(“我是PersonAAA,我喜欢郑州”); } }} using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace multicastDelegate{ class PersonBBB { public void AnswerBBB() { Console.WriteLine(“我是PersonBBB,我喜欢上海”); } }} Program类： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace multicastDelegate{ public delegate void MyDelegate(); class Program { public static MyDelegate myDelegate; static void Main(string\\[\\] args) { //委托变量赋值，第一次使用“=”号 myDelegate = Question; //第二次开始就要使用“+=”进行添加； //如果你还使用“=”，之前存在于该委托链内的方法，就会全丢失，只执行这个=的方法； myDelegate += new PersonAAA().AnswerAAA; myDelegate += new PersonBBB().AnswerBBB; myDelegate += Test; //可以使用“-=”把委托链中的某个方法移除 myDelegate -= Test; //调用委托，按赋值的先后顺序依次执行 myDelegate(); Console.ReadKey(); } private static void Question() { Console.WriteLine(&quot;你最喜欢哪个城市？&quot;); } private static void Test() { Console.WriteLine(&quot;测试用例&quot;); } }} 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081405-300x155.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C#委托之语法概要","slug":"委托之语法概要","date":"2017-08-13T12:33:32.000Z","updated":"2020-07-05T08:56:50.911Z","comments":false,"path":"2017/08/13/委托之语法概要/","link":"","permalink":"http://yoursite.com/2017/08/13/%E5%A7%94%E6%89%98%E4%B9%8B%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A6%81/","excerpt":"","text":"委托语法： 访问修饰符 delegate 返回值类型 委托名称 （参数列表）; public delegate void MyDelegate(int A, int B); 声明的委托要和要绑定的方法的“签名”保持一致，签名指的是方法的返回值类型，以及参数列表的类型。 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace delegateStart{ //声明的委托要和要绑定的方法的“签名”保持一致 //签名由方法的返回值类型，方法参数列表的类型，个数，顺序决定的。 //可以看出void是与JiaFa和JianFa相同的的返回值类型，int则是相同的参数列表类型 public delegate void MyDelegate(int A, int B); class Program { static void Main(string\\[\\] args) { string A= Console.ReadLine(); string B = Console.ReadLine(); //JiaFa(int.Parse(A),int.Parse(B)); //JianFa(int.Parse(A), int.Parse(B)); myDelegate(int.Parse(A), int.Parse(B), JiaFa); myDelegate(int.Parse(A), int.Parse(B), JianFa); Console.ReadKey(); } //委托可以把方法当做(方法的)参数来传递 private static void myDelegate(int A,int B,MyDelegate mydelegate) { mydelegate(A, B); } //加法运算 private static void JiaFa(int A,int B) { Console.WriteLine(string.Format(&quot;{0}+{1}={2}&quot;,A,B,A+B)); } //减法运算 private static void JianFa(int A,int B) { Console.WriteLine(string.Format(&quot;{0}-{1}={2}&quot;, A, B, A - B)); } }} 运行效果：输入两个数88和66，可以看到JiaFa和JianFa两个方法被成功调用了[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081302-300x115.png) 需要注意的是，我在上面的代码中把委托放到了类的外面，但是实际上也是可以放到类里边的。 区别在于： 如果放到一个类的外面，那么同一个命名空间下的所有类都可以访问这个委托； 如果放到一个类的内部，那么只能在当前类中访问。 实际开发中应该以实际需求来确定放外面还是放里面，如果这个委托只在这个类中使用，那么就可以放到类的里边，反之则放到外面。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"单例模式","slug":"单例模式","date":"2017-08-13T07:16:51.000Z","updated":"2020-07-05T11:17:17.950Z","comments":false,"path":"2017/08/13/单例模式/","link":"","permalink":"http://yoursite.com/2017/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式官方定义：确保一个类只有一个实例,并提供一个全局访问点。 1.新建一个singletonPattern的C#控制台项目，添加一个名为Singleton的类，代码如下： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace singletonPattern{ class Singleton { public string school = “郑州大学”; //定义一个当前类的字段 private static Singleton instance; //私有化构造方法，使外界不能通过new创建实例 private Singleton(){} //使用属性的方式实例化对象 public static Singleton Instance() { //如果实例不存在，就new一个，如果存在就返回实例 if(instance==null) { instance = new Singleton(); } return instance; } }} 2.回到Program类中我们访问这个实例： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace singletonPattern{ class Program { static void Main(string[] args) { Console.WriteLine(Singleton.Instance().school); Console.WriteLine(“————————————–”); Singleton.Instance().school = &quot;郑州大学软件与应用科技学院&quot;; Console.WriteLine(&quot;修改后的值：&quot;+Singleton.Instance().school); Console.ReadKey(); } }} 3.运行结果：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081301-300x142.png)","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"C#泛型类与泛型方法之语法","slug":"泛型类-泛型方法之语法格式","date":"2017-08-12T12:05:19.000Z","updated":"2020-07-05T08:56:50.907Z","comments":false,"path":"2017/08/12/泛型类-泛型方法之语法格式/","link":"","permalink":"http://yoursite.com/2017/08/12/%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B9%8B%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"首先新建一个C#控制台项目，命名为fanXingClassAndMethod。 一：泛型类的语法格式 1.新建一个名为Person的类，修改为泛型类，我在注释里写的很多，直接看代码吧： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace fanXingClassAndMethod{ //里面的T 可以用任何字母来代替，大小写都可以，但一般使用大写字母 //T代表一个不确定的类型 //这个类中有几个类型不确定，就在&lt;&gt;内写几个“类型占位符”，即可写成Person&lt;T,K&gt;，Person&lt;T,K,L&gt;等。 class Person { public string name; public int age; public T info; public void Show() { Console.WriteLine(string.Format(&quot;{0}---{1}---{2}&quot;,name,age,info)); } }} 2，在Program的类中实例化一个Person，并且调用它的Show： using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace fanXingClassAndMethod{ class Program { static void Main(string[] args) { Person p1 = new Person(); p1.name = “武大人”; p1.age = 18; p1.info = “郑州大学”; p1.Show(); Console.ReadKey(); } }} 3，运行项目： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081201-300x139.jpg) 二：泛型方法的语法格式 在定义方法的时候，方法名的后面使用来定义。 1.如果当前的方法所在的类中，已经定义了这个类型，方法名的后面就不需要再次定义； 例如： public T Attempt() { } using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace fanXingClassAndMethod{ class Person { public string name; public int age; public T info; public void Show() { Console.WriteLine(string.Format(&quot;{0}---{1}---{2}&quot;,name,age,info)); } //已经定义了T这个类型 public T Attempt() { return info; } }} using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace fanXingClassAndMethod{ class Program { static void Main(string[] args) { Person p1 = new Person(); p1.name = “武大人”; p1.age = 18; p1.info = “郑州大学”; p1.Show(); Console.WriteLine(p1.Attempt()); Console.ReadKey(); } }} 结果如下：[ 2.如果当前的方法所在的类中，没有定义这个类型，方法名的后面就需要再次定义； { } using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace fanXingClassAndMethod{ class Program { static void Main(string[] args) { Person p1 = new Person(); p1.name = “武大人”; p1.age = 18; p1.info = “郑州大学”; p1.Show(); //Console.WriteLine(p1.Attempt()); Console.WriteLine(Attempt&lt;string&gt;(&quot;我爱郑大&quot;)); Console.ReadKey(); } public static K Attempt&lt;K&gt;(K text) { return text; } } } 结果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17081203-300x135.jpg)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"UnityShader的基本构成以及属性","slug":"unityshader的基本构成以及属性","date":"2017-08-09T08:56:38.000Z","updated":"2020-07-05T11:22:19.610Z","comments":false,"path":"2017/08/09/unityshader的基本构成以及属性/","link":"","permalink":"http://yoursite.com/2017/08/09/unityshader%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7/","excerpt":"","text":"新建一个名为firstShader的Shader，选择Standard Surface Shader,双击打开，可以看到如下脚本： Shader “Custom/firstShader” { Properties { _Color (“Color”, Color) = (1,1,1,1) _MainTex (“Albedo (RGB)”, 2D) = “white” {} _Glossiness (“Smoothness”, Range(0,1)) = 0.5 _Metallic (“Metallic”, Range(0,1)) = 0.0 } SubShader { Tags { “RenderType”=”Opaque” } LOD 200 CGPROGRAM // Physically based Standard lighting model, and enable shadows on all light types #pragma surface surf Standard fullforwardshadows // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D \\_MainTex; struct Input { float2 uv\\_MainTex; }; half \\_Glossiness; half \\_Metallic; fixed4 \\_Color; // Add instancing support for this shader. You need to check &apos;Enable Instancing&apos; on materials that use the shader. // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. // #pragma instancing\\_options assumeuniformscaling UNITY\\_INSTANCING\\_CBUFFER\\_START(Props) // put more per-instance properties here UNITY\\_INSTANCING\\_CBUFFER\\_END void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (\\_MainTex, IN.uv\\_MainTex) \\* \\_Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = \\_Metallic; o.Smoothness = \\_Glossiness; o.Alpha = c.a; } ENDCG } FallBack &quot;Diffuse&quot;} 借助上面的代码构造可以看出Shader的基本结构： Shader “——–” Properties { Subshader { {Pass} {Pass} } } FallBack “——-“ 1.Properties的基本结构，我将在下面的代码中介绍属性： _Name(“DisplayName”,Type) = defaultValue 2.一个Shader中一般都会有好几个SubShader{}，他们的效果也不同,之所以有这么多是为了满足不同的显卡能力。 当我们的显卡运行到此Shader的时候，会从第一个SubShader开始检测，检测自己是否带的动这种效果，如果带不动，那么检测下一个，直到有一个能带的动的效果。 那万一我们的显卡带不动所有的SubShade，怎么办呢，看3 3.代码中最后一句话是：FallBack “Diffuse” 这句话的意思是，如果前面所有的shader代码都无法运行或者运行失败，那么会启动这个名叫Diffuse的shader 4.Subshader中有多个Pass，一个Subshader中的所有Pass会被依次执行 5.我把firstShader中多余的代码给删除了，介绍一下属性，代码如下： Shader “Custom/firstShader”{ Properties { _Int(“MyInt”,Int) = 2 //整数 Int _Float(“MyFloat”,Float) = 1.0 //浮点数 Float _Range(“MyRange”,Range(0.0,1.0)) = 0.5 //范围浮点数 Range _Color(“MyColor”,Color) = (1,1,1,1) //颜色 Color _Vector(“MyVector”,Vector) = (1,2,3,1) //四元素向量 Vector _MainTex(“Texture”, 2D) = “white” {} //普通贴图 2D _Cube(“MyCubeMap”,Cube) = “white”{} //正方体贴图 Cube _3D(“My3D”,3D) = “white”{} //3D贴图 3D } } 6.点击保存，回到unity，新建一个材质球，并把材质球给一个cube： [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080901-300x262.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080901.png) 7.给材质球添加我们的Shader，点击图中箭头处，点击Custom，点击firstShader，可以看到属性面板就变成了刚才我们代码中定义的东西。 方块变成了粉红色是因为我们的Shader代码并不完整，导致材质球错误。 在Unity中，如果我们的模型变成了粉红色，那一定是丢失了材质球 [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080902-300x239.png)","categories":[],"tags":[{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"},{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/tags/Shader/"}]},{"title":"Five Hundred Miles","slug":"five-hundred-miles","date":"2017-08-09T02:17:36.000Z","updated":"2020-07-05T08:56:49.141Z","comments":false,"path":"2017/08/09/five-hundred-miles/","link":"","permalink":"http://yoursite.com/2017/08/09/five-hundred-miles/","excerpt":"","text":"《Five Hundred Miles》，来自Justin Timberlake/Carey Mulligan/Stark Sands的Inside Llewyn Davis。 发行于：2013 曲目4。 流派：Folk。","categories":[],"tags":[]},{"title":"Unity导航系统笔记三：Bake与Object","slug":"unity导航系统笔记三：bake与object","date":"2017-08-07T16:09:55.000Z","updated":"2020-07-05T08:56:50.902Z","comments":false,"path":"2017/08/08/unity导航系统笔记三：bake与object/","link":"","permalink":"http://yoursite.com/2017/08/08/unity%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9Abake%E4%B8%8Eobject/","excerpt":"","text":"Bake面板常用属性： 1.Agent Radius导航代理器半径 当我们的场景中有障碍物时，在烘培场景的时候，会自动在我们的障碍物旁边留白，半径数值越高，留白就越大，看图： 2.Agent Height导航代理器的高度 当我们角色的上方有障碍物时，如果障碍物与地面的距离过小，也就是说距离小于Agent Height的数值，那么障碍物覆盖下的地面不会生成导航网格，看图： 3.Max Slope最大爬坡能力 当我们场景中有斜坡时，只要坡度不超过Max Slope的数值，就能生成导航网格，即角色可以爬上去，看图： 动态效果如下： 4.Step Height台阶高度 设置角色爬台阶的高度能力，只要台阶的高度不超过Step Height的数值，那就能上台阶，跟爬坡类似，不截图了 Object面板属性： Navigation Static：表示此物体是否在导航系统里面 Generate OffMeshLinks：生成“网格跳跃线”，在上一篇文章讲了网格跳跃线，也就是OffMeshLink Navigation Area：定义此处导航区域属于哪种地形区域，意味着走这条路付出的代价值不同。","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"Unity导航系统笔记二：OffMeshLink操作使用","slug":"unity导航系统笔记二：offmeshlink操作使用","date":"2017-08-07T15:20:04.000Z","updated":"2020-07-05T08:56:50.900Z","comments":false,"path":"2017/08/07/unity导航系统笔记二：offmeshlink操作使用/","link":"","permalink":"http://yoursite.com/2017/08/07/unity%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9Aoffmeshlink%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在导航系统中，如果要导航的两个地方没有相连那怎么办呢? 仔细看这张图(注意有两个小方块），我们会发现两个平面之间并没有连接起来，那么也就意味着我们的方块不能到达小绿球身边，那么如何能使它到达呢，就要用到我们的OffMeshLink组件 OffMeshLink面板属性如下：介绍几个前期常用的属性： 1.Start 和End 设置开始点，结束点 2.Bi Directional（双向跳越线） 如果勾选的话，会是一个双向的路线，能去也能回 如果不勾选，则有去无回 3.Activated 组件处于激活状态 4.Auto Update Position 自动更新位置 下面开始实际操作： 1，首先将模型摆放成第一张图的样式，并点击Navigation的Bake。 2，新建两个Cube，一个叫startCube，一个叫endCube,自定义大小，调整位置，尽量跟图上一样，贴近地面。 3，给startCube加OffMeshLink组件，将startCube拖入Start，endCube拖入End，设置如下：4.点击Bake，效果应该是这样(打开Navgiation面板)：注意：两个cube旁白都要有圆环才说明Bake成功，角色可以传送。如果没有圆环，那么说明cube位置离Bake区域太远，手动调整cube的位置。 另外这两个Cube不需要设置为静态，因为他们不参与导航网格的烘培 5.运行项目，看看效果： 实际开发中，并不需要我们每次都建立cube模型，空物体也可以，有Transform组件就行","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"HoIoLens开发笔记二：实现全息应用","slug":"hoiolens开发笔记二：实现全息应用","date":"2017-08-06T07:25:27.000Z","updated":"2020-07-05T08:56:50.897Z","comments":false,"path":"2017/08/06/hoiolens开发笔记二：实现全息应用/","link":"","permalink":"http://yoursite.com/2017/08/06/hoiolens%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%81%AF%E5%BA%94%E7%94%A8/","excerpt":"","text":"在第一篇文章，我写了如何配置环境。 那么这一篇是实战，我们将创建一个属于自己的全息影像应用，看完这篇文章，你就可以说你给微软开发过App了…… 开发环境：Unity5.6 , VS2015 Update3 , HoIoLens emulator 1.打开Unity，新建一个场景名叫myFirstHoIoLensApp，点击创建 2.首先打开File下的Build Setting，安装Windows Store 3.保存场景，命名为firstScene 将Main Camera的Position设置为(0,0,0),也就是起始点的意思。因为这个摄像机在我们的HoIoLens 中，就相当于我们眼睛位置，我们眼睛看到的东西其实就是他看到的东西。 修改Main Camera下的几个属性，我在图上标注出来了，我决定在后面不再介绍这些基础的属性了，没必要写。 之所以把背景变成黑色是因为电脑在渲染的时候无法渲染黑色，所以黑色的区域在实际项目中就会是透明的样式。 4.点击第二张图中的Player Setting，点击windows store 找到Other setting，勾选图中的按钮 点击Publishing Setting 在下面找到这个属性面板：勾选几个我们常用的功能，后面写其他文章时也会用到，剩下的功能可以花点时间再去研究： SpatialPerception:空间锚以及SurfaceObserver Microphone：听写识别，键盘识别等 InterentClient：小娜语音识别 5.因为我们的项目最终要导入到UWP平台，所以设置SDK，Build Type 因为HoIoLens性能不够强的原因，我们把我们的项目质量调成最低，点击Edit下的Project setting下的Quality，选中Fastest。 6.在场景中新建一个Cube，设置位置和角度： 挂一个脚本在cube身上，让它绕X轴和Y轴一直旋转： using System.Collections;using System.Collections.Generic;using UnityEngine; public class cubeRotate : MonoBehaviour { // Use this for initialization void Start () { } // Update is called once per frame void Update () { transform.Rotate(new Vector3(1, 1, 0)); }} 7.保存场景，打开build setting，设置如下，点击build。[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080611-300x175.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080611.png) 等build结束，可以看到生成了一个VS 文件，双击用vs2015打开[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080612-300x102.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080612.png) 8.按照我图上的配置来： [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080613-300x127.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080613.jpg) 9.运行项目，第一次失败了[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080614-300x134.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080614.png) 查看问题描述，原来是方法过时了[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080615-300x60.png) 我又仔细看了看，用新语句替代了过时的函数： ApplicationView.GetForCurrentView().TryEnterFullScreenMode(); [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080616-300x107.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080616.png)好了，再次运行，成功了 注意，如果你的GPU不太好的话，要等几分钟，只要没报错就一定能运行，等着就行。 在这里你可以和小娜对话，因为HoIoLens本质上就是一台win10电脑 [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080617-300x161.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080617.png)打开我们的应用：[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080618-300x263.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080618.png)动态效果如下（模型好像一开始做大了，不过还行）：[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080619-300x146.gif) 10.模拟器的一些操作： W,A,S,D 模拟移动 上下左右键 跟模拟移动类似 enter 确认键 按住Alt键并且用鼠标右键可以拖动画面 windows键可以在任何场景中调出主面板 用了两个小时，终于写完了…… 希望我写的内容你能明白，后面准备写点语音识别的","categories":[],"tags":[{"name":"AR-VR-MR","slug":"AR-VR-MR","permalink":"http://yoursite.com/tags/AR-VR-MR/"}]},{"title":"HoIoLens开发笔记一：配置环境","slug":"hoiolens开发笔记一：配置环境","date":"2017-08-05T09:01:04.000Z","updated":"2020-07-05T08:56:50.894Z","comments":false,"path":"2017/08/05/hoiolens开发笔记一：配置环境/","link":"","permalink":"http://yoursite.com/2017/08/05/hoiolens%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/","excerpt":"","text":"微软黑科技HoIoLens终于在国内开卖了，个人开发者版本23000RMB,商业版本三万多吧。高昂的售价给开发者带来了不小的难度，但是微软出了一个模拟器可以让我们不需要物理设备来测试我们的Demo，实际开发中还是在物理设备上测试是最好的。 HoIoLens的开发环境配置要求比较多： 1.首先你的电脑系统必须是64win10，而且不能是家庭版，因为家庭版不支持Hyper-V，所以我建议去装个win10专业版再深入研究，因为这是第一步。 2，你电脑至少需要8G内存，如果少于8G会导致项目运行失败，我8G的内存每次测试都能飙到百分之八九十。 2.你的vs版本必须是Visual Studio 2015 Update 2之后的版本，建议安装Visual Studio 2015 Update 3. 看了上面的几个条件，是不是想放弃，因为你很可能都不满足，没关系，花10分钟重装个系统吧，下面开始实际操作： 注意：需要按步骤一步一步来 1.安装Visual Studio 2015 Update 3 http://blog.csdn.net/wuyb_2004/article/details/51992038 可以选择社区版或企业版, 需要注意的是安装的时候一定要勾选Tools (1.4) and Windows 10 SDK (10.0.10586)，如果不装的话，那么接下来HoloLens Emulator将会装不了 2.开启Hyper-V 打开控制面板，选择程序，点击启用或关闭windows功能 勾选Hyper-v这个选项，然后电脑应该会提示需要重启3.BIOS中设置开启： Hardware-assisted virtualization Second Level Address Translation (SLAT) Hardware-based Data Execution Prevention (DEP) 如果没开启就开启，如果说你实在找不到前三项中的某一个，可以先不管，继续下一步，后期出错了可以再检查bios。 这一步是必须的，找到Security，启用Intel (R) Virtualization Technology，保存退出。 4.安装HoloLens Emulator http://go.microsoft.com/fwlink/?LinkID=823018 大小在1G左右，直接安装到默认目录即可，避免VS找不到 5。下载Unity，建议下载Unity5.6，5.5版本也可以。 https://unity3d.com/cn/get-unity/download/archive?_ga=2.103143812.581686941.1501922750-85097662.1496740748 Unity2017版本刚出来，我也不清楚怎么样，微软跟Unity的蜜月期应该不会这么短暂吧 6.配置环境已经完成了，实践是检验真理的唯一标准，后面几篇文章讲实践。","categories":[],"tags":[{"name":"AR-VR-MR","slug":"AR-VR-MR","permalink":"http://yoursite.com/tags/AR-VR-MR/"}]},{"title":"AR开发常用SDK推荐","slug":"ar开发常用sdk推荐","date":"2017-08-05T07:28:23.000Z","updated":"2020-07-05T08:56:50.891Z","comments":false,"path":"2017/08/05/ar开发常用sdk推荐/","link":"","permalink":"http://yoursite.com/2017/08/05/ar%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8sdk%E6%8E%A8%E8%8D%90/","excerpt":"","text":"SDK推荐：Vuforia，EasyAR, HiAR 开发环境：Unity，Android, VS2015 以上三个是我都用过的，其中Vuforia应该是用的最多的，后两个都是国内的，各有特点，总的来说也不错，国内还有一个叫太虚AR的，听过没用过。苹果推出的那个ARKit受限于设备问题(没mac，没iphone……），也就一直没去关注。 1.Vuforia的SDK https://developer.vuforia.com/ Vuforia大概五六年前就推出了自己的SDK，更新到现在，功能已经很完善了,云识别，智能地形，虚拟按钮,SLAM呀等等，总的来说功能很强大。但是我总感觉它在国内水土不服，要不然国内的这几个ARsdk估计也不会发展这么快吧，Hiar，EasyAR跟国内的支付宝，腾讯qq这些都有合作关系。 Vuforia的云识别很不好用，你要问我怎么不好用的话，建议你打开他们官网，看看你用了多久打开。 还有一点就是他里边的很多东西是不开源的，这非常限制开发者的开发。 2.EasyAR的SDK http://www.easyar.cn/ 国内这家公司的SDK还是很有诚意的，SDK完全免费（近期出了付费版本，但是免费版本依然够用），而且大部分东西都是开源的。 将他们的安卓SDK导入Android Studio中，你可以看到他们的底层代码，通过配置他们的Json文件，原生开发APP，但是如果你的APP涉及到模型动画之类的，还是要用到Unity。 缺点也很明显，SLAM技术不成熟，云识别虽然不稳定，但是流媒体的视频播放还是很给力的。 3.HiAR的SDK http://www.hiar.com.cn/download.html HiAR也是国内的一款SDK，我觉得它的云识别是最好的。 当你的app打包完成后，你可以登录他们的管理后台，给你的app动态的上传识别图和AssetBundle资源包来实现app后台内容的管理，直接秒杀所有云识别，缺点是不太稳定，偶尔会识别不出来，还有就是制作AssetBundle包也不是一步就成的。 他们官网的SDK已经半年多没更新了，应该是在憋大招，听说是在折腾眼镜。 这三个SDK目前都发展很好，网上也有很多教程，学好一个就明白这些SDK的套路了，再研究其他的也不是太难。但是如果想利用其做一个大型的多用户的APP，还是不容易呀……","categories":[],"tags":[{"name":"AR-VR-MR","slug":"AR-VR-MR","permalink":"http://yoursite.com/tags/AR-VR-MR/"}]},{"title":"安装第三方图形库EasyGui以及常用操作","slug":"安装第三方图形库easygui以及常用操作","date":"2017-08-05T04:44:50.000Z","updated":"2020-07-05T11:09:43.090Z","comments":false,"path":"2017/08/05/安装第三方图形库easygui以及常用操作/","link":"","permalink":"http://yoursite.com/2017/08/05/%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%9B%BE%E5%BD%A2%E5%BA%93easygui%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"进入EasyGui官网：http://easygui.sourceforge.net/ 点击下载，解压后easygui.py拷贝进python安装目录下的Lib\\site-packages文件夹下。 打开IDLE，官方建议是不要在IDLE上运行EasyGui，所以我们新建一个file，我们在这里写我们的新程序。[ , choices=(Button1',","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"用Sketch写一个简单的弹球程序","slug":"用sketch写一个简单的弹球程序","date":"2017-08-05T03:32:04.000Z","updated":"2020-07-05T11:11:41.318Z","comments":false,"path":"2017/08/05/用sketch写一个简单的弹球程序/","link":"","permalink":"http://yoursite.com/2017/08/05/%E7%94%A8sketch%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%B9%E7%90%83%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"效果如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080501-300x285.gif) 代码在下面，我已经加了很多注释了： //小球的位置和速度float x=100;float y=100;float xspeed=1;float yspeed=3; //setup启动时调用一次void setup(){ size(200,200); //窗口尺寸大小 smooth(); //开启平滑模式 background(255); //背景色} //draw启动后一直调用void draw(){ background(255); //根据速度移动小球 x=x+xspeed; y=y+yspeed; //检测边缘，用来改变速度方向 if((x&gt;width)||(x&lt;0)) { xspeed=xspeed*-1; } if((y&gt;width)||(y&lt;0)) { yspeed=yspeed*-1; } stroke(0); //边框颜色 fill(175); //填充颜色 ellipse(x,y,16,16); //在(x,y)位置绘制小球 }","categories":[],"tags":[{"name":"Processing","slug":"Processing","permalink":"http://yoursite.com/tags/Processing/"}]},{"title":"Unity导航系统笔记一：NavMeshAgent基本使用","slug":"unity导航系统笔记一：navmeshagent","date":"2017-08-04T15:36:18.000Z","updated":"2020-07-05T08:56:50.886Z","comments":false,"path":"2017/08/04/unity导航系统笔记一：navmeshagent/","link":"","permalink":"http://yoursite.com/2017/08/04/unity%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9Anavmeshagent/","excerpt":"","text":"最近在研究导航功能，正好可以写几篇笔记。 在Unity中，NavMeshAgent组件负责实现导航功能，面板属性如下：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080458-217x300.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080458.png) 几个常用的属性： Radius[半径]：控制代理器这个“圆柱体”的半径； Height[高度]：控制代理器这个“圆柱体”的高度； Base Offset[基础偏移]：控制代理器这个“圆柱体”在垂直方向的偏移量； Speed[速度]：导航的移动速度； Angular Speed[转弯速度]：模型是Y 轴朝向目标点；如果不是，则转向； Acceleration[加速度]：保持默认即可； Stopping Distance[停止距离]：距离目的地多远的时候停止； Auto Braking[自动停止]：保持默认勾选状态即可； 下面开始实战： 1.新建一个plane，设置为static，即静态物体[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080459-300x176.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080459.png) 2.打开Window下的Navigation面板，选中Bake，点击Bake，烘焙导航场景，可以看到Plane上加了一片蓝颜色区域，这就是可移动区域。[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080460-220x300.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080460.png)[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080461-300x146.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080461.png) 3.新建一个Cube放在Plane上面，给Cube添加NavMeshAgent组件，新建一个Sphere，也放在Plane上面[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080462-300x146.png) 4.新建一个C#脚本PlayerGo放在我们的Cube身上 脚本内容如下： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;//引入AI，才能操作导航系统的组件public class PlayerGo : MonoBehaviour{ private NavMeshAgent m_NavMeshAgent;//定义Cube身上的NavMeshAgent public Transform m_Transform; //公开定义我们的Sphere // Use this for initialization void Start () { m_NavMeshAgent = gameObject.GetComponent(); } // Update is called once per frame void Update () { //方法：SetDestination(目标点位置); //m\\_NavMeshAgent.SetDestination(m\\_Transform.position); //属性：destination = 目标点位置; m\\_NavMeshAgent.destination = m\\_Transform.position; //18行代码和21行代码作用一样，都是引导目的地的位置 }} 5.找到Cube身上的脚本，把Sphere拖进去[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080463-300x161.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080463.png) 6.运行测试：下图为GIF图，点击图片查看动态效果：[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080464-300x209.gif)","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"GetComponentsInChildren函数使用细节","slug":"component-getcomponentsinchildren函数使用细节","date":"2017-08-04T14:51:16.000Z","updated":"2020-07-05T08:56:50.884Z","comments":false,"path":"2017/08/04/component-getcomponentsinchildren函数使用细节/","link":"","permalink":"http://yoursite.com/2017/08/04/component-getcomponentsinchildren%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/","excerpt":"","text":"Component.GetComponentsInChildren:获取所有子物体 GetCompentsInChildren会将父物体一块找到，并当作列表中的第0个元素，因此在写for语句遍历的时候，需要从i=1开始，而不是i=0. 以下代码并不能运行，理解大致意思即可，即i需要从1开始 private Transform[] points;void Start () { m_Transform = gameObject.GetComponent(); points = GameObject.Find(“CreatePoints”).GetComponent().GetComponentsInChildren(); }for (int i = 1; i &lt; points.Length; i++)//注意i从1开始 { GameObject temp = GameObject.Instantiate(prefab_AAA, points[i].position, Quaternion.identity); //动态的给monster添加脚本. Monster monster = temp.AddComponent&lt;Monster&gt;(); //设置父物体 temp.GetComponent&lt;Transform&gt;().SetParent(m\\_Transform); }","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"}]},{"title":"Autodesk软件激活问题","slug":"autodesk软件激活问题","date":"2017-08-04T09:58:57.000Z","updated":"2020-07-05T11:12:20.244Z","comments":false,"path":"2017/08/04/autodesk软件激活问题/","link":"","permalink":"http://yoursite.com/2017/08/04/autodesk%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"Autodesk公司的软件激活的套路是一样的，本文章以Maya2016为例。 1.安装完成后，启动看到如下页面：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080451-290x300.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080451.jpg)2.点击激活，选择我具有Autodesk的激活码，记住图中的申请号。[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080452-300x288.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080452.png)3.一定一定要用管理员身份打开xf-adsk2016这个软件，注意软件版本的位数一定要与安装的maya版本对应，也就是说64位的Maya要用64位的破解软件来破解[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080457-300x39.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080457.png)4.打开软件后，首先点击左边的Patch按钮[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080453-300x167.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080453.jpg)5.点击确定[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080454-300x204.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080454.jpg) 6.清空Request，将第二个步骤里的申请号复制到那里，点击Generate，Activation会生成一串较长的激活码，复制Activation里的激活码，建议先全选再复制，直接ctrl+v粘贴到下图中右边的框框里，点击下一步。[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080455-300x136.jpg)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080455.jpg) 8.激活成功[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080456-300x273.jpg) 注意事项：如果按步骤操作但是最后一步未激活成功，可以从第四步开始再来一次。一般一次就能激活成功，但是有时候需要两三次，可能是没断网的原因吧。","categories":[],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://yoursite.com/tags/Misc/"}]},{"title":"Java开发环境的配置","slug":"java开发环境的配置","date":"2017-08-04T09:28:13.000Z","updated":"2020-07-05T08:56:50.879Z","comments":false,"path":"2017/08/04/java开发环境的配置/","link":"","permalink":"http://yoursite.com/2017/08/04/java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"每次重装系统后，我都是先配置Java环境，但是按照网上的步骤总是在运行javac命令行时失败，后来发现是path的问题，下面是完整的配置的步骤。 1.首先来到oracle官网http://www.oracle.com/technetwork/java/javase/downloads/index.html 点击这里：[ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080438-300x174.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080438.png) 2.勾选Accept按钮，然后下载32位或者64位jdk:[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080439-294x300.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080439.png) 3.建议安装之前，现在D盘新建个名叫Java的文件夹，再建一个jdk子文件夹和一个jre子文件夹，一会要用到[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080440-300x47.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080440.png)4.打开下载好的exe文件开始安装，安装过程中，把jdk的路径放到我们刚才新建的jdk文件夹中[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080441-300x224.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080441.png) 5.把jre的路径也放到刚才新建的jre文件夹[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080442-300x225.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080442.png)6.安装完成后，进入电脑属性面板，点击高级系统设置[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080443-300x174.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080443.png)7.点击环境变量[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080450-266x300.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080450.png)8.点击新建[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080444-300x288.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080444.png)9.输入变量名：JAVA_HOME 变量值：D:\\Java\\jdk 点击确定[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080445-300x72.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080445.png)10.再次点击新建 输入变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib 注意符号，点击确定[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080446-300x72.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080446.png) 11.双击Path，点击新建，在最后一行加入：D:\\Java\\jdk\\bin 完成后点击确定 [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080447-300x229.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080447.png)12.按windows+R键，输入cmd，依次在命令行输入java和javac，如果如下图所示，则说明配置完成。[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080448-300x160.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080448.png)[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080449-300x164.png)","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Unity操作XML","slug":"unity操作xml","date":"2017-08-04T06:39:30.000Z","updated":"2020-07-05T11:21:43.036Z","comments":false,"path":"2017/08/04/unity操作xml/","link":"","permalink":"http://yoursite.com/2017/08/04/unity%E6%93%8D%E4%BD%9Cxml/","excerpt":"","text":"1.读取XML 中的数据并展示出来 &lt;1&gt;实例化一个XML 文档操作对象； &lt;2&gt;使用XML 对象加载XML； &lt;3&gt;获取根节点； &lt;4&gt;获取根节点下所有子节点； &lt;5&gt;遍历输出。 XML文件： 止戈为武 www.wjgbaby.com &lt;Item id=&quot;2&quot;&gt; &lt;name&gt;百度&lt;/name&gt; &lt;url&gt;www.baidu.com&lt;/url&gt; &lt;/Item&gt; &lt;Item id=&quot;3&quot;&gt; &lt;name&gt;Unity&lt;/name&gt; &lt;url&gt;www.unity3d.com&lt;/url&gt; &lt;/Item&gt; 在Unity中调用我们的XML文件： using UnityEngine;using System.Collections;using System.Xml; //引入XML操作相关的命名空间. /// /// XML操作演示./// public class XMLDemo : MonoBehaviour { //定义一个字段,存储xml的路径. private string xmlPath = &quot;Assets/Datas/web.xml&quot;; void Start () { ReadXMLByPath(xmlPath); } /// &lt;summary&gt; /// 通过路径读取XML中的数据进行显示. /// &lt;/summary&gt;/// xml的路径地址 private void ReadXMLByPath(string path) { //&lt;1&gt;实例化一个XML文档操作对象. XmlDocument doc = new XmlDocument(); //&lt;2&gt;使用XML对象加载XML. doc.Load(path); //&lt;3&gt;获取根节点. XmlNode root = doc.SelectSingleNode(&quot;Web&quot;); //&lt;4&gt;获取根节点下所有子节点. XmlNodeList nodeList = root.ChildNodes; //&lt;5&gt;遍历输出. foreach(XmlNode node in nodeList) { //取属性. int id = int.Parse(node.Attributes\\[&quot;id&quot;\\].Value); //取文本. string name = node.ChildNodes\\[0\\].InnerText; string url = node.ChildNodes\\[1\\].InnerText; Debug.Log(id + &quot;--&quot; + name + &quot;--&quot; + url); } }}","categories":[],"tags":[{"name":"XML/JSON","slug":"XML-JSON","permalink":"http://yoursite.com/tags/XML-JSON/"}]},{"title":"XML简介","slug":"xml简介","date":"2017-08-04T06:32:41.000Z","updated":"2020-07-05T11:21:43.027Z","comments":false,"path":"2017/08/04/xml简介/","link":"","permalink":"http://yoursite.com/2017/08/04/xml%E7%AE%80%E4%BB%8B/","excerpt":"","text":"XML：可扩展标记语言。 XML 类似于HTML，都是标签（标记）语言。 在软件开发的各个领域（Web，Android，IOS，Game，EXE…）都可以 看到XML 文件的身影。 XML 的作用是用于传输和存储数据。 XML 本身就是一个存储的文本。 XML 的语法结构： XML 文档的语法结构最终是一个树状结构。 主要组成部分：根元素，子元素，属性，文本。 XML 注意事项 ①XML 标签对大小写很敏感； ②XML 标签必须正确的嵌套； ③XML 标签中的属性值必须加（双）引号； ④XML 文档必须有根元素。","categories":[],"tags":[{"name":"XML/JSON","slug":"XML-JSON","permalink":"http://yoursite.com/tags/XML-JSON/"}]},{"title":"客户端的编写","slug":"客户端的编写","date":"2017-08-04T06:25:53.000Z","updated":"2020-07-05T08:56:50.867Z","comments":false,"path":"2017/08/04/客户端的编写/","link":"","permalink":"http://yoursite.com/2017/08/04/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%96%E5%86%99/","excerpt":"","text":"打开Unity，创建一个新项目，新建文件夹Plugins，打开photon的lib文件夹，将Photon3Unity3D.dll拖入Plugins。 Plugins文件介绍： 如果做手机游戏开发一般 andoird 或者 ios 要接一些sdk 可以把sdk依赖的库文件 放在这里，比如 .so .jar .a 文件，这样打完包以后就会自动把这些文件打在你的包中。 新建C#脚本PhotonManger， 添加引用using ExitGames.Client.Photon; 添加接口IPhotonPeerListener，实现抽象类和构造函数。 PhotonManger.cs代码如下，我加的有注释： using System.Collections;using System.Collections.Generic;using UnityEngine;using ExitGames.Client.Photon;using System; public class PhotonManger : MonoBehaviour,IPhotonPeerListener{ private PhotonPeer peer; private ConnectionProtocol protocol = ConnectionProtocol.Udp; //udp传输协议 private string serverAddress = “127.0.0.1:5055”; //服务器目前的ip地址 private string applicationName = “ChatRoom”; //服务器程序名称 bool connected = false; void Awake() { peer = new PhotonPeer(this, protocol); } void Update () { if (!connected) { peer.Connect(serverAddress, applicationName); //，如果服务器未连接，那么连接服务器 } peer.Service(); if(Input.GetKeyDown(KeyCode.Space)) { var parameters = new Dictionary&lt;byte,object&gt;(); //字典 parameters.Add(0, &quot;武宝宝&quot;); peer.OpCustom(1, parameters, true); //给服务器发请求 } } /// &lt;summary&gt; /// 服务器断开调用，避免Unity卡死，我一开始没写这个方法unity死了很多次 /// &lt;/summary&gt; void OnDestroy() { peer.Disconnect(); } /// &lt;summary&gt; /// 返回时调用 /// &lt;/summary&gt; /// &lt;param name=&quot;level&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; public void DebugReturn(DebugLevel level, string message) { } public void OnEvent(EventData eventData) { } /// &lt;summary&gt; /// 服务器给客户端的响应 /// &lt;/summary&gt; /// &lt;param name=&quot;operationResponse&quot;&gt;&lt;/param&gt; public void OnOperationResponse(OperationResponse operationResponse) { Debug.Log(&quot;服务器给客户端的响应&quot;); } /// &lt;summary&gt; /// 连接状态改变 /// &lt;/summary&gt; /// &lt;param name=&quot;statusCode&quot;&gt;&lt;/param&gt; public void OnStatusChanged(StatusCode statusCode) { Debug.Log(statusCode.ToString()); switch(statusCode) { case StatusCode.Connect: connected = true; break; case StatusCode.Disconnect: connected = false; break; } }} 现在回到ChatRoom项目中， MyServer.cs代码如下： using ExitGames.Logging;using ExitGames.Logging.Log4Net;using log4net;using log4net.Config;using Photon.SocketServer;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks; namespace ChatRoom{ public class MyServer : ApplicationBase { private static readonly ILogger log = ExitGames.Logging.LogManager.GetCurrentClassLogger(); /// &lt;summary&gt; /// 日志输出 /// &lt;/summary&gt; /// &lt;param name=&quot;str&quot;&gt;&lt;/param&gt; public static void Log(string str) { log.Info(str.ToString()); } /// &lt;summary&gt; /// 客户端连接 /// &lt;/summary&gt; /// &lt;param name=&quot;initRequest&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override PeerBase CreatePeer(InitRequest initRequest) { return new MyClient(initRequest); } /// &lt;summary&gt; /// 服务器启动时调用 /// &lt;/summary&gt; protected override void Setup() { InitLogging(); Log(&quot;Setup OK&quot;); } /// &lt;summary&gt; /// 产生一个log文件，存放我们的log /// &lt;/summary&gt; protected virtual void InitLogging() { ExitGames.Logging.LogManager.SetLoggerFactory(Log4NetLoggerFactory.Instance); GlobalContext.Properties\\[&quot;Photon:ApplicationLogPath&quot;\\] = Path.Combine(this.ApplicationRootPath, &quot;log&quot;); GlobalContext.Properties\\[&quot;LogFileName&quot;\\] = &quot;wjg&quot; + this.ApplicationName; XmlConfigurator.ConfigureAndWatch(new FileInfo(Path.Combine(this.BinaryPath, &quot;log4net.config&quot;))); } /// &lt;summary&gt; /// 服务器停止时调用的方法 /// &lt;/summary&gt; protected override void TearDown() { Log(&quot;TearDown OK&quot;); } }} MyClient.cs代码如下： using Photon.SocketServer;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using log4net;using PhotonHostRuntimeInterfaces; namespace ChatRoom{ /// /// 客户端 /// class MyClient : ClientPeer { public MyClient(InitRequest initRequest) : base(initRequest) { MyServer.Log(“客户端上线”); } /// &lt;summary&gt; /// 客户端断开连接 /// &lt;/summary&gt; /// &lt;param name=&quot;reasonCode&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;reasonDetail&quot;&gt;&lt;/param&gt; protected override void OnDisconnect(DisconnectReason reasonCode, string reasonDetail) { MyServer.Log(&quot;客户端下线&quot;); } /// &lt;summary&gt; /// 客户端发起请求 /// &lt;/summary&gt; /// &lt;param name=&quot;operationRequest&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;sendParameters&quot;&gt;&lt;/param&gt; protected override void OnOperationRequest(OperationRequest operationRequest, SendParameters sendParameters) { MyServer.Log(&quot;客户端发送请求&quot;); MyServer.Log(operationRequest.Parameters\\[0\\].ToString()); //回调客户端，与PhotonManger中的OnOperationResponse相对应 this.SendOperationResponse(new OperationResponse(), sendParameters); } }} 把脚本PhotonManger.cs放到Main Camera身上，保存场景。 启动PhotonControl程序，启动ChatServer服务器。 打开日志，查看日志情况。[ 在unity的scene场景按下空格键，Console出现“服务器给客户端的响应”，这表明我们PhotonManger里面的函数：peer.OpCustom和方法:OnOperationResponse() 方法调用成功。","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"},{"name":"Photon","slug":"Photon","permalink":"http://yoursite.com/tags/Photon/"}]},{"title":"利用Photon搭建服务器","slug":"利用photon搭建服务器","date":"2017-08-04T06:07:53.000Z","updated":"2020-07-05T08:56:50.863Z","comments":false,"path":"2017/08/04/利用photon搭建服务器/","link":"","permalink":"http://yoursite.com/2017/08/04/%E5%88%A9%E7%94%A8photon%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"首先从photon官网下载sdk，下载后直接解压有四个文件： deploy：存放photon的服务器控制程序和服务端Demo，也是我们使用次数最多的文件夹 doc：官方文档 lib：Photon类库，服务端需要引用 src-server：服务端Demo源代码 创建一个简单的服务端： 1.从vs新建一个类库，命名为ChatRoom，进去后把类名修改为MyServer，然后新建一个名叫MyClient的类。 2.点击项目名称下的引用，然后点击浏览，选择你photon解压的文件夹下的lib文件夹里面的一下dll： 3.给MyServer实现ApplicationBase接口，点击显示可能的修补程序 选择第一项： 实现抽象类： 4.接下来回到MyClient中，添加接口ClientPee 生成构造函数并实现抽象类： MyServer和MyClient两个类连接： protected override PeerBase CreatePeer(InitRequest initRequest) { return new MyClient(initRequest); } 5.复制以下代码到MyServer中，并在Setup()中调用 /// /// 产生一个log文件，存放我们的log /// protected virtual void InitLogging() { ExitGames.Logging.LogManager.SetLoggerFactory(Log4NetLoggerFactory.Instance); GlobalContext.Properties[“Photon:ApplicationLogPath”] = Path.Combine(this.ApplicationRootPath, “log”); GlobalContext.Properties[“LogFileName”] = “wjg” + this.ApplicationName; XmlConfigurator.ConfigureAndWatch(new FileInfo(Path.Combine(this.BinaryPath, “log4net.config”))); } 6.日志配置文件： 打开src-server\\\\Loadbalancing\\\\LoadBalancing文件夹，把log4net.config文件拖到我们的ChatRoom项目中，文件属性设置为始终复制[{% image http://www.wjgbaby.com/wp-content/uploads/2017/08/17080433.png '](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080428-300x235.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080428.png) 7.打开log4net，以下节点暂时用不到，可以删除[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080429-300x153.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080429.png) 8.在deploy新建文件夹ChatRoom，在ChatRoom新建文件夹bin，回到项目中，点击属性-->生成-->输出路径，将输出路径设置为我们新建的bin文件夹，然后生成解决方案。 9.打开deploy\\\\bin\\_Win64下的PhotonServer.config。 复制","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"},{"name":"Photon","slug":"Photon","permalink":"http://yoursite.com/tags/Photon/"}]},{"title":"利用七牛云获得10G存储空间和CDN加速","slug":"利用七牛云获得10g存储空间和cdn加速","date":"2017-08-04T06:00:58.000Z","updated":"2020-07-05T08:56:50.859Z","comments":false,"path":"2017/08/04/利用七牛云获得10g存储空间和cdn加速/","link":"","permalink":"http://yoursite.com/2017/08/04/%E5%88%A9%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E8%8E%B7%E5%BE%9710g%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%92%8Ccdn%E5%8A%A0%E9%80%9F/","excerpt":"","text":"1G的服务器内存显然是不够用的，但是我们可以把图片存放到七牛云里边以节省我们的1G空间 首先请确保你的网站已经备案过了，以下操作只有备案过才能进行 1.去七牛云官网注册账号并认证成功（https://www.qiniu.com） 2.点击立即添加， 3 .空间名字随便起，一会要用到，存储区域建议选个离你较劲的地方，前三个任选一个也行，访问控制选择公开空间，确认创建。 4.打开镜像存储 按要求输入网址，比如我的 5.点击添加，注意此功能需要预存10元才能激活 6.有个坑在这个加速域名的输入框内。千万不要输入自己网站的域名，我们需要在这里绑定一个二级域名。比如说我网站域名是www.wjgbaby.com，那么下面的框内我们只需要把前三个www字母替换成其他的就行了，我这里输入的是fff.wjgbaby.com，其他选项保持默认即可，点击创建。[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080415-300x212.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080415.png) 7.打开CDN加速空间，我们需要把CNAME地址解析到我们的域名，解析成功后会出现“发布成功”这四个字。 8.找到给自己的域名解析的地方,我的是腾讯云 第一处选择CNAME; 第二处选择你刚才创建的二级域名的前几个字母，比如我的是fff.wjgbaby.com,那么我就输入fff 第三处默认即可 第四处填写CNAME值 第五处选择10分钟 等几分钟看到发布成功这四个字，就说明到目前你做的都是正确的。 9．回到wordpress面板，搜索这两个插件并安装,激活启用他们 10．在七牛域名处填写我们的二级域名，比如我的fff.wjgbaby.com 空间名填写最开始我们创建的空间名 最下面两个key在七牛云的个人中心得到，输入即可。 11．向网站中上传张图片，会看到我们的图片已经存在了fff.wjgbaby.com下面的目录里，这说明图片已经镜像到七牛云存储，可以把我们本地的删掉了。","categories":[],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]},{"title":"最好的社交分享插件优享ushare","slug":"最好的社交分享插件优享ushare","date":"2017-08-04T05:50:34.000Z","updated":"2020-07-05T08:56:50.857Z","comments":false,"path":"2017/08/04/最好的社交分享插件优享ushare/","link":"","permalink":"http://yoursite.com/2017/08/04/%E6%9C%80%E5%A5%BD%E7%9A%84%E7%A4%BE%E4%BA%A4%E5%88%86%E4%BA%AB%E6%8F%92%E4%BB%B6%E4%BC%98%E4%BA%ABushare/","excerpt":"","text":"wordpress有很多社交分享插件，但大多是外国人用的，不适合国内用户用。其实国内也有不少，但是都不太好用，而且都特别丑，虽然说能自己写代码修改图标，但是对于普通用户来说还是麻烦了点。 今天我推荐的这款插件绝对是最好的，本站采用的就是这款。这款插件在江湖丢失多年，终于被我找到了，先来看看效果。 一共三种显示效果和三种摆放位置。 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080405-300x137.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080405.png)[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080406-300x142.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080406.png)[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080407-300x138.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080407.png) 操作也很简单，把自己想要的按钮直接拖拽到左右对齐和居中这三个框中就可以了 还有两种角落样式 [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080408-300x69.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080408.png)最终效果如下：[![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080409-300x124.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080409.png) 插件下载：链接：[http://pan.baidu.com/s/1pKXPqsF 密码：sc0n","categories":[],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]},{"title":"WP BaiDu Submit主动向百度推送文章","slug":"wp-baidu-submit主动向百度推送文章","date":"2017-08-04T05:33:49.000Z","updated":"2020-07-05T08:56:50.855Z","comments":false,"path":"2017/08/04/wp-baidu-submit主动向百度推送文章/","link":"","permalink":"http://yoursite.com/2017/08/04/wp-baidu-submit%E4%B8%BB%E5%8A%A8%E5%90%91%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0/","excerpt":"","text":"1.安装插件WP BaiDu Submit，启动后如下所示 [ ](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080402-300x194.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080402.png) 2.打开百度站长平台，注册账号并认证你的网站 [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080403-300x147.png)](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080403.png) 3.点击箭头所指会得到一个准入密钥：输入到我们插件的第二个输入框中，保存更改，此时可以去发篇新文章试试，看看插件里的提交结果。 [![](http://www.wjgbaby.com/wp-content/uploads/2017/08/17080404-300x181.png)","categories":[],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]},{"title":"WordPress优秀插件推荐","slug":"wordpress优秀插件推荐","date":"2017-08-04T04:22:10.000Z","updated":"2020-07-05T08:56:50.853Z","comments":false,"path":"2017/08/04/wordpress优秀插件推荐/","link":"","permalink":"http://yoursite.com/2017/08/04/wordpress%E4%BC%98%E7%A7%80%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"1.图片增加一个查看特效 Easy FancyBox Responsive Lightbox 2.图片延时加载 a3 Lazy Load 简单点说就是只加载页面上能看到的图片，从而减短页面的等待时间，当访客需要看其他的图片的时候再加载相应的图片。 3.代码高亮插件，自适应各种分辨率 Crayon Syntax Highlighter 这个显示代码的插件可能是同类中最好的的了 4.标签插件 Simple Tags 5.返回顶部按钮插件 Simple Back To Top启用后直接就能用 To Top爱折腾就用这个 6.图片水印 DX-Watermark自动给上传的图片加水印，很不错","categories":[],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]},{"title":"WordPress必装插件","slug":"wordpress必装插件","date":"2017-08-04T03:38:52.000Z","updated":"2020-07-05T08:56:50.851Z","comments":false,"path":"2017/08/04/wordpress必装插件/","link":"","permalink":"http://yoursite.com/2017/08/04/wordpress%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/","excerpt":"","text":"1.Disable Google Fonts 禁用谷歌字体 2.WP-DuoShuo-Gravatar 替换全球头像服务 3.Akiement Anti-Spam检测并去除垃圾评论 4:开启缓存：WP Fastest Cache，安装好后设置如下 5.登陆安全管理插件：Login Lockdown 启动插件，保持默认选项即可，插件启动后会尝试记录登陆失败的ip地址和时间、限制某ip或ip段登陆、还能控制同ip密码输入错误的次数，如果超过一定的次数，就封锁限制此ip，有效防止密码被暴力破解。 6.七牛云存储以及CDN加速 http://www.wjgbaby.com/2017/08/04/%e5%88%a9%e7%94%a8%e4%b8%83%e7%89%9b%e4%ba%91%e8%8e%b7%e5%be%9710g%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4%e5%92%8ccdn%e5%8a%a0%e9%80%9f/","categories":[],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]}],"categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"计算机系统","slug":"计算机系统","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"http://yoursite.com/tags/Ray-Tracing/"},{"name":"3D Math","slug":"3D-Math","permalink":"http://yoursite.com/tags/3D-Math/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Unity_PBR/GI渲染","slug":"Unity-PBR-GI渲染","permalink":"http://yoursite.com/tags/Unity-PBR-GI%E6%B8%B2%E6%9F%93/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Unity3D","slug":"Unity3D","permalink":"http://yoursite.com/tags/Unity3D/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://yoursite.com/tags/OpenGL/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"UGUI","slug":"UGUI","permalink":"http://yoursite.com/tags/UGUI/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Lua热更新","slug":"Lua热更新","permalink":"http://yoursite.com/tags/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"},{"name":"XML/JSON","slug":"XML-JSON","permalink":"http://yoursite.com/tags/XML-JSON/"},{"name":"Matlab图像处理","slug":"Matlab图像处理","permalink":"http://yoursite.com/tags/Matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://yoursite.com/tags/AssetBundle/"},{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Shader","slug":"Shader","permalink":"http://yoursite.com/tags/Shader/"},{"name":"AR-VR-MR","slug":"AR-VR-MR","permalink":"http://yoursite.com/tags/AR-VR-MR/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Processing","slug":"Processing","permalink":"http://yoursite.com/tags/Processing/"},{"name":"Misc","slug":"Misc","permalink":"http://yoursite.com/tags/Misc/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Photon","slug":"Photon","permalink":"http://yoursite.com/tags/Photon/"},{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]}